% Copyright 2015 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Animations}
\label{section-tikz-animations}


\begin{tikzlibrary}{animations}
  This library must be loaded in order to use animations with \tikzname.
\end{tikzlibrary}


\subsection{Introduction}

An \emph{animation} changes the appearance of some part of a graphic
over time. The archetypical animation is, of course, a \emph{movement} 
of some part of a picture, but a change of, say, the opacity of a path
is also an animation. \tikzname\ allows you to specify such animations
using special keys and notations.

\begin{codeexample}[width=8cm]
\tikz{
  \useasboundingbox (-3.8,-3.8) (3.8,3.8);
  \node [ animate me = {
           :text = { 0s = "yellow!80!black",
                      10s = "red",
                      20s = "yellow!80!black",
                      repeats } } ] {Sun};
  \begin{scope}[ animate me = { :drive = {
           along = {(0,0) circle [radius=2.5cm]},
           along in = 36.5s, repeats }}] 
    \node {Earth};
    \node [animate me = { :drive = {
             along = {(0,0) circle [radius=1cm]},
             along in = 2.8s, repeats }}] {Moon};
  \end{scope}
}
\end{codeexample}

Before we plunge into the details, it is important to understand what
\tikzname\ actually does when creating an animation: It does
\emph{not} (as all other animation packages do) precompute a sequence of
pictures that are later somehow displayed in rapid succession. Neither
does it insert an external video into the document. Rather, a
\tikzname\ animation is just an ``annotation'' in the output that a
certain attribute of a certain object should change over time in some
specific way when the object is displayed. It is the job of the
document viewer application to actually compute and display the
animation. The big advantage of this approach is that animations neither
increase the ouput file sizes noticably nor do they really slow down
\TeX: The hard and complicated calculations are done by the viewer
application. The disadvantage is, of course, that a document viewer
application must understand the annotations and actually compute and
display the animations. The \textsc{svg} format is a format for which
this is possible, the popular \textsc{pdf} format is not. Thus,
animations currently work only with \textsc{svg} output.

Adding an animation to a \tikzname\ picture is done as follows:

\begin{enumerate}
\item \emph{Before} or \emph{in the options of} the to-be-animated
  object you specify the object together with an \emph{attribute}
  that you wish to animate. Attributes are things like the fill color
  or the line width or the position of the object.
\item You specify \emph{when} this attribute should have \emph{which}
  values using a so-called \emph{timeline}. This is just a curve that
  specifies for each point in time which value the attribute should
  have.
\item You can additionally use further options to configure
  the animation, for instance you can specify that the animation
  should repeat or that it should only start when a certain object is
  clicked. 
\end{enumerate}

As a simple example, let us move a circle within thirty seconds by three
centimeters to the left:

\begin{codeexample}[width=2cm]
\tikz \draw [animate me = {:xshift = {0s = "0cm", 30s = "-3cm"}}] (0,0) circle (5mm);
\end{codeexample}

As can be seen, a special syntax is used in several places: Entries
with a colon such as |:xshift| specify an attribute, values
are specified in quotation marks. This syntax will be explained in 
more detail later on. 


\subsubsection{Concepts: (Graphic) Objects}

During an animation an attribute of a certain ``object''
changes over time. The term ``object'' has deliberately been chosen to
be somewhat vague since there are numerous different ``things'' whose
attributes can change. In detail, the following objects have
attributes that can be animated:

\begin{enumerate}
\item Nodes, which are created by the |\node| command (and, also,
  internally by commands such as |\graph|). For nodes, different parts
  of the node can be animated separately; for instance, you can
  animate the color of the background path, but also the color of the
  text, and also the color of the foreground path (though most nodes
  do not have a foreground path) and also the color of different text
  parts (though only few nodes have multiple text parts).
\item Graphic scopes, which are created by numerous command, including
  the |{scope}| environment, the |\scopes| command, but also |\tikz|
  itself creates a graphic scope and so does each node and even each
  path. 
\item View boxes, which can only be created using the |view| library.
\item Paths, which you create using the |\path| command or commands
  like |\draw| that call |\path| internally. However, the (usually
  background) path of a node can also be animated. Note that
  ``animating the path'' really means that the path itself should
  change over time; in essence, you can ``warp'' a path over time.
\end{enumerate}

In all of these cases, you must either specify the animation inside
the object's options using |animate me| or use the |name| key to name
the object and, then, refer to it in an |animate|. For nodes you can, of
course, use the |(|\meta{node name}|)| syntax to name the node. Recall
that you must \emph{always} specify the animation \emph{before} the
object is created; it is not possible to animate an already created
object.


\subsubsection{Concepts: Attributes}

In addition to the to-be-animated object, you must also choose an
\emph{attribute} that you wish to animate. Attributes are things like
the color of an object, the position, but also things like the line
width. The syntax for choosing attributes and the list of attributes
will be explained in detail later on.

Most attributes correspond directly to attributes that are directly
supported by the backend driver (\textsc{svg}), but this is not always
the case. For instance, for a node, \tikzname\ differentiates between
the fill color, the draw (stroke) color, and the text color, while
\textsc{svg} treats the text color are a special case of the fill
color. \tikzname\ will do some internal mappings to ensure that you
can animate the ``\tikzname\ attributes'' even when they are not
directly supported.



\subsubsection{Concepts: Timelines}

Once an object and an attribute have been chosen, a \emph{timeline}
needs to be established. This is, essentially, a curve that specifies
for each ``moment in time'' which value the attribute should have.

A timeline has a \emph{start} and an \emph{end,} but the start need
not be the ``moment zero'' (we will come to that) and may even be
negative, while the end may be at infinity. You specify the timeline
by specifying for certain points in time what the value is at that
moment; for all other moments the value is then interpolated. For
instance, if you specify that the attribute |:xshift| (the
``horizontal position'' of the object) is 0\,mm at time 5\,s and 10\,mm
at time 10\,s, then at 7.5\,s it will be 5\,mm and at 9\,s it will
be 8\,mm (assuming a linear interpolation). The resulting optical
effect will be that the object \emph{smoothly moves} by one centimeter
to the right over a period of five seconds, starting five seconds
after ``moment zero''.

Now, what is the ``moment zero,'' the ``beginning of an animation''? If
nothing else is specified, an animation starts immediately when the
graphic is shown and this is the moment zero relative to which the
timeline is measured. However, it is also possible to change this. In
particular, you can specify that the moment zero is when a particular
\emph{event} occurs such as the user clicking on another object or
another animation ending or starting.

The interpolation of values is not always a straightforward affair.
Firstly, for certain kinds of values is not clear how an interpolation
should be computed. How does one interpolate between two paths?
Between the colors red and green? Between the values |"visible"| and
|"hidden"|? In these cases, one must define carefully what the
interpolation should be. Secondly, you may wish to use a non-linear
interpolation, which is useful for ``easing'' motions: The visual
effect of the movement 
specified above is that the object sits still from moment $0$ for five
seconds, then there is an ``infinte acceleration'' causing the object
to suddenly move at the speed of 2\,mm per second, then there is no
acceleration at all for five seconds, causing the obejct to move for
one centimeter, followed by an ``infinite negative acceleration'' that
makes the object come to a full stop. As a viewer you experience these
infinite accelerations as ``unrealistic,'' spoiling the effect of
watching a (virtual) physical process. Non-linear interpolations allow
you to avoid this effect. 

Just as for specifying objects and attributes, there is also a special
syntax for specifying times and values.


\subsection{Syntax: Specifying Objects, Attributes, Times, and Values}

A special syntax is used for specifying animations. This syntax is
only available inside the following key:

\begin{key}{/tikz/animate=\meta{animation specification}}
  You must place all specifications of animations inside uses of
  |animate|. You can, and usually should, place the complete animation
  inside a single use of this key since it will reset the time and the
  time base (to be explained later), but you can, in principle, also
  split an animation over several uses of this command.

  The key can be used at all places where a \tikzname\ key is used;
  typically you will use it with a |{scope}| environment, inside the
  options of a node, or directly with the |\tikz| command:

\begin{codeexample}[width=2cm]
\tikz \node [fill, text = white, animate = {myself:fill = {0s = "red", 10s = "blue"}}] {Text};
\end{codeexample}
\begin{codeexample}[width=2cm]
\tikz [animate = {a node:fill = {0s = "red", 10s = "blue"}}]
  \node (a node) [fill, text = white] {Text};
\end{codeexample}

  The details of what, exactly, happens in the \meta{animation
    specification} will be described in the rest of the
  section. However, basically, an \meta{animation specification} is
  just a sequence of normal \tikzname\ key--value pairs that get
  executed with the path prefix |/tikz/animate| and with some special
  handlers installed. In particular, you can define styles for this
  key path and use them. For instance, we can define a |shake|
  animation like this:
\begin{codeexample}[width=3.2cm]
\tikzset{
  animate/shake/.style = {:xshift = { #1,
      0s = "0mm", 50ms = "1mm", 150ms = "-1mm", 250ms = "1mm", 300ms = "0mm" }}}
\tikz \node [fill = blue!20, draw=blue, very thick, circle,
  animate me = {shake = {begin on=click}}] {Click me};
\end{codeexample}

  Note that, as stressed earlier, you can only use the |animate| key
  to specify animations for objects that do not yet exist. The node
  and object names mentioned in a specification always refer to
  ``upcoming'' object; already existing objects of the same name are
  not influenced.
\end{key}

\begin{key}{/tikz/animate me=\meta{animation specification}}
  This key has almost the same effect as |animate|, only the object
  slot (to be explained in a moment) is preset to |myself:|. This
  means that |animate me=|\meta{foo} is just a shorthand for
  |animate={myself:| |=| |{|\meta{foo}|}| |}|.

  You typically use this key when you specify an animation locally
  inside the options of the to-be-animated object.
\end{key}



\subsubsection{Specifying Objects and Attributes}

Inside \meta{animation specification} (or, more generally, for all
keys executed with the path prefix |/tikz/animate|), you can specify
an object and an attribute of this object using the following syntax,
whose use is detected by the presence of a colon inside a key:
\begin{quote}
  \normalfont
  \opt{\meta{object name(s)}}|:|\opt{\meta{attribute(s)}}
  |={|\meta{options}|}|
  
  or
  
  \opt{\meta{object
      name(s)}}|:|\opt{\meta{attribute(s)}}|_|\opt{\meta{id}}
  |={|\meta{options}|}| 
\end{quote}
In the place to the left of an equal sign, where you would
normally use a key, you can instead place an object name and an
attribute separated by a colon. Additionally, the attribute may be
followed by an underscore and an \meta{id}, which identifies the
timeline (see Section~\ref{section-anim-timeline} for details).

Each of these values may be missing, in which case it is not changed
from its previous value.

The \meta{options} are now executed, still with the path prefix
|/tikz/animate| inside a local scope. Inside this scope (and only
there) the object and attribute will be set to the values given to the
left of the equal sign. Inside the \meta{options}, you can use the
same syntax once more and any new values given for the object
and\,/\,or the attribute will override any values given in the outer
scope.

Let us now have a look at some examples. First, we set the
\meta{object name} to |mynode| and |othernode| and the
\meta{attribute} to |opacity| and to |color|: 

\begin{codeexample}[code only]
animate = {
  mynode:opacity    = { 0s = "1",   5s = "0" },
  mynode:color      = { 0s = "red", 5s = "blue" },
  othernode:opacity = { 0s = "1",   5s = "0" },
}
\end{codeexample}

Next, we do the same, but ``in two steps'': First, we set the object
to |my node|, but leave the attribute open and, then, set the
attribute, but leave the object:
\begin{codeexample}[code only]
animate = {
  mynode: = {
    :opacity        = { 0s = "1",   5s = "0" },
    :color          = { 0s = "red", 5s = "blue" }
  },
  othernode:opacity = { 0s = "1",   5s = "0" },
}
\end{codeexample}
Note how both in  |mynode:| and in  |:opacity| and |:color| you must
provide the colon. Its presence signals that an object--attribute pair
is being specified; only now either the object or the attribute is
missing. 

We can also do it the other way round:
\begin{codeexample}[code only]
animate = {
  :opacity = {
    mynode:         = { 0s = "1",   5s = "0" },
    othernode:      = { 0s = "1",   5s = "0" }
  },
  mynode:color      = { 0s = "red", 5s = "blue" }
}
\end{codeexample}
Finally, if several objects should get the exact same values, we can
also group them:
\begin{codeexample}[code only]
animate = {
  {mynode,othernode}:opacity = { 0s = "1",   5s = "0" },
  mynode:color               = { 0s = "red", 5s = "blue" }
}
\end{codeexample}

As mentioned earlier, all references to objects will be interpreted to
future objects, never to objects already created. Furthermore,
\tikzname\ allows you to specify |myself| as \meta{object}. This will
be interpreted as the scope or node where the |animate| is
given (you cannot animate a node or scope name |myself|, this special
name always refers to the current node). In order to have all
attributes refer to the current object, you write:
\begin{codeexample}[code only]
\begin{scope} [animate = {
                 myself: = { % Animate the attribute of the scope
                   :opacity = { ... },
                   :xshift  = { ... }
                 }
               }]
  ...
\end{scope}
\end{codeexample}
The |animate me| key is a shorthand for |animate = { myself: = {|. 

The list of permissible attributes is given in
Section~\ref{section-anim-attrs}. 

    
\subsubsection{Specifying Timelines}

\label{section-anim-timeline}

    
\subsubsection{The With Key}



\subsection{The Semantics: Attributes That Can Be Animated}

\label{section-anim-attr}


\subsection{Controlling the Timeline}



\endinput


Creating an animation is done using the following command:

\begin{command}{\pgfanimateattribute\marg{attribute}\marg{options}}
  Adds an animation of the \meta{attribute} of a future \emph{object}
  to the current graphic. Attributes are things like the ``fill
  opacity'' or the transformation matrix or the line width.

  The \meta{options} are keys that configure how the attribute changes
  over time. Using the |entry| key multiple times you specify which
  value the chosen attribute should have at different points in
  time. Other keys, like |repeats|, allow you to specify how the
  animation behaves ``as a whole''. These keys are documented later in
  this section.

\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{opacity}{
    whom = node, begin on = {click}, entry = {0s}{1}, entry = {2s}{0} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!};
}
\end{codeexample}

  \medskip
  \textbf{The Attributes}
  
  In detail, the |\pgfanimateattribute| command opens a \TeX-scope,
  looks up the \emph{type} values of the specified \meta{attribute}
  have (if you wish to animate the |opacity| of an object, the type is
  ``scalar'' meaning that entries must be scalar numbers; when you
  animate the |fill| atttribute, the type is ``color'' and values 
  must be colors, and so on), and then executes the \meta{options} with
  the path prefix |/pgf/animation|. Finally, an appropriate system
  layer command |\pgfsysanimate...| is called to create the actual
  animation and the scope is closed.

  The following \meta{attributes} are permissible:
  
  \begin{tabular}{ll}
    \emph{Attribute} & \emph{Type} \\
    |draw|, |fill|              & color \\
    |line width|                & dimension \\
    |motion|                    & scalar \\
    |opacity|, |fill opacity|, |draw opacity|              & scalar \\
    |path|                      & path \\
    |rotate|                    & scalar \\
    |scale|                     & scaling \\
    |softpath|                  & softpath \\
    |translate|                 & point \\
    |view|                      & viewbox \\
    |visible|                   & boolean \\
    |xskew|, |yskew|            & scalar \\
  \end{tabular}

  These attributes are detailed in
  Sections \ref{section-base-animation-painting}
  to~\ref{section-base-animation-views}, but here is a quick overview:
  \begin{itemize}
  \item |draw| and |fill| refer to the color used to
    draw (stroke) and fill paths in an object, respectively. Typical
    values for this attribute are |red| or |black!10|.
  \item |line width| is, of course, the line width used in an
    object. Typical values are |0.4pt| or |1mm|. Note that you
    (currently) cannot use keys like |thin| or |thick| here, but this
    may change in the future.
  \item |motion| is a slightly special attribute: It allows you to
    specify a path along which the object should be moved (using the
    |along| key). The values given to the |entry| key for this
    attribute refer to a \emph{fraction of the distance along the
      path}. See the |along| key for details.
  \item |opacity| and the variants |fill opacity| and |draw opacity|
    animate the opacity of an object. Allowed values range between 0
    and 1.
  \item |path| allows you to animate a graphs path (it will
    morph). The ``values'' are now paths themselves. See
    Section~\ref{section-base-animation-paths} for details.
  \item |rotate| refers to a rotation of the object. Values for the
    |entry| key are the rotation angles like |0| or |90|.
  \item |scale| refers to the scaling of the object. Values are either
    single scalars values (like |1| or  |1.5|) or two numbers
    separated by a comma (lile |1,1.5| or |0.5,2|), referring to the
    $x$-scaling and $y$-scaling.
  \item |softpath| is a special case of the |path| attribute, see
    Section~\ref{section-base-animation-paths} once more.
  \item |translate| shifts the object by a certain vector. Values are
    points like |\pgfpoint{1cm}{2cm}|.
  \item |view| allows you to animate the view box of a view, see
    Section~\ref{section-base-animation-views} for details.
  \item |visible| refers to the visibility of an object. Allowed
    values are |visible| and |hidden|.
  \item |xskew| and |yskew| skew the object. Attributes are angles
    like |0| or |45| or even |90|.
  \end{itemize}

  \medskip
  \textbf{The Target Object}

  As stated earlier, the \meta{options} are used to specify the object
  whose attribute for which an animation should be added to the
  picture. Indeed, you \emph{must} specify the object explicitly using
  the |whom| key and you must do so \emph{before} the object is
  created. Note that, in contrast, in \textsc{svg} you can specify an
  animation more or less anywhere and then use hyper-references to
  link the animation to the to-be-animated object; \pgfname\ insists
  that you specify the animation before the object. This is a bit of a
  bother in some situations, but it is the only way to ensure that
  \pgfname\ has a fighting chance to attach some additional code to
  the object (which is necessary for almost all animations of the
  transformation matrix).

  \begin{key}{/pgf/animation/whom=\meta{id}\opt{|.|\meta{type}}}
    You \emph{must} use this key once which each call of the
    |\pgfanimateattribute| command. The \meta{id} and the optional
    \meta{type} (which is whatever follows the first dot) will be
    passed to |\pgfidrefnextuse|, see that command for details. 
  \end{key}

  As explained in the introduction of this chapter, an ``animation''
  is just a bit of special text in the output document asking a viewer
  application to animate the object at some later time. The
  |\pgfanimateattribute| command inserts this special text immediately,
  even though it refers to an object created only later on. Normally,
  this is not a problem, but the special text should be on the same
  page as the to-be-animated object. To ensure this, it suffices to
  call |\pgfanimateattribute| no earlier than the beginning of the
  |pgfpicture| containing the object.

  \medskip
  \textbf{Naming the Animation}

  You can assign a name to an animation for later (or early)
  reference. In particular, it is possible to begin \emph{another}
  animation relative to the beginning or end of this animation and for
  referencing this animation must be assigned a name. See the |of| and
  |of next| keys for details.

  \begin{key}{/pgf/animation/name=\meta{name}}
    Assigns a name to the animation by which it can be referenced
    using the |of| and |of next| keys in another animation.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {end, of next = my move animation, delay = 1s},
    entry = {0s}{0}, entry = {2s}{90} }
  \pgfanimateattribute{translate}{
    name = my move animation, whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{0cm}{1cm}} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
  \end{key}
\end{command}


\begin{command}{\pgfanimateattributecode\marg{attribute}\marg{code}}
  The command works like |\pgfanimateattribute|, only instead of
  \meta{options} you specify some \meta{code} whose job is to setup
  the options. 
\end{command}


\subsubsection{Specifying the Timeline}

The core key for specifying how an attribute varies over time is the
|entry| key:
\begin{key}{/pgf/animation/entry=\marg{time}\marg{value}}
  You use this key repeatedly to specify the different values that
  the \meta{attribute} should have over time. At the \meta{time}
  specified, the \meta{attribute} will have the value specified as
  \meta{value}:
  
\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click},
    entry = {0s}{0}, entry = {1s}{90}, entry = {1.1s}{45}, entry = {2s}{90}
  }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!};
}
\end{codeexample}

  You need to call |entry| once for each time in the timeline for
  which you want to specify a \meta{value} explicitly. Between these
  times, the values get interpolated (see below for details). You need
  to specify the \meta{time}s in non-decreasing order (it is
  permissible and sometimes also necessary to specify the same time
  twice, namely to create a ``jump'' of the value of some attribute).

  The \meta{time} is parsed using the command |\pgfparsetime|
  described later.

  \medskip
  \textbf{Start and end of the timeline.}
  The first and last times of the timeline are a bit special: The
  timeline starts on the first time and the duration of the timeline is
  the difference between the first and last time. ``Starting'' on the
  start time actually means that any beginnings (see the |begin| and
  |end| keys) get offset by the start time; similarly end times are
  offset by this value. 

  \medskip
  \textbf{Syntax of the values.}
  The syntax of the \meta{value} varies according to the type of the
  \meta{attribute}. In detail, these are:

  \begin{tabular}{lp{12cm}}
    \emph{Type} & \emph{Syntax} \\
    color & Standard color syntax like |red| or |black!10| \\
    scalar & A value parsed using |\pgfmathparse| \\
    dimension & A dimension parsed using |\pgfmathparse| \\
    path & A sequence of path construction commands \\
    softpath & A sequence of soft path construction commands \\
    scaling & A scalar value or a pair of scalar values separated by a
              comma \\
    point & A \pgfname-point like |\pgfpoint{1cm}{5mm}| \\
    viewbox & Two \pgfname-points \\
    boolean & |true| or |false| \\
  \end{tabular}  

  \medskip
  \textbf{Interpolation between key times.}
  You use the |entry| key repeatedly, namely once for each ``key
  time,'' which is a time point for which you specify the value of the
  attribute explicitly. Between these key times, the attribute's value
  is interpolated.
  
  Suppose that an animation is supposed to interpolate a attribute's
  value between the two values |50| and |100| over a time of
  10\,s. The   simplest way of doing so is to do a linear
  interpolation, where the value as, say, 1\,s is 55, at 2\,s it is
  60, and so on. Unfortunately, the linear interpolation does not
  ``look'' nice in many cases since the acceleration of a linear
  interpolation is zero  during the animation, but infinite at the
  beginning and at the end; which looks ``jerky.''

  To avoid this, you can specify that the time--attribute curve should 
  not be a straight line, but rather a curve. You specify this curve
  using a spline. The most logical ``coordinate rectangle'' used for
  this spline in our example would be |(0s,50)| and |(10s,100)| and we
  would like to specify something like
\begin{codeexample}[code only]
  (0s,50) .. controls (5s,50) and (9s,100) .. (10s,100)
\end{codeexample}
  This would result in a time--attribute curve where
  the attribute at |50| changes slowly at 0\,s and also arrives slowly
  at |100| at 10\,s, but speeds up between these values.

  We call the first control point |(5s,50)| the ``exit control'' and
  call |(9s,100)| the ``entry control'': The first control dictates
  how quickly or slowly a time point is left, the second dictates how
  quickly or slowly we enter the next one.

  The control points are, however, not specified in the coordinate
  system indicated above. Rather, the rectangle |(0s,50)| to
  |(10s, 100)| gets normalized to |(0,0)| to |(1,1)|. The control
  point |(5s,50)| would thus become |(0.5,0)| and |(9s,100)| becomes
  |(0.9,1)|. 
  
  \begin{key}{/pgf/animations/exit control=\marg{time
        fraction}\marg{value fraction}}
    Specifies an exit control using two values as above. The spline
    from above would be specified as follows:

\begin{codeexample}[code only]
exit control={0.5}{0},
entry control={0.9}{1},
entry={0s}{50},
entry={10s}{100}
\end{codeexample}

    Note that the curve specified using exit and entry controls must
    be ``well-behaved'' in the sense that exactly one value must be
    specified for each point in time in the time interval.

    In the next three example, we first specify a ``smooth'' exit from
    the start position, then a smooth arrival at the end position,
    and, finally both.
    
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    exit control={0.5}{0},
    entry = {0s}{\pgfpointorigin},
    linear, 
    entry = {1s}{\pgfpoint{0cm}{-1cm}},
    entry = {2s}{\pgfpoint{0cm}{-2cm}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin},
    entry = {1s}{\pgfpoint{0cm}{-1cm}},
    entry control={.5}{1},
    entry = {2s}{\pgfpoint{0cm}{-2cm}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    exit control={0.5}{0},
    entry = {0s}{\pgfpointorigin},
    linear, % revert to default
    entry = {1s}{\pgfpoint{0cm}{-1cm}},
    entry control={.5}{1},
    entry = {2s}{\pgfpoint{0cm}{-2cm}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  \end{key}

  \begin{key}{/pgf/animations/entry control=\marg{time
        fraction}\marg{value fraction}}
    Works like |exit control|.
  \end{key}

  \begin{key}{/pgf/animations/linear}
    A shorthand for |exit control={0}{0}, entry control={1}{1}|. This
    will (re)install a linear curve.
  \end{key}

  The opposite of having a smooth curve between two values, is to have
  a ``jump'' from one value to the next. There are two keys for this:


  \begin{key}{/pgf/animations/stay}
    Specifies that inside the time interval the value ``stays put'' at
    the first value till the end of the interval, where it will jump
    to the second value. This is similar to an exit control where the
    curve is ``infinitely flat.''
    
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin},
    stay,
    entry = {1s}{\pgfpoint{0cm}{-1cm}},
    linear,
    entry = {2s}{\pgfpoint{0cm}{-2cm}},
    entry = {3s}{\pgfpoint{0cm}{-3cm}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  \end{key}
  
  \begin{key}{/pgf/animations/jump}
    Works like the |stay| key, but will cause the value to ``jump to''
    the new value right at the beginning of the time interval. It is
    similar to an entry control specifying a ``flat'' curve.

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin},
    jump,
    entry = {1s}{\pgfpoint{0cm}{-1cm}},
    linear,
    entry = {2s}{\pgfpoint{0cm}{-2cm}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  \end{key}


  \medskip
  \textbf{Paced animations.}
  Using the |entry| key you have detailed control over which value an
  attribute should have at different times. However, you are sometimes
  more interested in specifying the values and much less in specifying
  the exact moment in time when these values should be attained: When
  you specify the an object should move around between many different
  points, you typically wish to specify something like ``the object
  should be here at |0s| and there at |10s| and in between it should be
  here, here, and here -- and I do not care when, just make the
  movement evenly paced.'' In such cases the following key is useful:
  \begin{key}{/pgf/animation/paced}
    Requests that the times specified for the entries of the timeline
    are ignored, except for the first and last one. Instead, the times
    are recomputed such that an object moving between the specified
    values does so at a constant speed. Note that this notion of
    ``moving between values at a constant speed'' makes more sense for
    some attributes than for others: It makes lots of sense for a
    canvas shift and a bit of sense for a rotation angle or a color
    and no sense for something like |visibility|.    
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin},
    entry = {2s}{\pgfpoint{0cm}{1cm}},
    entry = {4s}{\pgfpoint{1mm}{1cm}}
  }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; }
\end{codeexample}
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click}, paced,
    entry = {0s}{\pgfpointorigin},
    entry = {2s}{\pgfpoint{0cm}{1cm}},
    entry = {4s}{\pgfpoint{1mm}{1cm}}
  }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; }
\end{codeexample}
  \end{key}
  \begin{key}{/pgf/animation/unpaced}
    The opposite of |paced| and the default. It restores the default
    behavior of using splines to interpolate between values at the
    given key times.
  \end{key}
\end{key}


\begin{command}{\pgfparsetime\marg{time}}
  This command works like |\pgfmathparse| (indeed, it calls is
  internally), but returns the result in the macro |\pgftimeresult|
  rather than |\pgfmathresult|. Furthermore, the following changes are
  installed:

  \begin{itemize}
  \item 
    The postfix operator |s| is added, which has no effect.
  \item The postfix operator |ms| is added, which devides a number by
    1.000, so |2ms| equals 0.002s.
  \item
    The postfix operator |min| is added, which multiplies a number by
    60.
  \item The postfix operator |h| is added, which multiplies a number by
    3.600.
  \item The infix operator |:| is redefined, so that it multiplies its
    first argument by 60 and adds the second. This implies that
    |1:20| equals 80s and |01:00:00| equals 3600s.
  \item The parsing of octal numbers is switched off to allow things
    like |01:08| for 68s.
  \end{itemize}
\end{command}



\subsubsection{Animating Color, Opacity, and Visibility}
\label{section-base-animation-painting}

You can animate the color of the target object of an animation using
the attributes |fill| or |draw|, which animate the fill color and the
drawing (stroking) color, respectively. To animate both the fill and
draw color, you need to create two animations, one for each.

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{fill}{
    whom = node.background, begin on = {click}, entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{draw}{
    whom = node.background, begin on = {click}, entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

When the target of a color animation is a scope, you animate
the color ``used in this scope'' for filling or stroking. However,
when an object inside the scope has its color set explicitly, this
color overrules the color of the scope:

\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{fill}{
    whom = example, begin on = {click, of next=node},
    entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
  \begin{scope}[name = example]
    \fill (1.1,0) rectangle ++ (1,1);
    \fill [blue] (1.5,0.5) rectangle ++ (1,1);
  \end{scope}
}
\end{codeexample}

Note that in certain cases, a graphic scope may contain graphic
objects with their colors set explicitly ``in places where you do not
expect it'': In particular, a node normally consists at least of a
background path and a text. For both the text and for the background
path, colors will be set for the text and also for the path
explicitly. This means that when you pick the fill attribute of a node
as the target of an animation, you will \emph{not} animate the color
of the background path in case this color has been set
explicitly. Instead, you must choose the background path of the node
as the target of the animation. Fortunately, this is easy to achieve
since when the background path of a node is created, the identifier
type is set to |background|, which in turn allows you to access it as
\meta{node}|.background| through the |whom| key.

The text of a node also gets it color set explicitly, which means that
a change of the node's scope's color has no effect on the text
color. Instead, you must choose \meta{name}|.text| as the target (or,
if the node has more parts, use the name of the part as the identifier
type instead of |text|).

\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{fill}{
    whom = example, begin on = {click, of next=node},
    entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
  \node at (2,0) (example) [fill = blue!20, circle] {No effect}; }
\end{codeexample}


\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{fill}{
    whom = example.background, begin on = {click, of next=node},
    entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
  \node at (2,0) (example) [fill = blue!20, circle] {Effect}; }
\end{codeexample}


\begin{codeexample}[]
\tikz {
  \pgfanimateattribute{fill}{
    whom = example.text, begin on = {click, of next=node},
    entry = {0s}{white}, entry = {2s}{red} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
  \node at (2,0) (example) [fill = blue!20, circle, font=\huge] {Text}; }
\end{codeexample}

Similarly to the color, you can also set the opacity used for filling
and for drawing. You specify the opacity using a number between 0
(transparent) and 1 (opaque). 

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{fill opacity}{
    whom = node, begin on = {click}, entry = {0s}{1}, entry = {2s}{0} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{draw opacity}{
    whom = node, begin on = {click}, entry = {0s}{1}, entry = {2s}{0} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

Unlike colors, where there is no joint attribute for filling and
stroking, there is a single |opacity| attribute in addition to the above
two attributes. If supported by the driver, it treats the graphic
object to which it is applied as a transparency group. In essence,
``this attribute does what you want'' at least in most situations.

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{opacity}{
    whom = node, begin on = {click}, entry = {0s}{1}, entry = {2s}{0} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}

The last attribute that concerns colors and visibility is the
Boolean |visible| attribute. The difference to an opacity of |0| is
that an invisible object cannot be clicked and does not need to be
rendered. The (only) two possible values for this attribute are
|false| and |true|.

\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{visible}{
    whom = node, begin on = {click}, entry = {0s}{false}, entry = {2s}{false} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}


\subsubsection{Animating Paths and their Rendering}
\label{section-base-animation-paths}

You can animate the appearance of a path in the following ways:

\begin{itemize}
\item You can animate the line width:
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{line width}{
    whom = node, begin on = {click}, entry = {0s}{1pt}, entry = {2s}{5mm} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
  The possible values passed to the |entry| key are, of course,
  dimensions. 
\item You can animate the dash phase:
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{dash phase}{
    whom = node.background, begin on = {click}, entry = {0s}{0pt}, entry = {2s}{10pt} }
  \node (node) [dashed, fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  Again, the possible values are dimensions.
\item You can animate the dash pattern:
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{dash pattern}{
    whom = node, begin on = {click}, entry = {0s}{{10pt}{1pt}}, entry = {2s}{{1pt}{10pt}} }
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  To specify the dash pattern, you specify a sequence of ``on and
  off'' dimensions; see the second argument of |\pgfsetdash| for
  details. Note that you \emph{must} specify the same number of
  elements in all patterns of a timeline: You cannot specify that the
  dash pattern for |1s| is |{1pt}{2pt}| and for |2s| is
  |{1pt}{3pt}{2pt}| since the number of elements would differ. In
  particular, you cannot (sensibly) use |current value| for the first
  entry since this corresponds to an empty dash pattern (even when you
  have specified a dash pattern for the target object: this pattern
  will not be attached to the to-be-animated scope or object but to a
  surrounding scope and, thus, the to-be-animated scope will not have
  any dash pattern installed).
\item Finally, you can animate the path itself:
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfanimateattribute{path}{
    whom = node.background.path, begin on = {click, of next=node},
    entry = {0s}{\pgfpathellipse{\pgfpointorigin}{\pgfpointxy{2}{0}}{\pgfpointxy{0}{1}}},
    entry = {2s}{\pgfpathellipse{\pgfpointxy{1}{0}}{\pgfpointxy{1}{1}}{\pgfpointxy{0.25}{.75}}}}
  \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!}; 
}
\end{codeexample}
  The path is specified by giving path construction commands as in the
  above example. They will be executed in a special protected scope to
  ensure that they have only little side effects.

  As for the dash pattern, you must ensure that all paths in the
  timeline have the same structure (same sequence of path construction
  commands); only the coordinates may differ. In particular, you
  cannot say that the path at |1s| is a rectangle using
  |\pgfpathrectangle| and at |2s| is a circle using
  |\pgfpathcircle|. Instead, you would have to ensure that at both
  times that path consists of appropriate BÃ©zier curves.

  Unlike the dash pattern, the to-be-animated object is, indeed, the
  path itself and not some special scope. This means that you can use
  the |current value| for the start path. However, this also means
  that you really must pick \emph{the path object} as the target of
  the animation. In conjunction with \tikzname, this will be an object
  of type |path| as in the above example.
\end{itemize}



\subsubsection{Animating Transformations  and Views}
\label{section-base-animation-views}


In order to animate the canvas transformation matrix, you do not
animate an attribute called ``|transform|'' (or something
similar). Rather, there are several keys that all manipulate the
canvas transformation matrix in 
different ways. These keys, taken in appropriate combination, allow
you to achieve any particular canvas transformation matrix.

Let us start with the basic keys that allow you to change the
canvas transformation matrix directly:

\begin{itemize}
\item The |scale| attribute adds an animation of the scaling:
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{scale}{
    whom = node, begin on = {click}, entry = {0s}{1}, entry = {2s}{1.5,2} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
  The values passed to the |entry| key must either be single scalar
  values or a pair of such numbers separated by a comma (which then
  refer to the $x$- and $y$-scaling).
\item The |rotate| key adds an animation of the rotation:
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, entry = {0s}{45}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
  The values are scalar values representing a rotation in degrees.
\item The |xskew| and |yskew| keys (and also |skew x| and |skew y|,
  which are aliases) add an animation of the skew (given
  in degrees, not as a slant):
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{xskew}{
    whom = node, begin on = {click}, entry = {0s}{0}, entry = {2s}{45} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
  The values are scalar values.
\item The |translate| key adds an animation of the translation (shift):
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{translate}{
    whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{1cm}{1cm}} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
  The values are \pgfname-points.
\end{itemize}

For all of these attributes, the following key is of importance:
\begin{key}{/pgf/animation/origin=\meta{pgf point}}
  An animation of the canvas transformation is added to all other
  transformations from surrounding or interior scopes. This means
  that, in particular, the origin of a canvas transformation is, by
  default, the origin of the canvas of the scope surrounding the
  transformation object.

  For some canvas animations, like a rotation or a scaling, you will
  typically wish to use a different origin (like the center of an
  object that is to be rotated or scaled). You can achieve this effect
  by surrounding the object by a scope that shifts the canvas to the
  desired origin, followed by a scope whose transformation matrix you
  animate, followed by a scope that shifts back the canvas.

  The |origin| key simplifies this process by allowing you to specify
  the origin of the transformation directly. Internally, however, all
  this key does is to create the above-mentioned scopes with the
  necessary shifts.
  
\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click},
    origin = \pgfpoint{1cm}{1cm}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; 
}
\end{codeexample}
\end{key}


A second way of changing the canvas transformation matrix is to use
the |motion| key:

\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{motion}{
    whom = node, begin on = {click},
    along = \pgfpathcircle{\pgfpointorigin}{5mm},
    entry = {0s}{0}, entry = {2s}{1} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}


\begin{key}{/pgf/animation/along=\meta{path}}
  This key (or |rotate along|) must be used with |motion| attribute to
  specify a path along which the transformation matrix will be
  ``moved'' (that is, a shift transformation will be added to the
  different points on the path).

  The values passed to the |entry| key specify fractions of the
  distance along the \meta{path}. That means, when you provide a value
  of |0|, you reference the start point of the path, a value of |1|
  references the end of the path and |0.5| referenced the point
  halfway along the path.

\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{motion}{
    whom = node, begin on = {click},
    along = \pgfpathcircle{\pgfpointorigin}{5mm},
    entry = {0s}{0}, entry = {1s}{0.5}, entry = {2s}{0.25}, entry={3s}{1} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
\end{key}

  
\begin{key}{/pgf/animation/rotate along=\meta{Boolean} (default true)}
  When set to |true|, the |along| key additionally adds a rotation
  that varies in such a way that a tangent to the path always points right. 

\begin{codeexample}[width=2.3cm]
\tikz [very thick] {
  \pgfanimateattribute{motion}{
    whom = node, begin on = {click},
    rotate along = true,
    along = \pgfpathmoveto {\pgfpointorigin}
            \pgfpathcurveto{\pgfpoint{1cm}{0cm}}{\pgfpoint{1cm}{0cm}}{\pgfpoint{1cm}{1cm}},
    entry = {0s}{0}, entry = {2s}{1} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}  
\end{key}

The final method of changing the transformation matrix is to animate 
a \emph{view.} A view is a canvas transformation that shifts and
scales the canvas in such a way that a certain rectangle ``matches''
another rectangle: The idea is that you ``look through'' a ``window''
(the view) and ``see'' a certain area of the canvas. View animation do
not allow you to do anything that cannot also be done using the
|translate| and |scale| keys in combination, but it often much more
natural to animate which area of a graphic you wish to see than to
compute and animate a scaling and shift explicitly.

In order to use a view, you first need to create a view, which is done
using a |{pgfviewboxscope}|, see Section~\ref{section-base-view},
which is used by the |view| library internally. You can then animate
the view using the |view| attribute. The values passed to the |entry|
key must be two \pgfname-points, each surrounded by parentheses.

\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{view}{
    whom = me.view, begin on = {click, of next=n1}, freeze at end,
    entry = {0s}{current value}, entry = {2s}{{\pgfpoint{5mm}{5mm}}{\pgfpoint{15mm}{20mm}}} }
  \pgfanimateattribute{view}{
    whom = me.view, begin on = {click, of next=n2}, freeze at end,
    entry = {0s}{current value}, entry = {2s}{{\pgfpoint{10mm}{10mm}}{\pgfpoint{15mm}{15mm}}} }
  \node (n1) at (0,0) [fill = blue!20, draw = blue, circle] {Zoom blue}; 
  \node (n2) at (2,0) [fill = blue!20, draw = blue, circle] {Zoom red};

  \draw [green!50!black] (4,0) rectangle (6,2);
  \begin{scope}[name = me, meet = {view (0,0) (2,2) at (4,0) (6,2)}]
    \draw [blue] (5mm,5mm) rectangle (15mm,20mm);
    \node at (5mm,5mm) [circle, fill=blue, text=white] {blue};
    
    \draw [red] (10mm,10mm) rectangle (15mm,15mm);
    \node at (10mm,10mm) [circle, fill=red, text=white, font=\tiny] {red};
  \end{scope}
}
\end{codeexample}  


\subsubsection{Commands for Specifying Timing: Beginnings  and
  Endings}


Using the |entry| key repeatedly, you specify a timeline: The
\meta{time} used with the first use of the |entry| key in a timeline
is the start time and the \meta{time} in the last |entry| key is the
stop time. However, this leaves open then question of when the whole
timeline is to be started: The moment the document is opened? When the
page is displayed? When the user scrolls to the to-be-animated object?
When some other object is clicked? The key |begin|, and also the key
|end|, allow you to specify answers to these questions.

\begin{key}{/pgf/animation/begin=\meta{time}}
  This key specifies when the ``moment |0s|'' should be relative to
  the moment when the current graphic is first displayed. You can use
  this key multiple times, in this case the timeline is restarted for
  each of the times specified (if it is already running, it will be
  reset). If no |begin| key is given at all, the effect is the same as
  if |begin=0s| had been specified.

  It is permissible to set \meta{time} to a negative value.
\end{key}

\begin{key}{/pgf/animation/end=\meta{time}}
  This key will truncate the timeline so that it ends \meta{time}
  after the display of the graphic, provided the timeline begins
  before the specified end time. For instance, if you specify a
  timeline starting at 2\,s and ending at 5\,s and you set |begin| to
  1\,s and |end| to 4\,s, the timeline will run, relative to the moment
  when the graphic is displayed from 3\,s to 4\,s.
  
\begin{codeexample}[width=3cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin = 2s, end = 4s,
    entry = {1s}{0}, entry = {2s}{90}, entry = {3s}{180}, entry = {4s}{270} }
  \node (node) [fill = blue!20, draw = blue, circle] {Turn after 3s!}; }
\end{codeexample}
\end{key}

It is not immediately clear what should happen with the attribute of
an object when an animation ends: Should it revert to its original
value ``as if there had never been an animation'' or should it ``stay
at the last value''? The following key governs what should happen:

\begin{key}{/pgf/animation/freeze at end=\meta{true or false} (default
  true, initially false)}
  When set to |true|, whenever a timeline ends (either because the
  last time of timeline has been reached or because an |end| or
  |end of| key have ended it prematurely), the last value the
  attribute had because of the animation ``stays put.'' When set to
  |false|, which is the initial value, once an animation ends, its
  effect will be removed ``as if it never happened.''
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{ 
    whom = node, begin on = {click}, freeze at end,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; }
\end{codeexample}
\end{key}

Instead of specifying the beginning of the timeline relative to the
moment to to-be-animated graphic is displayed, you can also set the
``moment |0s|'' to the moment a specific \emph{event} happens using
the following key:

\begin{key}{/pgf/animation/begin on=\meta{options}}
  The \meta{options} will be executed with the path
  |/pgf/animation/events| and will cause a new beginning to be added
  to the list of possible beginnings for the timeline (so the uses of
  this key accumulate). Each ``beginning'' is just another possible
  ``moment |0s|'' for the timeline. For instance, when the
  \meta{options} are set to |click|, then each time the graph is
  clicked a moment |0s| starts for the timeline.

  Most events are ``caused'' or ``happen to'' some object. For
  instance, the |click| event happens when you click on a certain
  object. In order to specify this object, use the following two keys
  inside the \meta{options}: |of| and |of next|. If neither of these
  keys are given, the to-be-animated object is used.
  
  \begin{key}{/pgf/animation/events/of=\meta{id}\opt{|.|\meta{type}}}
    This specifies a graphic object id in the same way as the |whom|
    key, also with an optional \meta{type}. This is the object that
    ``causes'' the event to happen.

    Unlike the |whom| key, which always refers to a not-yet-existing
    object, this key always refers to an already existing
    object, namely to the most recent use of the \meta{id}. In the
    following example, the referenced object is the node with the
    label |2| since it is the most recently referenced node with
    \meta{id} |X|.
\begin{codeexample}[width=3cm]
\tikz [very thick] {
  \node (X) at (1,1.2)  [fill = blue!20, draw = blue, circle] {1};
  \node (X) at (1,0.4)  [fill = blue!20, draw = blue, circle] {2};
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click, of = X}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = red!20, draw = red, rectangle] {Anim}; 
  \node (X) at (1,-0.4) [fill = blue!20, draw = blue, circle] {3};
  \node (X) at (1,-1.2) [fill = blue!20, draw = blue, circle] {4};
}
\end{codeexample}
  \end{key}
  
  \begin{key}{/pgf/animation/events/of next=\meta{id}\opt{|.|\meta{type}}}
    This key works like the |of| key, only it refers to a future
    (actually, the next) object with the given \meta{id}, not to a
    previous one. This, in the next example, the referenced node is
    the one with label |3|.
\begin{codeexample}[width=3cm]
\tikz [very thick] {
  \node (X) at (1,1.2)  [fill = blue!20, draw = blue, circle] {1};
  \node (X) at (1,0.4)  [fill = blue!20, draw = blue, circle] {2};
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click, of next = X}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = red!20, draw = red, rectangle] {Anim}; 
  \node (X) at (1,-0.4) [fill = blue!20, draw = blue, circle] {3};
  \node (X) at (1,-1.2) [fill = blue!20, draw = blue, circle] {4};
}
\end{codeexample}
  \end{key}

  The following key allows you to specify the event that should cause
  the animation to start:
  \begin{key}{/pgf/animation/events/event=\meta{event name}}
    Specifies the name of the event whose occurrence should start the
    timeline. Which events are supported depends on the device on
    which the animation is displayed, the output format
    (\textsc{svg} or some other format), and the setup of scripts, but
    here is a list of events supported by ``plain \textsc{svg}'':
    |click|, |focusin|, |focusout|, |mousedown|,  |mouseup|,
    |mouseover|, |mousemove|, |mouseout|, |begin|, |end|. However, the
    following keys make using these events simpler:
    \begin{key}{/pgf/animate/events/click}
      This is a shorthand for |event=click|. This event gets triggered
      when the user clicks on the triggering object with a mouse (or
      something equivalent).
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/mouse down}
      Shorthand for |event=mousedown|. The event gets
      triggered when the user presses a mouse button down on the object.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {mouse down}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/mouse up}
      Shorthand for |event=mouseup| and gets triggered, of course,
      when a pressed button is released on the object.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {mouse up}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/mouse over}
      Shorthand for |event=mouseover|. The event gets triggered the
      moment the mouse cursor moves over the object.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {mouse over}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/mouse move}
      Shorthand for |event=mousemove|. The event gets triggered lots
      of times, namely each time the mouse moves while being ``over''
      the object.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {mouse move}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/mouse out}
      Shorthand for |event=mouseout|. The opposite of |mouse over|:
      triggered when the mouse leaves the object.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {mouse out}, entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/begin}
      Shorthand for |event=begin|. The ``begin'' refers to the
      beginning of another animation, namely the one referenced by
      |of| or |of whom|. This means that the current animation will
      begin when some other animation begins.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {begin, of next = my move animation, delay = 1s},
    entry = {0s}{0}, entry = {2s}{90}, add }
  \pgfanimateattribute{translate}{
    name = my move animation, whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{0cm}{1cm}} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/end}
      Shorthand for |event=end|. Again, the ``end'' refers to the
      end of another animation, namely the one referenced by
      |of| or |of whom|. This means that the current animation will
      \emph{begin} when some other animation \emph{ends.}
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {end, of next = my move animation, delay = 1s},
    entry = {0s}{0}, entry = {2s}{90} }
  \pgfanimateattribute{translate}{
    name = my move animation, whom = node, begin on = {click},
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{0cm}{1cm}} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
    \end{key}
    \begin{key}{/pgf/animation/events/focus in}
      This is a shorthand for |event=focusin|. This event gets
      triggered when the graphic object gets the focus (this usually
      makes sense only for text input fields).
    \end{key}
    \begin{key}{/pgf/animation/events/focus out}
      This is a shorthand for |event=focusout|.
    \end{key}
  \end{key}

  In addition to the events specified using the generic |event| key,
  there are two further events that take a parameter:
  \begin{key}{/pgf/animation/events/repeat=\meta{number}}
    The event is triggered when a repeating animation has been
    repeated \meta{number} times.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {repeat = 2, of next = my move animation},
    entry = {0s}{0}, entry = {2s}{90} }
  \pgfanimateattribute{translate}{
    name = my move animation, whom = node, begin on = {click}, repeats = 4,
    entry = {0s}{\pgfpointorigin}, entry = {1s}{\pgfpoint{0cm}{1cm}} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; 
}
\end{codeexample}
  \end{key}
  
  \begin{key}{/pgf/animation/events/key=\meta{key}}
    The event is triggered when the keyboard key \meta{key} has been
    pressed. For security reasons, a viewer may suppress this.
  \end{key}
  
  Having specified the event, you can also specify a delay relative to
  this event:

  \begin{key}{/pgf/animation/events/delay=\meta{time}}
    Specifies that the timeline should not start with the event, but,
    rather, be delayed by \meta{time}.
  \end{key}
  
\end{key}

When you use |begin on| to start an animation when a certain event is
triggered, it is not clear what should happen when the event is
triggered \emph{again}. Should this be ignored completely? Should it
only be ignored while the animation is running? The following key
allows you to specify when should happen:

\begin{key}{/pgf/animation/restart=\meta{choice} (default true)}
  You can set \meta{choice} to one of the following:
  \begin{itemize}
  \item |true| means that the animation will restart each time the
    event is triggered. If the animation is already running, it will
    be reset to its beginning.
  \item |false| means that once the animation has started once, it
    will never be restarted.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{ 
    whom = node, begin on = {click}, restart = false,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; }
\end{codeexample}  
  \item |never| means the same as |false|.
  \item |when not active| means that the animation will restart when
    the event is triggered, but \emph{not} while the animation is
    running.     
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{ 
    whom = node, begin on = {click}, restart = when not active,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Here!}; }
\end{codeexample}  
  \end{itemize}
\end{key}

Just like |begin on| specifies when a timeline begins relative to some
event, the |end on| allows you to stop is early when some event
happens:

\begin{key}{/pgf/animation/end on=\meta{options}}
  Works exactly like |begin on|, one possible end of the timeline is
  specified using the \meta{options}.
\end{key}


\subsubsection{Commands for Specifying Timing: Repeats}

Normally, a timeline is displayed once and then ends. You can,
however, request that the timeline should be repeated a certain number
of times or indefinitely. 

\begin{key}{/pgf/animation/repeats=\meta{specification}}
  Use this key to specify that the timeline animation should repeat at
  the end. The \meta{specification} must consist of two parts, each of
  which may be empty. The first part is one of the following:
  \begin{itemize}
  \item Empty, in which case the timeline repeats forever.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, repeats,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
  \item A \meta{number} (like |2| or |3.25|), in which case the
    timeline repeats \meta{number} times.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, repeats = 2.5,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
  \item The text ``|for| \meta{time}'' (like |for 2s| or |for 300ms|),
    in which case the timeline repeats however often necessary so that
    it  stops exactly after \meta{time}.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, repeats = for 3s,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
  \end{itemize}
  The second part of the specification must be one of the following:
  \begin{itemize}
  \item Empty, in which case each time the timeline is restarted, the
    attribute's value undergoes the same series of values it did
    previously.
  \item The text |accumulating|. This has the effect that each time
    the timeline is restarted, the attribute values specified by the
    timeline are \emph{added} to the value from the previous
    iteration(s). A typical example is an animation that shifts a
    scope by, say, 1\,cm over a time of 1\,s. Now, if you repeat this
    five times, normally the scope will shift 1\,cm for 1\,s then
    ``jump back,'' shift again, jump back, and so on for five
    times. In contrast, when the repeats are accumulating, the scope
    will move by 5\,cm over 5\,s in total.    
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, repeats = accumulating,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{rotate}{
    whom = node, begin on = {click}, repeats = 5 accumulating,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}
  \end{itemize}
\end{key}

\begin{key}{/pgf/animation/repeat=\meta{specification}}
  This is an alias for |repeats|.  
\end{key}



\subsubsection{Commands for Specifying Accumulation}

A timeline specifies a value for an attribute of an object for each
moment in time. Normally, the value specified in this way will replace
the value attribute had originally, but in many situations it is
desirable that the timeline's values are only \emph{added} to the
original value. This is particularly important for canvas
transformations since, there, you may wish to specify that there is a
shift \emph{and} a rotation, both of which should happen at the same
time. However, adding values also makes sense for other attributes.

\begin{key}{/pgf/animation/add}
  This key causes the values specified in a timeline to be added to
  the value an attribute has. In particular, when two animations are
  in effect at the same time, the second one would normally ``win,''
  but the |add| key ensures that this animation is also in effect.
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{translate}{ whom = node, begin on = {click}, 
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{0cm}{1cm}} }
  \pgfanimateattribute{rotate}{ whom = node, begin on = {click}, replace,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}  
\begin{codeexample}[width=2cm]
\tikz [very thick] {
  \pgfanimateattribute{translate}{ whom = node, begin on = {click}, 
    entry = {0s}{\pgfpointorigin}, entry = {2s}{\pgfpoint{0cm}{1cm}} }
  \pgfanimateattribute{rotate}{ whom = node, begin on = {click}, add,
    entry = {0s}{0}, entry = {2s}{90} }
  \node (node) [fill = blue!20, draw = blue, circle] {Click me!}; }
\end{codeexample}  
\end{key}

\begin{key}{/pgf/animation/replace}
  Causes an animation's value to replace the attribute's value. If
  there are several animations for the same value, only the ``last one
  wins''. This is the default behavior.
\end{key}


\endinput



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual"
%%% End: 
