% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Actions on Paths}

Once a path has been constructed, different things can be done with
it. It can be drawn (or stroked) with a ``pen,'' it can be filled with
a color or shading, it can be used for clipping subsequent drawing, it
can be used to specify the extend of the picture---or  any
combination of these actions at the same time.

To decide what is to be done with a path, two methods can be
used. First, you can use a special-purpose command like |\draw| to
indicate that the path should be drawn. However, commands like |\draw|
and |\fill| are just abbreviations for special cases of the more
general method: Here, the |\path| command is used to specify the
path. Then, options encountered on the path indicate what should be
done with the path.

For example, |\path (0,0) circle (1cm);| means ``This is a path
consisting of a circle around the origin. Do not do anything with it
(throw it away).'' However, if the option |draw| is encountered
anywhere on the path, the circle will be drawn. ``Anywhere'' is any
point on the path where an option can be given, which is everywhere
where a path command like |circle (1cm)| or |rectangle (1,1)| or even
just |(0,0)| would also be allowed. Thus, the following commands all
draw the same circle:
\begin{codeexample}[code only]
\path [draw] (0,0) circle (1cm);
\path (0,0) [draw] circle (1cm);
\path (0,0) circle (1cm) [draw];
\end{codeexample}
Finally, |\draw (0,0) circle (1cm);| also draws a path, because
|\draw| is an abbreviation for |\path [draw]| and thus the command
expands to the first line of the above example.

Similarly, |\fill| is an abbreviation for |\path[fill]| and
|\filldraw| is an abbreviation for the command
|\path[fill,draw]|. Since options accumulate, the following commands
all have the same effect: 
\begin{codeexample}[code only]
\path [draw,fill]   (0,0) circle (1cm);
\path [draw] [fill] (0,0) circle (1cm);
\path [fill] (0,0) circle (1cm) [draw];
\draw [fill] (0,0) circle (1cm);
\fill (0,0) [draw] circle (1cm);
\filldraw (0,0) circle (1cm);
\end{codeexample}

In the following subsection the different actions are explained that
can be performed on a path. The following commands are abbreviations for
certain sets of actions, but for many useful combinations there are no
abbreviations:

\begin{command}{\draw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[draw]|.
\end{command}

\begin{command}{\fill}
  Inside |{tikzpicture}| this is an abbreviation for |\path[fill]|.
\end{command}

\begin{command}{\filldraw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[fill,draw]|.
\end{command}

\begin{command}{\pattern}
  Inside |{tikzpicture}| this is an abbreviation for |\path[pattern]|.
\end{command}

\begin{command}{\shade}
  Inside |{tikzpicture}| this is an abbreviation for |\path[shade]|.
\end{command}

\begin{command}{\shadedraw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[shade,draw]|.
\end{command}

\begin{command}{\clip}
  Inside |{tikzpicture}| this is an abbreviation for |\path[clip]|.
\end{command}

\begin{command}{\useasboundingbox}
  Inside |{tikzpicture}| this is an abbreviation for |\path[use as bounding box]|.
\end{command}

\begin{command}{\node}
  Inside |{tikzpicture}| this is an abbreviation for |\path node|. Note
  that, for once, |node| is not an option but a path operation.
\end{command}

\begin{command}{\coordinate}
  Inside |{tikzpicture}| this is an abbreviation for |\path coordinate|.
\end{command}



\subsection{Specifying a Color}

The most unspecific option for setting colors is the following:

\begin{itemize}
  \itemoption{color}|=|\meta{color name}%
  \indexoption{color option}%
  This option sets the color that is used for fill, drawing, and text
  inside the current scope. Any special settings for filling colors or
  drawing colors are immediately ``overruled'' by this option.

  The \meta{color name} is the name of a previously defined color. For
  \LaTeX\ users, this is just a normal ``\LaTeX-color'' and the
  |xcolor| extensions are allows. Here is an example:

\begin{codeexample}[]
\tikz \fill[color=red!20] (0,0) circle (1ex);
\end{codeexample}

  It is possible to ``leave out'' the |color=| part and you can also
  write:
\begin{codeexample}[]
\tikz \fill[red!20] (0,0) circle (1ex);
\end{codeexample}
  What happens is that every option that \tikzname\ does not know, like
  |red!20|, gets a ``second chance'' as a color name.

  For plain \TeX\ users, it is not so easy to specify colors since
  plain \TeX\ has no ``standardized'' color naming
  mechanism. Because of this, \pgfname\ emulates the |xcolor| package,
  though the emulation is \emph{extremely basic} (more precisely, what
  I could hack together in two hours or so). The emulation allows you
  to do the following:
  \begin{itemize}
  \item Specify a new color using |\definecolor|. Only the two color
    models |gray| and |rgb| are supported.
    \example |\definecolor{orange}{rgb}{1,0.5,0}|
  \item Use |\colorlet| to define a new color based on an old
    one. Here, the |!| mechanism is supported, though only ``once''
    (use multiple |\colorlet| for more fancy colors).
    \example |\colorlet{lightgray}{black!25}|
  \item Use |\color|\marg{color name} to set the color in the current
    \TeX\ group. |\aftergroup|-hackery is used to restore the color
    after the group.
  \end{itemize}
\end{itemize}

As pointed out above, the |color=| option applies to ``everything''
(except to shadings), which is not always what you want. Because of
this, there are several more specialized color options. For example,
the |draw=| option sets the color used for drawing, but does not
modify the color used for filling. These color options are documented
where the path action they influence is described.


\subsection{Drawing a Path}

You can draw a path using the following option:
\begin{itemize}
  \itemoption{draw}\opt{|=|\meta{color}}
  Causes the path to be drawn. ``Drawing'' (also known as
  ``stroking'') can be thought of as picking up a pen and moving it
  along the path, thereby leaving ``ink'' on the canvas.

  There are numerous parameters that influence how a line is drawn,
  like the thickness or the dash pattern. These options are explained
  below.

  If the optional \meta{color} argument is given, drawing is done
  using the given \meta{color}. This color can be different from the
  current filling color, which allows you to draw and fill a path with
  different colors. If no \meta{color} argument is given, the last
  usage of the |color=| option is used.

  If the special color name |none| is given, this option causes
  drawing to be ``switched off.'' This is useful if a style has
  previously switched on drawing and you locally wish to undo this
  effect. 

  Although this option is normally used on paths to indicate that the
  path should be drawn, it also makes sense to use the option with a
  |{scope}| or |{tikzpicture}| environment. However, this will
  \emph{not} cause all path to drawn. Instead, this just sets the
  \meta{color} to be used for drawing paths inside the environment.

\begin{codeexample}[]
\begin{tikzpicture}
  \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
\end{tikzpicture}
\end{codeexample}
\end{itemize}

The following subsections list the different options that influence
how a path is drawn. All of these options only have an effect if the
|draw| options is given (directly or indirectly).

\subsubsection{Graphic Parameters: Line Width, Line Cap, and Line Join}

\label{section-cap-joins}

\begin{itemize}
  \itemoption{line width}|=|\meta{dimension}
  Specifies the line width. Note the space. Default: |0.4pt|.

\begin{codeexample}[]
  \tikz \draw[line width=5pt] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{itemize}

There are a number of predefined styles that provide more ``natural''
ways of setting the line width. You can also redefine these
styles. Remember that you can leave out the |style=| when setting a
style.

\begin{itemize}
  \itemstyle{ultra thin}
  Sets the line width to 0.1pt.
\begin{codeexample}[]
  \tikz \draw[ultra thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{very thin}
  Sets the line width to 0.2pt.
\begin{codeexample}[]
  \tikz \draw[very thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{thin}
  Sets the line width to 0.4pt.
\begin{codeexample}[]
  \tikz \draw[thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{semithick}
  Sets the line width to 0.6pt.
\begin{codeexample}[]
  \tikz \draw[semithick] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{thick}
  Sets the line width to 0.8pt.
\begin{codeexample}[]
  \tikz \draw[thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{very thick}
  Sets the line width to 1.2pt.
\begin{codeexample}[]
  \tikz \draw[very thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}

  \itemstyle{ultra thick}
  Sets the line width to 1.6pt.
\begin{codeexample}[]
  \tikz \draw[ultra thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{itemize}

\begin{itemize}
  \itemoption{cap}|=|\meta{type}
  Specifies how lines ``end.'' Permissible \meta{type} are |round|,
  |rect|, and |butt| (default). They have the following effects:

\begin{codeexample}[]
\begin{tikzpicture}
  \begin{scope}[line width=10pt]
    \draw[cap=rect]  (0,0 ) -- (1,0);
    \draw[cap=butt]  (0,.5) -- (1,.5);
    \draw[cap=round] (0,1 ) -- (1,1);
  \end{scope}
  \draw[white,line width=1pt]
    (0,0 ) -- (1,0) (0,.5) -- (1,.5) (0,1 ) -- (1,1);
\end{tikzpicture}
\end{codeexample}

  \itemoption{join}|=|\meta{type}
  Specifies how lines ``join.'' Permissible \meta{type} are |round|,
  |bevel|, and |miter| (default). They have the following effects:

\begin{codeexample}[]
\begin{tikzpicture}[line width=10pt]
  \draw[join=round] (0,0) -- ++(.5,1) -- ++(.5,-1);
  \draw[join=bevel] (1.25,0) -- ++(.5,1) -- ++(.5,-1); 
  \draw[join=miter] (2.5,0) -- ++(.5,1) -- ++(.5,-1); 
  \useasboundingbox (0,1.5); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}

  \itemoption{miter limit}|=|\meta{factor}
  When you use the miter join and there is a very sharp corner (a
  small angle), the miter join may protrude very far over the actual
  joining point. In this case, if it were to protrude by 
  more than \meta{factor} times the line width, the miter join is
  replaced by a bevel join. Default value is |10|.

\begin{codeexample}[]
\begin{tikzpicture}[line width=5pt]
  \draw                 (0,0) -- ++(5,.5) -- ++(-5,.5);
  \draw[miter limit=25] (6,0) -- ++(5,.5) -- ++(-5,.5);
  \useasboundingbox (14,0); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}
\end{itemize}

\subsubsection{Graphic Parameters: Dash Pattern}

\begin{itemize}
  \itemoption{dash pattern}|=|\meta{dash pattern}
  Sets the dashing pattern. The syntax is the same as in
  \textsc{metafont}. For example |on 2pt off 3pt on 4pt off 4pt| means ``draw
  2pt, then leave out 3pt, then draw 4pt once more, then leave out 4pt
  again, repeat''. 

\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 2pt off 3pt on 4pt off 4pt]
  \draw (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}

  \itemoption{dash phase}|=|\meta{dash phase}
  Shifts the start of the dash pattern by \meta{phase}.

\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 20pt off 10pt]
  \draw[dash phase=0pt] (0pt,3pt) -- (3.5cm,3pt);
  \draw[dash phase=10pt] (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
\end{itemize}

As for the line thickness, some predefined styles allow you to set the
dashing conveniently.

\begin{itemize}
\itemstyle{solid}
  Shorthand for setting a solid line as ``dash pattern.'' This is the default.

\begin{codeexample}[]
\tikz \draw[solid] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{dotted}
  Shorthand for setting a dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{densely dotted}
  Shorthand for setting a densely dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[densely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{loosely dotted}
  Shorthand for setting a loosely dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[loosely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{dashed}
  Shorthand for setting a dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{densely dashed}
  Shorthand for setting a densely dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[densely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}

  \itemstyle{loosely dashed}
  Shorthand for setting a loosely dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[loosely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{itemize}


\subsubsection{Graphic Parameters: Draw Opacity}

When a line is drawn, it will normally ``obscure'' everything behind
it as if you has used perfectly opaque ink. It is also possible to ask
\tikzname\ to use an ink that is a little bit (or a big bit)
transparent. To do so, use the following option:

\begin{itemize}
  \itemoption{draw opacity}|=|\meta{value}
  This option sets ``how transparent'' lines should be. A value of |1|
  means ``fully opaque'' or ``not transparent at all,'' a value of |0|
  means ``fully transparent'' or ``invisible.'' A value of |0.5|
  yields lines that are semitransparent.

  Note that when you use PostScript as your output format,
  this option works only with recent versions of GhostScript.
   
\begin{codeexample}[]
\begin{tikzpicture}[line width=1ex]
  \draw (0,0) -- (3,1);
  \filldraw [fill=examplefill,draw opacity=0.5] (1,0) rectangle (2,1);
\end{tikzpicture}
\end{codeexample}
\end{itemize}

Note that the |draw opacity| options only sets the opacity of drawn
lines. The opacity of fillings is set using the option
|fill opacity| (documented in Section~\ref{section-fill-opacity}. The
option |opacity| sets both at the same time. 

\begin{itemize}
  \itemoption{opacity}|=|\meta{value}
  Sets both the drawing and filling opacity to \meta{value}.

  The following predefined styles make it easier to use this option:
  \begin{itemize}
    \itemstyle{transparent}
    Makes everything totally transparent and, hence, invisible.

\begin{codeexample}[]
\tikz{\fill[red]             (0,0)   rectangle (1,0.5);
      \fill[transparent,red] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{ultra nearly transparent}
    Makes everything, well, ultra nearly transparent.

\begin{codeexample}[]
\tikz{\fill[red]                      (0,0)   rectangle (1,0.5);
      \fill[ultra nearly transparent] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{very nearly transparent}
\begin{codeexample}[]
\tikz{\fill[red]                     (0,0)   rectangle (1,0.5);
      \fill[very nearly transparent] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{nearly transparent}
\begin{codeexample}[]
\tikz{\fill[red]                (0,0)   rectangle (1,0.5);
      \fill[nearly transparent] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{semitransparent} 
\begin{codeexample}[]
\tikz{\fill[red]             (0,0)   rectangle (1,0.5);
      \fill[semitransparent] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{nearly opaque}   
\begin{codeexample}[]
\tikz{\fill[red]           (0,0)   rectangle (1,0.5);
      \fill[nearly opaque] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{very nearly opaque} 
\begin{codeexample}[]
\tikz{\fill[red]                (0,0)   rectangle (1,0.5);
      \fill[very nearly opaque] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{ultra nearly opaque}
\begin{codeexample}[]
\tikz{\fill[red]                 (0,0)   rectangle (1,0.5);
      \fill[ultra nearly opaque] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
    \itemstyle{opaque}
    This yields completely opaque drawings, which is the default.
\begin{codeexample}[]
\tikz{\fill[red]    (0,0)   rectangle (1,0.5);
      \fill[opaque] (0.5,0) rectangle (1.5,0.25); }
\end{codeexample}
  \end{itemize}  
\end{itemize}




\subsubsection{Graphic Parameters: Arrow Tips}

When you draw a line, you can add arrow tips at the ends. It is
only possible to add one arrow tip at the start and one at the end. If
the path consists of several segments, only the last segment gets
arrow tips. The behavior for paths that are closed is not specified
and may change in the future.

\begin{itemize}
\itemoption{arrows}\opt{|=|\meta{start arrow kind}|-|\meta{end arrow kind}}
  This option sets the start and end arrow tips (an empty value as in |->|
  indicates that no arrow tip should be drawn at the start).%
  \indexoption{arrows}

  \emph{Note: Since the arrow option is so often used, you can leave
    out the text |arrows=|.} What happens is that every option that
  contains a |-| is interpreted as an arrow specification.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[->]        (0,0)   -- (1,0);
  \draw[o-stealth] (0,0.3) -- (1,0.3);
\end{tikzpicture}
\end{codeexample}

  The permissible values are all predefined arrow tips, though
  you can also define new arrow tip kinds as explained in
  Section~\ref{section-arrows}. This is often necessary to obtain
  ``double'' arrow tips and arrow tips that have a fixed size. Since
  |pgflibraryarrows| is loaded by default, all arrow tips described in
  Section~\ref{section-library-arrows} are available.

  One arrow tip kind is special: |>| (and all arrow tip kinds containing the
  arrow tip kind such as |<<| or \verb!>|!). This arrow tip type is not  
  fixed. Rather, you can redefine it using the |>=| option, see
  below. 

  \example You can also combine arrow tip types as in
\begin{codeexample}[]
\begin{tikzpicture}[thick]
  \draw[to reversed-to]   (0,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \draw[[-latex reversed] (1,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \draw[latex-)]          (2,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \useasboundingbox (-.1,-.1) rectangle (3.1,1.1); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}

  \itemoption{>}|=|\meta{end arrow kind}
  This option can be used to redefine the ``standard'' arrow tip |>|. The
  idea is that different people have different ideas what arrow tip kind
  should normally be used. I prefer the arrow tip of \TeX's |\to| command
  (which is used in things like $f\colon A \to B$). Other people will
  prefer \LaTeX's standard arrow tip, which looks like this: \tikz
  \draw[-latex] (0,0) -- (10pt,1ex);. Since the arrow tip kind |>| is
  certainly the most ``natural'' one to use, it is kept free of any
  predefined meaning. Instead, you can change it by saying |>=to| to
  set the ``standard'' arrow tip kind to \TeX's arrow tip, whereas |>=latex|
  will set it to \LaTeX's arrow tip and |>=stealth| will use a
  \textsc{pstricks}-like arrow tip.

  Apart from redefining the arrow tip kind |>| (and |<| for the start),
  this option also redefines the following arrow tip kinds: |>| and |<| as
  the swapped version of \meta{end arrow kind}, |<<| and |>>| as
  doubled versions, |>>| and |<<| as swapped doubled versions, %>>
  and \verb!|<! and \verb!>|! as arrow tips ending with a vertical bar.

\begin{codeexample}[]
\begin{tikzpicture}[scale=2]
  \begin{scope}[>=latex]
    \draw[->]    (0pt,6ex) -- (1cm,6ex);
    \draw[>->>]  (0pt,5ex) -- (1cm,5ex);
    \draw[|<->|] (0pt,4ex) -- (1cm,4ex);
  \end{scope}
  \begin{scope}[>=diamond]
    \draw[->]    (0pt,2ex) -- (1cm,2ex);
    \draw[>->>]  (0pt,1ex) -- (1cm,1ex);
    \draw[|<->|] (0pt,0ex) -- (1cm,0ex);
  \end{scope} 
\end{tikzpicture}
\end{codeexample}

  \itemoption{shorten >}|=|\meta{dimension}
  This option will shorten the end of lines by the given
  \meta{dimension}. If you specify an arrow tip, lines are already
  shortened a bit such that the arrow tip touches the specified endpoint
  and does not ``protrude over'' this point. Here is an example:

\begin{codeexample}[]
\begin{tikzpicture}[line width=20pt]
  \useasboundingbox (0,-1.5) rectangle (3.5,1.5);
  \draw[red]        (0,0) -- (3,0);
  \draw[gray,->]    (0,0) -- (3,0);
\end{tikzpicture}
\end{codeexample}

  The |shorten >| option allows you to shorten the end on the line
  \emph{additionally} by the given distance. This option can also be
  useful if you have not specified an arrow tip at all.

\begin{codeexample}[]
\begin{tikzpicture}[line width=20pt]
  \useasboundingbox (0,-1.5) rectangle (3.5,1.5);
  \draw[red]                     (0,0) -- (3,0);
  \draw[-to,shorten >=10pt,gray] (0,0) -- (3,0);
\end{tikzpicture}
\end{codeexample}

  \itemoption{shorten <}|=|\meta{dimension} works like |shorten >|,
  but for the start.
\end{itemize}



\subsubsection{Graphic Parameters: Double Lines and Bordered Lines}

\begin{itemize}
  \itemoption{double}\opt{|=|\meta{core color}}
  This option causes ``two'' lines to be drawn instead of a single
  one. However, this is not what really happens. In reality, the path
  is drawn twice. First, with the normal drawing color, secondly with
  the \meta{core color}, which is normally |white|. Upon the second
  drawing, the line width is reduced. The net effect is that it
  appears as if two lines had been drawn and this works well even with
  complicated, curved paths:

\begin{codeexample}[]
\tikz \draw[double]
  plot[smooth cycle] coordinates{(0,0) (1,1) (1,0) (0,1)};
\end{codeexample}

  You can also use the doubling option to create an effect in which a
  line seems to have a certain ``border'':

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- (1,1);
  \draw[draw=white,double=red,very thick] (0,1) -- (1,0);
\end{tikzpicture}
\end{codeexample}

  \itemoption{double distance}|=|\meta{dimension}
  Sets the distance the ``two'' lines are spaced apart (default is
  0.6pt). In reality, this is the thickness of the line that is used
  to draw the path for the second time. The thickness of the
  \emph{first} time the path is drawn is twice the normal line width
  plus the given \meta{dimension}. As a side-effect, this option
  ``selects'' the |double| option.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[very thick,double]              (0,0) arc (180:90:1cm);
  \draw[very thick,double distance=2pt] (1,0) arc (180:90:1cm);
  \draw[thin,double distance=2pt]       (2,0) arc (180:90:1cm);
\end{tikzpicture}
\end{codeexample}
\end{itemize}


  




\subsection{Filling a Path}
\label{section-rules}
To fill a path, use the following option:
\begin{itemize}
  \itemoption{fill}\opt{|=|\meta{color}}
  This option causes the path to be filled. All unclosed parts of the
  path are first closed, if necessary. Then, the area enclosed by the
  path is filled with the current filling color, which is either the
  last color set using the general |color=| option or the optional
  color \meta{color}. For self-intersection paths and for paths
  consisting of several closed areas, the ``enclosed area'' is
  somewhat complicated to define and two different definitions exist,
  namely the nonzero winding number rule and the even odd rule, see
  the explanation of these options, below.

  Just as for the |draw| option, setting \meta{color} to |none|
  disables filling locally.

\begin{codeexample}[]
\begin{tikzpicture}
  \fill (0,0) -- (1,1) -- (2,1);
  \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}

  If the |fill| option is used together with the |draw| option (either
  because both are given as options or because a |\filldraw| command
  is used), the path is filled \emph{first}, then the path is drawn
  \emph{second}. This is especially useful if different colors are
  selected for drawing and for filling. Even if the same color is
  used, there is a difference between this command and a plain 
  |fill|: A ``filldrawn'' area will be slightly larger than a filled
  area because of the thickness of the ``pen.''

\begin{codeexample}[]
\begin{tikzpicture}[fill=examplefill,line width=5pt]
  \filldraw (0,0) -- (1,1) -- (2,1);
  \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}
\end{itemize}



\subsubsection{Graphic Parameters: Fill Pattern}

\label{section-fill-pattern}
Instead of filling a path with a single solid color, it is also
possible to fill it with a \emph{tiling pattern}. Imagine a small tile
that contains a simple picture like a star. Then these tiles are
(conceptually) repeated infinitely in all directions, but clipped
against the path.

Tiling patterns come in two variants: \emph{inherently 
  colored patterns} and \emph{form-only patterns}. An inherently colored
pattern is, say, a red star with a black border and will always look
like this. A form-only pattern may have a different color each time
it is used, only the form of the pattern will stay the same. As such,
form-only patterhns do not have any colors of their own, but when it
is used the current \emph{pattern color} is used as its color.

Patterns are not overly flexible. In particular, it is not possible to
change the size or orientation of a pattern without declaring a new
pattern. For complicated case, it may be easier to use two nested
|\foreach| statements to simulate a pattern, but patterns are rendered
\emph{much} more quickly than simulated ones.

\begin{itemize}
  \itemoption{pattern}\opt{|=|\meta{name}}
  This option causes the path to be filled with a pattern. If the
  \meta{name} is given, this pattern is used, otherwise the pattern
  set in the enclosing scope is used. As for the |draw| and |fill|
  options, setting \meta{name} to |none| disables filling locally.

  The pattern works like a fill color. In particular, setting a new
  fill color will fill the path with a solid color once more.

  Strangely, no \meta{name}s are permissible by default. You neet to
  load for instance |pgflibrarypatterns|, see
  Section~\ref{section-library-patterns}, to install predefined
  patterns.  
  
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[pattern=dots] (0,0) circle (1cm);
  \draw[pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}

  \itemoption{pattern color}|=|\meta{color}
  This option is used to set the color to be used for form-only
  patterns. This option has no effect on inherently colored patterns. 
  
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[pattern color=red,pattern=fivepointed stars]  (0,0) circle (1cm);
  \draw[pattern color=blue,pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
  \def\mypath{(0,0) -- +(0,1) arc (180:0:1.5cm) -- +(0,-1)}
  \fill   [red]                                \mypath;
  \pattern[pattern color=white,pattern=bricks] \mypath;
\end{tikzpicture}
\end{codeexample}
\end{itemize}


\subsubsection{Graphic Parameters: Interior Rules}

The following two options can be used to decide how interior points
should be determined:
\begin{itemize}
  \itemoption{nonzero rule}
  If this rule is used (which is the default), the following method is
  used to determine whether a given point is ``inside'' the path: From
  the point, shoot a ray in some direction towards infinity (the
  direction is chosen such that no strange borderline cases
  occur). Then the ray may hit the path. Whenever it hits the path, we
  increase or decrease a counter, which is initially zero. If the ray
  hits the path as the path goes ``from left to right'' (relative to
  the ray), the counter is increased, otherwise it is decreased. Then,
  at the end, we check whether the counter is nonzero (hence the
  name). If so, the point is deemed to lie ``inside,'' otherwise it is
  ``outside.'' Sounds complicated? It is.

\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=examplefill]
  % Clockwise rectangle
  (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
  % Counter-clockwise rectangle
  (0.25,0.25) -- (0.75,0.25) -- (0.75,0.75) -- (0.25,0.75) -- cycle;

  \draw[->] (0,1) -- (.4,1);
  \draw[->] (0.75,0.75) -- (0.3,.75);

  \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $-1+1 = 0$};

  \begin{scope}[yshift=-3cm]
    \filldraw[fill=examplefill]
    % Clockwise rectangle
    (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
    % Clockwise rectangle
    (0.25,0.25) -- (0.25,0.75) -- (0.75,0.75) -- (0.75,0.25) -- cycle;

    \draw[->] (0,1) -- (.4,1);
    \draw[->] (0.25,0.75) -- (0.4,.75);
      
    \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $1+1 = 2$};
  \end{scope}
\end{tikzpicture}
\end{codeexample}

\itemoption{even odd rule}
  This option causes a different method to be used for determining the
  inside and outside of paths. While it is less flexible, it turns out
  to be more intuitive.

  With this method, we also shoot rays from the point for which we
  wish to determine whether it is inside or outside the filling
  area. However, this time we only count how often we ``hit'' the path
  and declare the point to be ``inside'' if the number of hits is odd.

  Using the even-odd rule, it is easy to ``drill holes'' into a path.
  
\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=examplefill,even odd rule]
    (0,0) rectangle (1,1) (0.5,0.5) circle (0.4cm);
  \draw[->] (0.5,0.5) -- +(0,1) [above] node{crossings: $1+1 = 2$};
\end{tikzpicture}
\end{codeexample}
\end{itemize}



\subsubsection{Graphic Parameters: Fill Opacity}

\label{section-fill-opacity}
Analogously to the |draw opacity|, you can also set the filling
opacity:

\begin{itemize}
  \itemoption{fill opacity}|=|\meta{value}
  This option sets the opacity of fillings. In addition to filling
  operations, this opacity also applies to text and images.

  Note, again, that when you use PostScript as your output format,
  this option works only with recent versions of GhostScript.
  
\begin{codeexample}[]
\begin{tikzpicture}[thick,fill opacity=0.5]
  \filldraw[fill=red]   (0:1cm)    circle (12mm);
  \filldraw[fill=green] (120:1cm)  circle (12mm);
  \filldraw[fill=blue]  (-120:1cm) circle (12mm);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
  \fill[red] (0,0) rectangle (3,2);

  \node                   at (0,0) {\huge A};
  \node[fill opacity=0.5] at (3,2) {\huge B};
\end{tikzpicture}
\end{codeexample}
\end{itemize}


\subsection{Shading a Path}

You can shade a path using the |shade| option. A shading is like a
filling, only the shading changes its color smoothly from one color to
another.

\begin{itemize}
  \itemoption{shade}
  Causes the path to be shaded using the currently selected shading
  (more on this later). If this option is used together with the
  |draw| option, then the path is first shaded, then drawn.

  It is not an error to use this option together with the |fill|
  option, but it makes no sense.

\begin{codeexample}[]
\tikz \shade (0,0) circle (1ex);
\end{codeexample}

\begin{codeexample}[]
\tikz \shadedraw (0,0) circle (1ex);
\end{codeexample}
\end{itemize}

For some shadings it is not really clear how they can ``fill'' the
path. For example, the |ball| shading normally looks like this: \tikz
\shade[shading=ball] (0,0) circle (0.75ex);. How is this supposed to
shade a rectangle? Or a triangle?

To solve this problem, the predefined shadings like |ball| or |axis|
fill a large rectangle completely in a sensible way. Then, when the
shading is used to ``shade'' a path, what actually happens is that the
path is temporarily used for clipping and then the rectangular shading
is drawn, scaled and shifted such that all parts of the path are
filled.


\subsubsection{Choosing a Shading Type}

The default shading is a smooth transition from gray
to white and from above to bottom. However, other shadings are also
possible, for example a shading that will sweep a color from the
center to the corners outward. To choose the shading, you can use the
|shading=| option, which will also automatically invoke the |shade|
option. Note that this does \emph{not} change the shading color, only
the way the colors sweep. For changing the colors, other options are
needed, which are explained below.

\begin{itemize}
  \itemoption{shading}|=|\meta{name}
  This selects a shading named \meta{name}. The following shadings are
  predefined:
  \begin{itemize}
  \item \declare{|axis|}
    This is the default shading in which the color changes gradually
    between three horizontal lines. The top line is at the top
    (uppermost) point of the path, the middle is in the middle, the
    bottom line is at the bottom of the path.

\begin{codeexample}[]
\tikz \shadedraw [shading=axis] (0,0) rectangle (1,1);
\end{codeexample}

    The default top color is gray, the default bottom color is white,
    the default middle is the ``middle'' of these two.
  \item \declare{|radial|}
    This shading fills the path with a gradual sweep from a certain
    color in the middle to another color at the border. If the path is
    a circle, the outer color will be reached exactly at the
    border. If the shading is not a circle, the outer color will
    continue a bit towards the corners. The default inner color is
    gray, the default outer color is white.

\begin{codeexample}[]
\tikz \shadedraw [shading=radial] (0,0) rectangle (1,1);
\end{codeexample}
  \item \declare{|ball|}
    This shading fills the path with a shading that ``looks like a
    ball.'' The default ``color'' of the ball is blue (for no
    particular reason).

\begin{codeexample}[]
\tikz \shadedraw [shading=ball] (0,0) rectangle (1,1);
\end{codeexample}

\begin{codeexample}[]
\tikz \shadedraw [shading=ball] (0,0) circle (.5cm);
\end{codeexample}
  \end{itemize}
  \itemoption{shading angle}|=|\meta{degrees}
  This option rotates the shading (not the path!) by the given
  angle. For example, we can turn a top-to-bottom axis shading into a
  left-to-right shading by rotating it by $90^\circ$.

\begin{codeexample}[]
\tikz \shadedraw [shading=axis,shading angle=90] (0,0) rectangle (1,1);
\end{codeexample}
\end{itemize}


You can also define new shading types yourself. However, for this, you
need to use the basic layer directly, which is, well, more basic and
harder to use. Details on how to create a shading appropriate for
filling paths are given in Section~\ref{section-shading-a-path}.



\subsubsection{Choosing a Shading Color}

The following options can be used to change the colors used for
shadings. When one of these options is given, the |shade| option is
automatically selected and also the ``right'' shading.

\begin{itemize}
  \itemoption{top color}|=|\meta{color}
  This option prescribes the color to be used at the top in an |axis|
  shading. When this option is given, several things happen:
  \begin{enumerate}
  \item
    The |shade| option is selected.
  \item
    The |shading=axis| option is selected.
  \item
    The middle color of the axis shading is set to the average of the
    given top color \meta{color} and of whatever color is currently
    selected for the bottom.
  \item
    The rotation angle of the shading is set to 0.
  \end{enumerate}

\begin{codeexample}[]
\tikz \draw[top color=red] (0,0) rectangle (2,1);
\end{codeexample}
  
  \itemoption{bottom color}|=|\meta{color}
  This option works like |top color|, only for the bottom color.
  
  \itemoption{middle color}|=|\meta{color}
  This option specifies the color for the middle of an axis
  shading. It also sets the |shade| and |shading=axis| options, but it
  does not change the rotation angle.

  \emph{Note:} Since both |top color| and |bottom color| change the
  middle color, this option should be given \emph{last} if all of
  these options need to be given:

\begin{codeexample}[]
\tikz \draw[top color=white,bottom color=black,middle color=red]
  (0,0) rectangle (2,1);
\end{codeexample}  

  \itemoption{left color}|=|\meta{color}
  This option does exactly the same as |top color|, except that the
  shading angle is set to $90^\circ$.

  \itemoption{right color}|=|\meta{color}
  Works like |left color|.

  \itemoption{inner color}|=|\meta{color}
  This option sets the color used at the center of a |radial|
  shading. When this option is used, the |shade| and |shading=radial|
  options are set.
  
\begin{codeexample}[]
\tikz \draw[inner color=red] (0,0) rectangle (2,1);
\end{codeexample}

  \itemoption{outer color}|=|\meta{color}
  This option sets the color used at the border and outside of a
  |radial| shading.
  
\begin{codeexample}[]
\tikz \draw[outer color=red,inner color=white]
  (0,0) rectangle (2,1);
\end{codeexample}

  \itemoption{ball color}|=|\meta{color}
  This option sets the color used for the ball shading. It sets the
  |shade| and |shading=ball| options. Note that the ball will never
  ``completely'' have the color \meta{color}. At its ``highlight'' spot
  a certain amount of white is mixed in, at the border a certain
  amount of black. Because of this, it also makes sense to say
  |ball color=white| or |ball color=black|

\begin{codeexample}[]
\begin{tikzpicture}
  \shade[ball color=white] (0,0) circle (2ex);
  \shade[ball color=red] (1,0) circle (2ex);
  \shade[ball color=black] (2,0) circle (2ex);
\end{tikzpicture}
\end{codeexample}
\end{itemize}




\subsection{Establishing a Bounding Box}

\pgfname\ is reasonably good at keeping track of the size of your picture
and reserving just the right amount of space for it in the main
document. However, in some cases you may want to say things like
``do not count this for the picture size'' or ``the picture is
actually a little large.'' For this you can use the option
|use as bounding box| or the command |\useasboundingbox|, which is just
a shorthand for |\path[use as bounding box]|.

\begin{itemize}
  \itemoption{use as bounding box}
  Normally, when this option is given on a path, the bounding box of
  the present path is used to determine the size of the picture and
  the size of all \emph{subsequent} paths are
  ignored. However, if there were previous path operations that have
  already established a larger bounding box, it will not be made
  smaller by this operation.

  In a sense, |use as bounding box| has the same effect as clipping
  all subsequent drawing against the current path---without actually
  doing the clipping, only making \pgfname\ treat everything as if it
  were clipped.

  The first application of this option is to have a |{tikzpicture}|
  overlap with the main text:

\begin{codeexample}[]
Left of picture\begin{tikzpicture}
  \draw[use as bounding box] (2,0) rectangle (3,1);
  \draw (1,0) -- (4,.75);
\end{tikzpicture}right of picture.
\end{codeexample}

  In a second application this option can be used to get better
  control over the white space around the picture:
  
\begin{codeexample}[]
Left of picture
\begin{tikzpicture}
  \useasboundingbox (0,0) rectangle (3,1);
  \fill (.75,.25) circle (.5cm);
\end{tikzpicture}
right of picture.
\end{codeexample}

  Note: If this option is used on a path inside a \TeX\ group (scope),
  the effect ``lasts'' only till the end of the scope. Again, this
  behavior is the same as for clipping.
\end{itemize}

There is a node that allows you to get the size of the current
bounding box. The |current bounding box| node has the |rectangle|
shape and its size is always the size of the current 
bounding box.

Similarly, the |current path bounding box| node has the |rectangle|
hape and the size of the bounding box of the current path.


\begin{codeexample}[]
\begin{tikzpicture}
  \draw[red] (0,0) circle (2pt);
  \draw[red] (2,1) circle (3pt);

  \draw (current bounding box.south west) rectangle
        (current bounding box.north east);

  \draw[red] (3,-1) circle (4pt);

  \draw[thick] (current bounding box.south west) rectangle
               (current bounding box.north east);
\end{tikzpicture}
\end{codeexample}





\subsection{Using a Path For Clipping}

To use a path for clipping, use the |clip| option. 

\begin{itemize}
  \itemoption{clip}
  This option causes all subsequent drawings to be clipped against the
  current path and the size of subsequent paths will not be important
  for the picture size.  If you clip against a self-intersecting path,
  the even-odd rule or  the nonzero winding number rule is used to
  determine whether a point is inside or outside the clipping region.

  The clipping path is a graphic state parameter, so it will be reset
  at the end of the current scope. Multiple clippings accumulate, that
  is, clipping is always done against the intersection of all clipping
  areas that have been specified inside the current scopes. The only
  way of enlarging the clipping area is to end a |{scope}|.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[clip] (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

  It  is usually a \emph{very} good idea to apply the |clip| option only
  to the first path command in a scope. 

  If you ``only wish to clip'' and do not wish to draw anything, you can
  use the |\clip| command, which is a shorthand for |\path[clip]|.

\begin{codeexample}[]
\begin{tikzpicture}
  \clip (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

  To keep clipping local, use |{scope}| environments as in the
  following example:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- ( 0:1cm);
  \draw (0,0) -- (10:1cm);
  \draw (0,0) -- (20:1cm);
  \draw (0,0) -- (30:1cm);
  \begin{scope}[fill=red]
    \fill[clip] (0.2,0.2) rectangle (0.5,0.5);
    
    \draw (0,0) -- (40:1cm);
    \draw (0,0) -- (50:1cm);
    \draw (0,0) -- (60:1cm);
  \end{scope}
  \draw (0,0) -- (70:1cm);
  \draw (0,0) -- (80:1cm);
  \draw (0,0) -- (90:1cm);
\end{tikzpicture}
\end{codeexample}

  There is a slightly annoying catch: You cannot specify certain graphic
  options for the command used for clipping. For example, in the above
  code we could not have moved the |fill=red| to the |\fill|
  command. The reasons for this have to do with the internals of the
  \pdf\ specification. You do not want to know the details. It is best
  simply not to specify any options for these 
  commands. 
\end{itemize}
