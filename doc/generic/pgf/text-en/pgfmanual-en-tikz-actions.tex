% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Actions on Paths}

\subsection{Overview}

Once a path has been constructed, different things can be done with
it. It can be drawn (or stroked) with a ``pen,'' it can be filled with
a color or shading, it can be used for clipping subsequent drawing, it
can be used to specify the extend of the picture---or  any
combination of these actions at the same time.

To decide what is to be done with a path, two methods can be
used. First, you can use a special-purpose command like |\draw| to
indicate that the path should be drawn. However, commands like |\draw|
and |\fill| are just abbreviations for special cases of the more
general method: Here, the |\path| command is used to specify the
path. Then, options encountered on the path indicate what should be
done with the path.

For example, |\path (0,0) circle (1cm);| means ``This is a path
consisting of a circle around the origin. Do not do anything with it
(throw it away).'' However, if the option |draw| is encountered
anywhere on the path, the circle will be drawn. ``Anywhere'' is any
point on the path where an option can be given, which is everywhere
where a path command like |circle (1cm)| or |rectangle (1,1)| or even
just |(0,0)| would also be allowed. Thus, the following commands all
draw the same circle:
\begin{codeexample}[code only]
\path [draw] (0,0) circle (1cm);
\path (0,0) [draw] circle (1cm);
\path (0,0) circle (1cm) [draw];
\end{codeexample}
Finally, |\draw (0,0) circle (1cm);| also draws a path, because
|\draw| is an abbreviation for |\path [draw]| and thus the command
expands to the first line of the above example.

Similarly, |\fill| is an abbreviation for |\path[fill]| and
|\filldraw| is an abbreviation for the command
|\path[fill,draw]|. Since options accumulate, the following commands
all have the same effect:
\begin{codeexample}[code only]
\path [draw,fill]   (0,0) circle (1cm);
\path [draw] [fill] (0,0) circle (1cm);
\path [fill] (0,0) circle (1cm) [draw];
\draw [fill] (0,0) circle (1cm);
\fill (0,0) [draw] circle (1cm);
\filldraw (0,0) circle (1cm);
\end{codeexample}

In the following subsection the different actions that
can be performed on a path are explained. The following commands are abbreviations for
certain sets of actions, but for many useful combinations there are no
abbreviations:

\begin{command}{\draw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[draw]|.
\end{command}

\begin{command}{\fill}
  Inside |{tikzpicture}| this is an abbreviation for |\path[fill]|.
\end{command}

\begin{command}{\filldraw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[fill,draw]|.
\end{command}

\begin{command}{\pattern}
  Inside |{tikzpicture}| this is an abbreviation for |\path[pattern]|.
\end{command}

\begin{command}{\shade}
  Inside |{tikzpicture}| this is an abbreviation for |\path[shade]|.
\end{command}

\begin{command}{\shadedraw}
  Inside |{tikzpicture}| this is an abbreviation for |\path[shade,draw]|.
\end{command}

\begin{command}{\clip}
  Inside |{tikzpicture}| this is an abbreviation for |\path[clip]|.
\end{command}

\begin{command}{\useasboundingbox}
  Inside |{tikzpicture}| this is an abbreviation for |\path[use as bounding box]|.
\end{command}



\subsection{Specifying a Color}

The most unspecific option for setting colors is the following:

\begin{key}{/tikz/color=\meta{color name}}
  \indexoption{color option}%
  This option sets the color that is used for fill, drawing, and text
  inside the current scope. Any special settings for filling colors or
  drawing colors are immediately ``overruled'' by this option.

  The \meta{color name} is the name of a previously defined color. For
  \LaTeX\ users, this is just a normal ``\LaTeX-color'' and the
  |xcolor| extensions are allowed. Here is an example:

\begin{codeexample}[]
\tikz \fill[color=red!20] (0,0) circle (1ex);
\end{codeexample}

  It is possible to ``leave out'' the |color=| part and you can also
  write:
\begin{codeexample}[]
\tikz \fill[red!20] (0,0) circle (1ex);
\end{codeexample}
  What happens is that every option that \tikzname\ does not know, like
  |red!20|, gets a ``second chance'' as a color name.

  For plain \TeX\ users, it is not so easy to specify colors since
  plain \TeX\ has no ``standardized'' color naming
  mechanism. Because of this, \pgfname\ emulates the |xcolor| package,
  though the emulation is \emph{extremely basic} (more precisely, what
  I could hack together in two hours or so). The emulation allows you
  to do the following:
  \begin{itemize}
  \item Specify a new color using |\definecolor|. Only the two color
    models |gray| and |rgb| are supported\footnote{Con\TeX t users should be aware that \texttt{\textbackslash definecolor} has a different meaning in Con\TeX t. There is a low-level equivalent named \texttt{\textbackslash pgfutil@definecolor} which can be used instead.}.%
    \example |\definecolor{orange}{rgb}{1,0.5,0}|
  \item Use |\colorlet| to define a new color based on an old
    one. Here, the |!| mechanism is supported, though only ``once''
    (use multiple |\colorlet| for more fancy colors).
    \example |\colorlet{lightgray}{black!25}|
  \item Use |\color|\marg{color name} to set the color in the current
    \TeX\ group. |\aftergroup|-hackery is used to restore the color
    after the group.
  \end{itemize}
\end{key}

As pointed out above, the |color=| option applies to ``everything''
(except to shadings), which is not always what you want. Because of
this, there are several more specialized color options. For example,
the |draw=| option sets the color used for drawing, but does not
modify the color used for filling. These color options are documented
where the path action they influence is described.


\subsection{Drawing a Path}

You can draw a path using the following option:
\begin{key}{/tikz/draw=\meta{color} (default \normalfont is scope's color setting)}
  Causes the path to be drawn. ``Drawing'' (also known as
  ``stroking'') can be thought of as picking up a pen and moving it
  along the path, thereby leaving ``ink'' on the canvas.

  There are numerous parameters that influence how a line is drawn,
  like the thickness or the dash pattern. These options are explained
  below.

  If the optional \meta{color} argument is given, drawing is done
  using the given \meta{color}. This color can be different from the
  current filling color, which allows you to draw and fill a path with
  different colors. If no \meta{color} argument is given, the last
  usage of the |color=| option is used.

  If the special color name |none| is given, this option causes
  drawing to be ``switched off.'' This is useful if a style has
  previously switched on drawing and you locally wish to undo this
  effect.

  Although this option is normally used on paths to indicate that the
  path should be drawn, it also makes sense to use the option with a
  |{scope}| or |{tikzpicture}| environment. However, this will
  \emph{not} cause all path to drawn. Instead, this just sets the
  \meta{color} to be used for drawing paths inside the environment.

\begin{codeexample}[]
\begin{tikzpicture}
  \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
\end{tikzpicture}
\end{codeexample}
\end{key}


The following subsections list the different options that influence
how a path is drawn. All of these options only have an effect if the
|draw| option is given (directly or indirectly).

\subsubsection{Graphic Parameters: Line Width, Line Cap, and Line Join}

\label{section-cap-joins}

\begin{key}{/tikz/line width=\meta{dimension} (initially 0.4pt)}
  Specifies the line width. Note the space.

\begin{codeexample}[]
  \tikz \draw[line width=5pt] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{key}

There are a number of predefined styles that provide more ``natural''
ways of setting the line width. You can also redefine these
styles.

\begin{stylekey}{/tikz/ultra thin}
  Sets the line width to 0.1pt.
\begin{codeexample}[]
  \tikz \draw[ultra thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/very thin}
  Sets the line width to 0.2pt.
\begin{codeexample}[]
  \tikz \draw[very thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/thin}
  Sets the line width to 0.4pt.
\begin{codeexample}[]
  \tikz \draw[thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/semithick}
  Sets the line width to 0.6pt.
\begin{codeexample}[]
  \tikz \draw[semithick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/thick}
  Sets the line width to 0.8pt.
\begin{codeexample}[]
  \tikz \draw[thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/very thick}
  Sets the line width to 1.2pt.
\begin{codeexample}[]
  \tikz \draw[very thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/ultra thick}
  Sets the line width to 1.6pt.
\begin{codeexample}[]
  \tikz \draw[ultra thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
\end{stylekey}


\begin{key}{/tikz/line cap=\meta{type} (initially butt)}
  Specifies how lines ``end.'' Permissible \meta{type} are |round|,
  |rect|, and |butt|. They have the following effects:

\begin{codeexample}[]
\begin{tikzpicture}
  \begin{scope}[line width=10pt]
    \draw[line cap=rect]  (0,0 ) -- (1,0);
    \draw[line cap=butt]  (0,.5) -- (1,.5);
    \draw[line cap=round] (0,1 ) -- (1,1);
  \end{scope}
  \draw[white,line width=1pt]
    (0,0 ) -- (1,0) (0,.5) -- (1,.5) (0,1 ) -- (1,1);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/line join=\meta{type} (initially miter)}
  Specifies how lines ``join.'' Permissible \meta{type} are |round|,
  |bevel|, and |miter|. They have the following effects:

\begin{codeexample}[]
\begin{tikzpicture}[line width=10pt]
  \draw[line join=round] (0,0) -- ++(.5,1) -- ++(.5,-1);
  \draw[line join=bevel] (1.25,0) -- ++(.5,1) -- ++(.5,-1);
  \draw[line join=miter] (2.5,0) -- ++(.5,1) -- ++(.5,-1);
  \useasboundingbox (0,1.5); % enlarge bounding box
\end{tikzpicture}
\end{codeexample}

  \begin{key}{/tikz/miter limit=\meta{factor} (initially 10)}
    When you use the miter join and there is a very sharp corner (a
    small angle), the miter join may protrude very far over the actual
    joining point. In this case, if it were to protrude by
    more than \meta{factor} times the line width, the miter join is
    replaced by a bevel join.

\begin{codeexample}[]
\begin{tikzpicture}[line width=5pt]
  \draw                 (0,0) -- ++(5,.5) -- ++(-5,.5);
  \draw[miter limit=25] (6,0) -- ++(5,.5) -- ++(-5,.5);
  \useasboundingbox (14,0); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}
  \end{key}
\end{key}

\subsubsection{Graphic Parameters: Dash Pattern}

\begin{key}{/tikz/dash pattern=\meta{dash pattern}}
  Sets the dashing pattern. The syntax is the same as in
  \textsc{metafont}. For example following pattern
  |on 2pt off 3pt on 4pt off 4pt| means ``draw
  2pt, then leave out 3pt, then draw 4pt once more, then leave out 4pt
  again, repeat''.

\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 2pt off 3pt on 4pt off 4pt]
  \draw (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/dash phase=\meta{dash phase} (initially 0pt)}
  Shifts the start of the dash pattern by \meta{phase}.

\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 20pt off 10pt]
  \draw[dash phase=0pt] (0pt,3pt) -- (3.5cm,3pt);
  \draw[dash phase=10pt] (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
\end{key}

As for the line thickness, some predefined styles allow you to set the
dashing conveniently.

\begin{stylekey}{/tikz/solid}
  Shorthand for setting a solid line as ``dash pattern.'' This is the default.

\begin{codeexample}[]
\tikz \draw[solid] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/dotted}
  Shorthand for setting a dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/densely dotted}
  Shorthand for setting a densely dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[densely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dotted}
  Shorthand for setting a loosely dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[loosely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/dashed}
  Shorthand for setting a dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/densely dashed}
  Shorthand for setting a densely dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[densely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dashed}
  Shorthand for setting a loosely dashed dash pattern.

\begin{codeexample}[]
\tikz \draw[loosely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}


\begin{stylekey}{/tikz/dashdotted}
  Shorthand for setting a dashed and dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[dashdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/densely dashdotted}
  Shorthand for setting a densely dashed and dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[densely dashdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dashdotted}
  Shorthand for setting a loosely dashed and dotted dash pattern.

\begin{codeexample}[]
\tikz \draw[loosely dashdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}


\begin{stylekey}{/tikz/dashdotdotted}
  Shorthand for setting a dashed and dotted dash pattern with more dots.

\begin{codeexample}[]
\tikz \draw[dashdotdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/densely dashdotdotted}
  Shorthand for setting a densely dashed and dotted dash pattern with more dots.

\begin{codeexample}[]
\tikz \draw[densely dashdotdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dashdotdotted}
  Shorthand for setting a loosely dashed and dotted dash pattern with more dots.

\begin{codeexample}[]
\tikz \draw[loosely dashdotdotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
\end{stylekey}


\subsubsection{Graphic Parameters: Draw Opacity}

When a line is drawn, it will normally ``obscure'' everything behind
it as if you has used perfectly opaque ink. It is also possible to ask
\tikzname\ to use an ink that is a little bit (or a big bit)
transparent using the |draw opacity| option. This is explained in
Section~\ref{section-tikz-transparency} on transparency in more detail.



\subsubsection{Graphic Parameters: Arrow Tips}

When you draw a line, you can add arrow tips at the ends. It is
only possible to add one arrow tip at the start and one at the end. If
the path consists of several segments, only the last segment gets
arrow tips. The behavior for paths that are closed is not specified
and may change in the future.

\begin{key}{/tikz/arrows=\meta{start arrow kind}|-|\meta{end arrow kind}}
  This option sets the start and end arrow tips (an empty value as in |->|
  indicates that no arrow tip should be drawn at the start).%
  \indexoption{arrows}

  \emph{Note: Since the arrow option is so often used, you can leave
    out the text |arrows=|.} What happens is that every option that
  contains a |-| is interpreted as an arrow specification.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[->]        (0,0)   -- (1,0);
  \draw[o-stealth] (0,0.3) -- (1,0.3);
\end{tikzpicture}
\end{codeexample}

  The permissible values are all predefined arrow tips, though
  you can also define new arrow tip kinds as explained in
  Section~\ref{section-arrows}. This is often necessary to obtain
  ``double'' arrow tips and arrow tips that have a fixed size. You
  need to load the |arrows| library if you need arrow tips other than
  the default ones, see Section~\ref{section-library-arrows}.

  One arrow tip kind is special: |>| (and all arrow tip kinds containing the
  arrow tip kind such as |<<| or \verb!>|!). This arrow tip type is not
  fixed. Rather, you can redefine it using the |>=| option, see
  below.

  \example You can also combine arrow tip types as in
\begin{codeexample}[]
\begin{tikzpicture}[thick]
  \draw[to reversed-to]   (0,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \draw[[-latex reversed] (1,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \draw[latex-)]          (2,0) .. controls +(.5,0) and +(-.5,-.5) .. +(1.5,1);
  \useasboundingbox (-.1,-.1) rectangle (3.1,1.1); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/>=\meta{end arrow kind}}
  This option can be used to redefine the ``standard'' arrow tip |>|. The
  idea is that different people have different ideas what arrow tip kind
  should normally be used. I prefer the arrow tip of \TeX's |\to| command
  (which is used in things like $f\colon A \to B$). Other people will
  prefer \LaTeX's standard arrow tip, which looks like this: \tikz
  \draw[-latex] (0,0) -- (10pt,1ex);. Since the arrow tip kind |>| is
  certainly the most ``natural'' one to use, it is kept free of any
  predefined meaning. Instead, you can change it by saying |>=to| to
  set the ``standard'' arrow tip kind to \TeX's arrow tip, whereas |>=latex|
  will set it to \LaTeX's arrow tip and |>=stealth| will use a
  \textsc{pstricks}-like arrow tip.

  Apart from redefining the arrow tip kind |>| (and |<| for the start),
  this option also redefines the following arrow tip kinds: |>| and \declareandlabel{<} as
  the swapped version of \meta{end arrow kind}, \declareandlabel{<<} and \declareandlabel{>>} as
  doubled versions, \declareandlabel{>>} and \declareandlabel{<<} as swapped doubled versions, %>>
  and \verb!|<! and \verb!>|! as arrow tips ending with a vertical bar.

\begin{codeexample}[]
\begin{tikzpicture}[scale=2]
  \begin{scope}[>=latex]
    \draw[->]    (0pt,6ex) -- (1cm,6ex);
    \draw[>->>]  (0pt,5ex) -- (1cm,5ex);
    \draw[|<->|] (0pt,4ex) -- (1cm,4ex);
  \end{scope}
  \begin{scope}[>=diamond]
    \draw[->]    (0pt,2ex) -- (1cm,2ex);
    \draw[>->>]  (0pt,1ex) -- (1cm,1ex);
    \draw[|<->|] (0pt,0ex) -- (1cm,0ex);
  \end{scope}
\end{tikzpicture}
\end{codeexample}
% <<
\end{key}

\begin{key}{/tikz/shorten >=\meta{dimension} (initially 0pt)}
  This option will shorten the end of lines by the given
  \meta{dimension}. If you specify an arrow tip, lines are already
  shortened a bit such that the arrow tip touches the specified endpoint
  and does not ``protrude over'' this point. Here is an example:

\begin{codeexample}[]
\begin{tikzpicture}[line width=20pt]
  \useasboundingbox (0,-1.5) rectangle (3.5,1.5);
  \draw[red]        (0,0) -- (3,0);
  \draw[gray,->]    (0,0) -- (3,0);
\end{tikzpicture}
\end{codeexample}

  The |shorten >| option allows you to shorten the end on the line
  \emph{additionally} by the given distance. This option can also be
  useful if you have not specified an arrow tip at all.

\begin{codeexample}[]
\begin{tikzpicture}[line width=20pt]
  \useasboundingbox (0,-1.5) rectangle (3.5,1.5);
  \draw[red]                     (0,0) -- (3,0);
  \draw[-to,shorten >=10pt,gray] (0,0) -- (3,0);
\end{tikzpicture}
\end{codeexample}
\end{key}


\begin{key}{/tikz/shorten <=\meta{dimension}}
  Works like |shorten >|, but for the start.
\end{key}



\subsubsection{Graphic Parameters: Double Lines and Bordered Lines}

\begin{key}{/tikz/double=\meta{core color} (default white)}
  This option causes ``two'' lines to be drawn instead of a single
  one. However, this is not what really happens. In reality, the path
  is drawn twice. First, with the normal drawing color, secondly with
  the \meta{core color}, which is normally |white|. Upon the second
  drawing, the line width is reduced. The net effect is that it
  appears as if two lines had been drawn and this works well even with
  complicated, curved paths:

\begin{codeexample}[]
\tikz \draw[double]
  plot[smooth cycle] coordinates{(0,0) (1,1) (1,0) (0,1)};
\end{codeexample}

  You can also use the doubling option to create an effect in which a
  line seems to have a certain ``border'':

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- (1,1);
  \draw[draw=white,double=red,very thick] (0,1) -- (1,0);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/double distance=\meta{dimension} (initially 0.6pt)}
  Sets the distance the ``two'' lines are spaced apart. In reality,
  this is the thickness of the line that is used
  to draw the path for the second time. The thickness of the
  \emph{first} time the path is drawn is twice the normal line width
  plus the given \meta{dimension}. As a side-effect, this option
  ``selects'' the |double| option.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[very thick,double]              (0,0) arc (180:90:1cm);
  \draw[very thick,double distance=2pt] (1,0) arc (180:90:1cm);
  \draw[thin,double distance=2pt]       (2,0) arc (180:90:1cm);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/double distance between line centers=\meta{dimension}}
  This option works like |double distance|, only the distance is not
  the distance between (inner) borders of the two main lines, but
  between their centers. Thus, the thickness the
  \emph{first} time the path is drawn is the normal line width
  plus the given \meta{dimension}, while the line width of the
  \emph{second} line that is drawn is \meta{dimension} minus the
  normal line width. As a side-effect, this option ``selects'' the
  |double| option.

\begin{codeexample}[]
\begin{tikzpicture}[double distance between line centers=3pt]
  \foreach \lw in {0.5,1,1.5,2,2.5}
    \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}[double distance=3pt]
  \foreach \lw in {0.5,1,1.5,2,2.5}
    \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{stylekey}{/tikz/double equal sign distance}
  This style selects a double line distance such that it corresponds
  to the distance of the two lines in an equal sign.
\begin{codeexample}[]
\Huge $=\implies$\tikz[baseline,double equal sign distance]
                    \draw[double,thick,-implies](0,0.55ex) --++(3ex,0);
\end{codeexample}
\begin{codeexample}[]
\normalsize $=\implies$\tikz[baseline,double equal sign distance]
                          \draw[double,-implies](0,0.6ex) --++(3ex,0);
\end{codeexample}
\begin{codeexample}[]
\tiny $=\implies$\tikz[baseline,double equal sign distance]
                   \draw[double,very thin,-implies](0,0.5ex) -- ++(3ex,0);
\end{codeexample}
\end{stylekey}






\subsection{Filling a Path}
\label{section-rules}
To fill a path, use the following option:
\begin{key}{/tikz/fill=\meta{color} (default \normalfont is scope's color setting)}
  This option causes the path to be filled. All unclosed parts of the
  path are first closed, if necessary. Then, the area enclosed by the
  path is filled with the current filling color, which is either the
  last color set using the general |color=| option or the optional
  color \meta{color}. For self-intersection paths and for paths
  consisting of several closed areas, the ``enclosed area'' is
  somewhat complicated to define and two different definitions exist,
  namely the nonzero winding number rule and the even odd rule, see
  the explanation of these options, below.

  Just as for the |draw| option, setting \meta{color} to |none|
  disables filling locally.

\begin{codeexample}[]
\begin{tikzpicture}
  \fill (0,0) -- (1,1) -- (2,1);
  \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}

  If the |fill| option is used together with the |draw| option (either
  because both are given as options or because a |\filldraw| command
  is used), the path is filled \emph{first}, then the path is drawn
  \emph{second}. This is especially useful if different colors are
  selected for drawing and for filling. Even if the same color is
  used, there is a difference between this command and a plain
  |fill|: A ``filldrawn'' area will be slightly larger than a filled
  area because of the thickness of the ``pen.''

\begin{codeexample}[]
\begin{tikzpicture}[fill=examplefill,line width=5pt]
  \filldraw (0,0) -- (1,1) -- (2,1);
  \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}
\end{key}



\subsubsection{Graphic Parameters: Fill Pattern}

\label{section-fill-pattern}
Instead of filling a path with a single solid color, it is also
possible to fill it with a \emph{tiling pattern}. Imagine a small tile
that contains a simple picture like a star. Then these tiles are
(conceptually) repeated infinitely in all directions, but clipped
against the path.

Tiling patterns come in two variants: \emph{inherently
  colored patterns} and \emph{form-only patterns}. An inherently colored
pattern is, say, a red star with a black border and will always look
like this. A form-only pattern may have a different color each time
it is used, only the form of the pattern will stay the same. As such,
form-only patterns do not have any colors of their own, but when it
is used the current \emph{pattern color} is used as its color.

Patterns are not overly flexible. In particular, it is not possible to
change the size or orientation of a pattern without declaring a new
pattern. For complicated cases, it may be easier to use two nested
|\foreach| statements to simulate a pattern, but patterns are rendered
\emph{much} more quickly than simulated ones.

\begin{key}{/tikz/pattern=\meta{name} (default \normalfont is scope's pattern)}
  This option causes the path to be filled with a pattern. If the
  \meta{name} is given, this pattern is used, otherwise the pattern
  set in the enclosing scope is used. As for the |draw| and |fill|
  options, setting \meta{name} to |none| disables filling locally.

  The pattern works like a fill color. In particular, setting a new
  fill color will fill the path with a solid color once more.

  Strangely, no \meta{name}s are permissible by default. You need to
  load for instance the |patterns| library, see
  Section~\ref{section-library-patterns}, to install predefined
  patterns.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[pattern=dots] (0,0) circle (1cm);
  \draw[pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/pattern color=\meta{color}}
  This option is used to set the color to be used for form-only
  patterns. This option has no effect on inherently colored patterns.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[pattern color=red,pattern=fivepointed stars]  (0,0) circle (1cm);
  \draw[pattern color=blue,pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
  \def\mypath{(0,0) -- +(0,1) arc (180:0:1.5cm) -- +(0,-1)}
  \fill   [red]                                \mypath;
  \pattern[pattern color=white,pattern=bricks] \mypath;
\end{tikzpicture}
\end{codeexample}
\end{key}


\subsubsection{Graphic Parameters: Interior Rules}

The following two options can be used to decide how interior points
should be determined:
\begin{key}{/tikz/nonzero rule}
  If this rule is used (which is the default), the following method is
  used to determine whether a given point is ``inside'' the path: From
  the point, shoot a ray in some direction towards infinity (the
  direction is chosen such that no strange borderline cases
  occur). Then the ray may hit the path. Whenever it hits the path, we
  increase or decrease a counter, which is initially zero. If the ray
  hits the path as the path goes ``from left to right'' (relative to
  the ray), the counter is increased, otherwise it is decreased. Then,
  at the end, we check whether the counter is nonzero (hence the
  name). If so, the point is deemed to lie ``inside,'' otherwise it is
  ``outside.'' Sounds complicated? It is.

\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=examplefill]
  % Clockwise rectangle
  (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
  % Counter-clockwise rectangle
  (0.25,0.25) -- (0.75,0.25) -- (0.75,0.75) -- (0.25,0.75) -- cycle;

  \draw[->] (0,1) -- (.4,1);
  \draw[->] (0.75,0.75) -- (0.3,.75);

  \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $-1+1 = 0$};

  \begin{scope}[yshift=-3cm]
    \filldraw[fill=examplefill]
    % Clockwise rectangle
    (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
    % Clockwise rectangle
    (0.25,0.25) -- (0.25,0.75) -- (0.75,0.75) -- (0.75,0.25) -- cycle;

    \draw[->] (0,1) -- (.4,1);
    \draw[->] (0.25,0.75) -- (0.4,.75);

    \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $1+1 = 2$};
  \end{scope}
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/even odd rule}
  This option causes a different method to be used for determining the
  inside and outside of paths. While it is less flexible, it turns out
  to be more intuitive.

  With this method, we also shoot rays from the point for which we
  wish to determine whether it is inside or outside the filling
  area. However, this time we only count how often we ``hit'' the path
  and declare the point to be ``inside'' if the number of hits is odd.

  Using the even-odd rule, it is easy to ``drill holes'' into a path.

\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=examplefill,even odd rule]
    (0,0) rectangle (1,1) (0.5,0.5) circle (0.4cm);
  \draw[->] (0.5,0.5) -- +(0,1) [above] node{crossings: $1+1 = 2$};
\end{tikzpicture}
\end{codeexample}
\end{key}



\subsubsection{Graphic Parameters: Fill Opacity}

\label{section-fill-opacity}
Analogously to the |draw opacity|, you can also set the fill opacity. Please see Section~\ref{section-tikz-transparency} for more
details.


\subsection{Generalized Filling: Using Arbitrary Pictures to Fill a Path}

Sometimes you wish to ``fill'' a path with something even more
complicated than a pattern, let alone a single color. For instance,
you might wish to use an image to fill the path or some other,
complicated drawing. In principle, this effect can be achieved
by first using the path for clipping and then, subsequently, drawing
the desired image or picture. However, there is an option that makes
this process much easier:

\begin{key}{/tikz/path picture=\meta{code}}
  When this option is given on a path and when the \meta{code} is not
  empty, the following happens: After all other ``filling'' operations
  are done with the path, which are caused by the options |fill|,
  |pattern| and  |shade|, a local scope is opened and the path is
  temporarily installed as a clipping path. Then, the \meta{code} is
  executed, which can now draw something. Then, the local scope ends
  and, possibly, the path is stroked, provided the |draw| option has
  been given.

  As with other keys like |fill| or |draw| this option needs to be given on a path, setting the |path picture| outside a path has no effect (the path picture is cleared at the beginning of each path).

  The \meta{code} can be any normal \tikzname\ code like |\draw ...|
  or |\node ...|. As always, when you include an external graphic, you need to put it inside a |\node|.

  Note that no special actions are taken to transform the origin in
  any way. This means that the coordinate |(0,0)| is still where is
  was when the path was being constructed and not -- as one might
  expect -- at the lower left corner of the path. However, you can use
  the following special node to access the size of the path:
  \begin{predefinednode}{path picture bounding box}
    This node is of shape |rectangle|. Its size and position are those
    of |current path bounding box| just before the \meta{code}
    of the path picture started to be executed. The \meta{code} can
    construct its own paths, so accessing the
    |current path bounding box| inside the \meta{code} yields the
    bounding box of any path that is currently being constructed
    inside the \meta{code}.
  \end{predefinednode}

\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \filldraw [fill=blue!10,draw=blue,thick] (1.5,1) circle (1)
    [path picture={
      \node at (path picture bounding box.center) {
        This is a long text.
      };}
    ];
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}[cross/.style={path picture={
      \draw[black]
            (path picture bounding box.south east) --
            (path picture bounding box.north west)
            (path picture bounding box.south west) --
            (path picture bounding box.north east);
    }}]
  \draw [help lines] (0,0) grid (3,2);
  \filldraw [cross,fill=blue!10,draw=blue,thick] (1,1) circle (1);
  \path     [cross,top color=red,draw=red,thick] (2,0) -- (3,2) -- (3,0);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
  \begin{tikzpicture}[path image/.style={
      path picture={
        \node at (path picture bounding box.center) {
          \includegraphics[height=3cm]{#1}
        };}}]
  \draw     [help lines] (0,0) grid (3,2);

  \draw [path image=brave-gnu-world-logo,draw=blue,thick]
          (0,1) circle (1);
  \draw [path image=brave-gnu-world-logo,draw=red,very thick,->]
          (1,0) parabola[parabola height=2cm] (3,0);

\end{tikzpicture}
\end{codeexample}
\end{key}


\subsection{Shading a Path}

You can shade a path using the |shade| option. A shading is like a
filling, only the shading changes its color smoothly from one color to
another.

\begin{key}{/tikz/shade}
  Causes the path to be shaded using the currently selected shading
  (more on this later). If this option is used together with the
  |draw| option, then the path is first shaded, then drawn.

  It is not an error to use this option together with the |fill|
  option, but it makes no sense.

\begin{codeexample}[]
\tikz \shade (0,0) circle (1ex);
\end{codeexample}

\begin{codeexample}[]
\tikz \shadedraw (0,0) circle (1ex);
\end{codeexample}
\end{key}

For some shadings it is not really clear how they can ``fill'' the
path. For example, the |ball| shading normally looks like this: \tikz
\shade[shading=ball] (0,0) circle (0.75ex);. How is this supposed to
shade a rectangle? Or a triangle?

To solve this problem, the predefined shadings like |ball| or |axis|
fill a large rectangle completely in a sensible way. Then, when the
shading is used to ``shade'' a path, what actually happens is that the
path is temporarily used for clipping and then the rectangular shading
is drawn, scaled and shifted such that all parts of the path are
filled.

The default shading is a smooth transition from gray
to white and from top to bottom. However, other shadings are also
possible, for example a shading that will sweep a color from the
center to the corners outward. To choose the shading, you can use the
|shading=| option, which will also automatically invoke the |shade|
option. Note that this does \emph{not} change the shading color, only
the way the colors sweep. For changing the colors, other options are
needed, which are explained below.

\begin{key}{/tikz/shading=\meta{name}}
  This selects a shading named \meta{name}. The following shadings are
  predefined: |axis|, |radial|, and |ball|.
\begin{codeexample}[]
\tikz \shadedraw [shading=axis] (0,0) rectangle (1,1);
\tikz \shadedraw [shading=radial] (0,0) rectangle (1,1);
\tikz \shadedraw [shading=ball] (0,0) circle (.5cm);
\end{codeexample}

  The shadings as well as additional shadings are described in more
  detail in Section~\ref{section-library-shadings}.

  To change the color of a shading, special options are needed like
  |left color|, which sets the color of an axis shading from left to
  right. These options implicitly also select the correct shading type,
  see the following example
\begin{codeexample}[]
\tikz \shadedraw [left color=red,right color=blue]
    (0,0) rectangle (1,1);
\end{codeexample}

  For a complete list of the possible options see
  Section~\ref{section-library-shadings} once more.

  \begin{key}{/tikz/shading angle=\meta{degrees} (initially 0)}
    This option rotates the shading (not the path!) by the given
    angle. For example, we can turn a top-to-bottom axis shading into a
    left-to-right shading by rotating it by $90^\circ$.

\begin{codeexample}[]
\tikz \shadedraw [shading=axis,shading angle=90] (0,0) rectangle (1,1);
\end{codeexample}
  \end{key}
\end{key}

You can also define new shading types yourself. However, for this, you
need to use the basic layer directly, which is, well, more basic and
harder to use. Details on how to create a shading appropriate for
filling paths are given in Section~\ref{section-shading-a-path}.



\subsection{Establishing a Bounding Box}

\pgfname\ is reasonably good at keeping track of the size of your picture
and reserving just the right amount of space for it in the main
document. However, in some cases you may want to say things like
``do not count this for the picture size'' or ``the picture is
actually a little large.'' For this you can use the option
|use as bounding box| or the command |\useasboundingbox|, which is just
a shorthand for |\path[use as bounding box]|.

\begin{key}{/tikz/use as bounding box}
  Normally, when this option is given on a path, the bounding box of
  the present path is used to determine the size of the picture and
  the size of all \emph{subsequent} paths are
  ignored. However, if there were previous path operations that have
  already established a larger bounding box, it will not be made
  smaller by this operation (consider the |\pgfresetboundingbox| command
  to reset the previous bounding box).

  In a sense, |use as bounding box| has the same effect as clipping
  all subsequent drawing against the current path---without actually
  doing the clipping, only making \pgfname\ treat everything as if it
  were clipped.

  The first application of this option is to have a |{tikzpicture}|
  overlap with the main text:

\begin{codeexample}[]
Left of picture\begin{tikzpicture}
  \draw[use as bounding box] (2,0) rectangle (3,1);
  \draw (1,0) -- (4,.75);
\end{tikzpicture}right of picture.
\end{codeexample}

  In a second application this option can be used to get better
  control over the white space around the picture:

\begin{codeexample}[]
Left of picture
\begin{tikzpicture}
  \useasboundingbox (0,0) rectangle (3,1);
  \fill (.75,.25) circle (.5cm);
\end{tikzpicture}
right of picture.
\end{codeexample}

  Note: If this option is used on a path inside a \TeX\ group (scope),
  the effect ``lasts'' only till the end of the scope. Again, this
  behavior is the same as for clipping.


  Consider using |\useasboundingbox| together with |\pgfresetboundingbox| in order to replace the bounding box with a new one.
\end{key}

There is a node that allows you to get the size of the current
bounding box. The |current bounding box| node has the |rectangle|
shape and its size is always the size of the current
bounding box.

Similarly, the |current path bounding box| node has the |rectangle|
shape and the size of the bounding box of the current path.


\begin{codeexample}[]
\begin{tikzpicture}
  \draw[red] (0,0) circle (2pt);
  \draw[red] (2,1) circle (3pt);

  \draw (current bounding box.south west) rectangle
        (current bounding box.north east);

  \draw[red] (3,-1) circle (4pt);

  \draw[thick] (current bounding box.south west) rectangle
               (current bounding box.north east);
\end{tikzpicture}
\end{codeexample}


Occasionally, you may want to align multiple |tikzpicture| environments horizontally and/or vertically at some prescribed position. The vertical alignment can be realized by means of the |baseline| option since \TeX\ supports the concept of box depth natively. For horizontal alignment, things are slightly more involved. The following approach is realized by means of negative |\hspace|s before and/or after the picture, thereby removing parts of the picture. However, the actual amount of negative horizontal space is provided by means of image coordinates using the |trim left| and |trim right| keys:

\begin{key}{/tikz/trim left=\meta{dimension or coordinate or \texttt{default}} (default 0pt)}
	The |trim left| key tells \pgfname\space to discard everything which is left of the provided \meta{dimension or coordinate}. Here, \meta{dimension} is a single $x$ coordinate of the picture and \meta{coordinate} is a point with $x$ and $y$ coordinates (but only its $x$ coordinate will be used). The effect is the same as if you issue |\hspace{-s}| where |s| is the difference of the picture's bounding box lower left $x$ coordinate and the $x$ coordinate specified as \meta{dimension or coordinate}:
\begin{codeexample}[]
Text before image.%
	\begin{tikzpicture}[trim left]
		\draw (-1,-1) grid (3,2);
		\fill (0,0) circle (5pt);
	\end{tikzpicture}%
Text after image.
\end{codeexample}
	Since |trim left| uses the default |trim left=0pt|, everything left of $x=0$ is removed from the bounding box.

	The following example has once the relative long label $-1$ and once the shorter label $1$. Horizontal alignment is established with |trim left|:
\begin{codeexample}[pre={\vbox\bgroup\hsize=5cm},post=\egroup,width=8cm]
\begin{tikzpicture}
	\draw (0,1) -- (0,0) -- (1,1) -- cycle;
	\fill (0,0) circle (2pt);
	\node[left] at (0,0) {$-1$};
\end{tikzpicture}
\par
\begin{tikzpicture}
	\draw (0,1) -- (0,0) -- (1,1) -- cycle;
	\fill (0,0) circle (2pt);
	\node[left] at (0,0) {$1$};
\end{tikzpicture}
\par
\begin{tikzpicture}[trim left]
	\draw (0,1) -- (0,0) -- (1,1) -- cycle;
	\fill (0,0) circle (2pt);
	\node[left] at (0,0) {$-1$};
\end{tikzpicture}
\par
\begin{tikzpicture}[trim left]
	\draw (0,1) -- (0,0) -- (1,1) -- cycle;
	\fill (0,0) circle (2pt);
	\node[left] at (0,0) {$1$};
\end{tikzpicture}
\end{codeexample}
	
	Use |trim left=default| to reset the value.
\end{key}

\begin{key}{/tikz/trim right=\meta{dimension or coordinate or \texttt{default}}}
	This key is similar to |trim left|: it discards everything which is right of the provided \meta{dimension or coordinate}. As for |trim left|, \meta{dimension} denotes a single $x$ coordinate of the picture and \meta{coordinate} a coordinate with $x$ and $y$ value (although only its $x$ component will be used).

	We use the same example from above and add |trim right|:
\begin{codeexample}[]
Text before image.%
	\begin{tikzpicture}[trim left, trim right=2cm, baseline]
		\draw (-1,-1) grid (3,2);
		\fill (0,0) circle (5pt);
	\end{tikzpicture}%
Text after image.
\end{codeexample}
	In addition to |trim left=0pt|, we also discard everything which is right of $x$|=2cm|. Furthermore, the |baseline| key supports vertical alignment as well (using the $y$|=0cm| baseline).

	Use |trim right=default| to reset the value.
\end{key}

Note that |baseline|, |trim left| and |trim right| are currently the \emph{only} supported way of truncated bounding boxes which are compatible with image externalization (see the |external| library for details).

\begin{key}{/pgf/trim lowlevel=\mchoice{true,false} (initially false)}
	This affects only the basic level image externalization: the initial configuration |trim lowlevel=false| stores the normal image, without trimming, and the trimming into a separate file. This allows reduced bounding boxes without clipping the rest away. The |trim lowlevel=true| information causes the image externalization to store the trimmed image, possibly resulting in clipping.
\end{key}

\subsection{Clipping and Fading (Soft Clipping)}

\emph{Clipping path} means that all painting on the page is restricted
to a certain area. This area need not be rectangular, rather an
arbitrary path can be used to specify this area. The |clip| option,
explained below, is used to specify the region that is to be used for
clipping.

A \emph{fading} (a term that I propose, fadings are commonly known
as soft masks, transparency masks, opacity masks or soft clips) is
similar to clipping, but a fading allows parts of the picture to be
only ``half clipped.'' This means that a fading can specify that newly
painted pixels should be partly transparent. The specification
and handling of fadings is a bit complex and it is detailed in
Section~\ref{section-tikz-transparency}, which is devoted to
transparency in general.

\begin{key}{/tikz/clip}
  This option causes all subsequent drawings to be clipped against the
  current path and the size of subsequent paths will not be important
  for the picture size.  If you clip against a self-intersecting path,
  the even-odd rule or  the nonzero winding number rule is used to
  determine whether a point is inside or outside the clipping region.

  The clipping path is a graphic state parameter, so it will be reset
  at the end of the current scope. Multiple clippings accumulate, that
  is, clipping is always done against the intersection of all clipping
  areas that have been specified inside the current scopes. The only
  way of enlarging the clipping area is to end a |{scope}|.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[clip] (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

  It  is usually a \emph{very} good idea to apply the |clip| option only
  to the first path command in a scope.

  If you ``only wish to clip'' and do not wish to draw anything, you can
  use the |\clip| command, which is a shorthand for |\path[clip]|.

\begin{codeexample}[]
\begin{tikzpicture}
  \clip (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

  To keep clipping local, use |{scope}| environments as in the
  following example:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- ( 0:1cm);
  \draw (0,0) -- (10:1cm);
  \draw (0,0) -- (20:1cm);
  \draw (0,0) -- (30:1cm);
  \begin{scope}[fill=red]
    \fill[clip] (0.2,0.2) rectangle (0.5,0.5);

    \draw (0,0) -- (40:1cm);
    \draw (0,0) -- (50:1cm);
    \draw (0,0) -- (60:1cm);
  \end{scope}
  \draw (0,0) -- (70:1cm);
  \draw (0,0) -- (80:1cm);
  \draw (0,0) -- (90:1cm);
\end{tikzpicture}
\end{codeexample}

  There is a slightly annoying catch: You cannot specify certain graphic
  options for the command used for clipping. For example, in the above
  code we could not have moved the |fill=red| to the |\fill|
  command. The reasons for this have to do with the internals of the
  \pdf\ specification. You do not want to know the details. It is best
  simply not to specify any options for these
  commands.
\end{key}



\subsection{Doing Multiple Actions on a Path}

If more than one of the basic actions like drawing, clipping and
filling are requested, they are automatically applied in a sensible
order: First, a path is filled, then drawn, and then clipped (although
it took Apple two mayor revisions of their operating system to get
this right\dots). Sometimes, however, you need finer control over what
is done with a path. For instance, you might wish to first fill a path
with a color, then repaint the path with a pattern and then repaint it
with yet another pattern. In such cases you can use the following two
options:

\begin{key}{/tikz/preactions=\meta{options}}
  This option can be given to a |\path| command (or to derived
  commands like |\draw| which internally call |\path|). Similarly to
  options like |draw|, this option only has an effect when given to a
  |\path| or as part of the options of a |node|; as an option to a
  |{scope}| it has no effect.

  When this option is used on a |\path|, the effect is the following:
  When the path has been completely constructed and is about to be
  used, a scope is created. Inside this scope, the path is used but
  not with the original path options, but with \meta{options}
  instead. Then, the path is used in the usual manner. In other words,
  the path is used twice: Once with \meta{options} in force and then
  again with the normal path options in force.

  Here is an example in which the path consists of a rectangle. The
  main action is to draw this path in red (which is why we see a red
  rectangle). However, the preaction is to draw the path in blue,
  which is why we see a blue rectangle behind the red rectangle.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \draw
    [preaction={draw,line width=4mm,blue}]
    [line width=2mm,red] (0,0) rectangle (2,2);
\end{tikzpicture}
\end{codeexample}

  Note that when the preactions are preformed, then the path is
  already ``finished.'' In particular, applying a coordinate
  transformation to the path has no effect. By comparison, applying a
  canvas transformation does have an effect. Let us use this to add a
  ``shadow'' to a path. For this, we use the preaction to fill the
  path in gray, shifted a bit to the right and down:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw
    [preaction={fill=black,opacity=.5,
                transform canvas={xshift=1mm,yshift=-1mm}}]
    [fill=red] (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}

  Naturally, you would normally create a style |shadow| that contains
  the above code. The shadow library, see
  Section~\ref{section-libs-shadows}, contains predefined shadows of
  this kind.

  It is possible to use the |preaction| option multiple times. In this
  case, for each use of the |preaction| option, the path is used again
  (thus, the \meta{options} do not accumulate in a single usage of the
  path). The path is used in the order of |preaction| options given.

  In the following example, we use one |preaction| to add a shadow and
  another to provide a shading, while the main action is to use a
  pattern.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw [pattern=fivepointed stars]
    [preaction={fill=black,opacity=.5,
                transform canvas={xshift=1mm,yshift=-1mm}}]
    [preaction={top color=blue,bottom color=white}]
               (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}

  A complicated application is shown in the following example, where
  the path is used several times with different fadings and shadings
  to create a special visual effect:
\begin{codeexample}[]
\begin{tikzpicture}
  [
    % Define an interesting style
    button/.style={
      % First preaction: Fuzzy shadow
      preaction={fill=black,path fading=circle with fuzzy edge 20 percent,
                 opacity=.5,transform canvas={xshift=1mm,yshift=-1mm}},
      % Second preaction: Background pattern
      preaction={pattern=#1,
                 path fading=circle with fuzzy edge 15 percent},
      % Third preaction: Make background shiny
      preaction={top color=white,
                 bottom color=black!50,
                 shading angle=45,
                 path fading=circle with fuzzy edge 15 percent,
                 opacity=0.2},
      % Fourth preaction: Make edge especially shiny
      preaction={path fading=fuzzy ring 15 percent,
                 top color=black!5,
                 bottom color=black!80,
                 shading angle=45},
      inner sep=2ex
    },
    button/.default=horizontal lines light blue,
    circle
  ]

  \draw [help lines] (0,0) grid (4,3);

  \node [button] at (2.2,1) {\Huge Big};
  \node [button=crosshatch dots light steel blue,
         text=white] at (1,1.5) {Small};
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/tikz/postaction=\meta{options}}
  The postactions work in the same way as the preactions, only they
  are applied \emph{after} the main action has been taken. Like
  preactions, multiple |postaction| options may be given to a |\path|
  command, in which case the path is reused several times, each time
  with a different set of options in force.

  If both pre- and postactions are specified, then the preactions are
  taken first, then the main action, and then the post actions.

  In the first example, we use a postaction to draw the path, after it
  has already been drawn:
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \draw
    [postaction={draw,line width=2mm,blue}]
    [line width=4mm,red,fill=white] (0,0) rectangle (2,2);
\end{tikzpicture}
\end{codeexample}

  In another example, we use a postaction to ``colorize'' a path:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw
    [postaction={path fading=south,fill=white}]
    [postaction={path fading=south,fading angle=45,fill=blue,opacity=.5}]
    [left color=black,right color=red,draw=white,line width=2mm]
               (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}
\end{key}



\subsection{Decorating and Morphing a Path}

Before a path is used, it is possible to first ``decorate'' and/or
``morph'' it. Morphing means that the path is replaced by another path
that is slightly varied. Such morphings are a special case
of the more general ``decorations'' described in detail in
Section~\ref{section-tikz-decorations}. For instance, in the following
example the path is drawn twice: Once normally and then in a morphed
(=decorated) manner.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) rectangle (3,2);
  \draw [red, decorate, decoration=zigzag]
        (0,0) rectangle (3,2);
\end{tikzpicture}
\end{codeexample}

Naturally, we could have combined this into a single command using
pre- or postaction. It is also possible to deform shapes:
\begin{codeexample}[]
\begin{tikzpicture}
  \node [circular drop shadow={shadow scale=1.05},minimum size=3.13cm,
         decorate, decoration=zigzag,
         fill=blue!20,draw,thick,circle] {Hello!};
\end{tikzpicture}
\end{codeexample}
