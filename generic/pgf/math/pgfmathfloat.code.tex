% Copyright 2008 by Christian Feuersaenger
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.
%
% This file contains methods for basic floating point arithmetics, rounding
% to arbitrary precision and number pretty printing.
%
% Version 1.0 2008/09/17

\global\newif\ifpgfmathfloatcomparison
\newif\ifpgfmathfloatroundhasperiod
\newif\ifpgfmathprintnumberskipzeroperiod


% used internally in grouped macros:
\toksdef\pgfmathfloat@tmptoks=1
\newif\ifpgfmathfloat@fixed@digits@after@period
\newif\ifpgfmathfloatroundmayneedrenormalize
\toksdef\pgfmathfloat@a@Mtok=0

%% WARNING: avoid conflicting register names!
\let\pgfmathfloat@a@S=\c@pgf@counta
\let\pgfmathfloat@a@M=\pgf@xa
\let\pgfmathfloat@a@E=\c@pgf@countb
\let\pgfmathfloat@b@S=\c@pgf@countc
\let\pgfmathfloat@b@M=\pgf@xb
\let\pgfmathfloat@b@E=\c@pgf@countd

% can be changed with options.
\def\pgfmathfloat@round@precision{2}

\gdef\pgfmathfloat@glob@TMP{}

% Remember the basic math commands. They will be invoked as subroutines in floating point routines.
% I don't want to switch them, even if the PGF math engine is switched to 'fp' package.
\let\pgfmath@basic@add@=\pgfmathadd@
\let\pgfmath@basic@subtract@=\pgfmathsubtract@
\let\pgfmath@basic@multiply@=\pgfmathmultiply@
\let\pgfmath@basic@divide@=\pgfmathdivide@
\let\pgfmath@basic@abs@=\pgfmathabs@
\let\pgfmath@basic@round@=\pgfmathround@
\let\pgfmath@basic@floor@=\pgfmathfloor@
\let\pgfmath@basic@ceil@=\pgfmathceil@
\let\pgfmath@basic@mod@=\pgfmathmod@
\let\pgfmath@basic@max@=\pgfmathmax@
\let\pgfmath@basic@min@=\pgfmathmin@
\let\pgfmath@basic@sin@=\pgfmathsin@
\let\pgfmath@basic@cos@=\pgfmathcos@
\let\pgfmath@basic@tan@=\pgfmathtan@
\let\pgfmath@basic@deg@=\pgfmathdeg@
\let\pgfmath@basic@rad@=\pgfmathrad@
\let\pgfmath@basic@atan@=\pgfmathatan@
\let\pgfmath@basic@asin@=\pgfmathasin@
\let\pgfmath@basic@acos@=\pgfmathacos@
\let\pgfmath@basic@cot@=\pgfmathcot@
\let\pgfmath@basic@sec@=\pgfmathsec@
\let\pgfmath@basic@cosec@=\pgfmathcosec@
\let\pgfmath@basic@pow@=\pgfmathpow@
\let\pgfmath@basic@exp@=\pgfmathexp@
\let\pgfmath@basic@ln@=\pgfmathln@
\let\pgfmath@basic@sqrt@=\pgfmathsqrt@
\let\pgfmath@basic@@pi=\pgfmath@pi
\let\pgfmath@basic@veclen@=\pgfmathveclen@
\let\pgfmath@basic@e@=\pgfmathe@
\let\pgfmath@basic@lessthan@=\pgfmathlessthan@
\let\pgfmath@basic@greaterthan@=\pgfmathgreaterthan@
\let\pgfmath@basic@equalto@=\pgfmathequalto@

% Computes a normalised floating point representation for #1 of the
% form
%   [FLAGS] MANTISSE EXPONENT
% meaning
%   [+-]X.XXXXXXX*10^C
% where 
%   X.XXXXXX is a mantisse with first number != 0, C is an integer and
% FLAGS contains the sign and some other special cases.
%
% This method does NOT use TeX Registers to represent the numbers! The
% computation is COMPLETELY STRING BASED.
% This allows numbers such at 10000000 or 5.23e-10 to be represented
% properly, although TeX-registers would produce overflow/underflow
% errors in these cases. 
%
% It is to be used to compute logs, because log(X*10^Y) = log(X) + log(10)*Y
%
% Arguments:
% #1:  an arbitrary number which shall be parsed. Maybe a macro.
%     Examples:
%     [+-]XXXXX.XXXXXX
%     [+-]XXXXX.XXXXXXeXXXX
%     [+-]0.0000XXXXXX
%     [+-]0.0000XXXXXXeXXXX
%     [+-]inf
%     nan
%    Maybe a macro containing such a number.
%
% Return value:
% \pgfmathresult will be \def'ed to
%  FLAGS MANTISSE 'e' EXPONENT
% where
% FLAGS is a number in [0-5] where
% 		0 == '0' (the number is +- 0.0),
% 		1 == '+', 
% 		2 == '-',
% 		3 == 'not a number'
% 		4 == '+ infinity'
% 		5 == '- infinity'
%
% MANTISSE is a normalised number 1 <= M < 10. It always contains a
% period and at least one digit after the period.
%
% EXPONENT is an integer value.
%
% Example:
% \pgfmathfloatparsenumber{1}
% -> \pgfmathresult = 11.0e0
% \pgfmathfloatparsenumber{141.212}
% -> \pgfmathresult = 11.41212e2
\def\pgfmathfloatparsenumber#1{%
	\begingroup
	\edef\pgfmathresult{#1}%
	\expandafter\pgfflt@impl\pgfmathresult\pgfflt@EOI
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.0}%
	\fi
	\edef\pgfmathresult{%
		\the\pgfmathfloat@a@S\the\pgfmathfloat@a@Mtok e\the\pgfmathfloat@a@E}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

% The same as \pgfmathfloatparsenumber, but does not perform sanity checking.
\def\pgfmathfloatqparsenumber#1{%
	\begingroup
	\edef\pgfmathresult{#1}%
	\expandafter\pgfflt@impl\pgfmathresult\pgfflt@EOI
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.0}%
	\fi
	\edef\pgfmathresult{%
		\the\pgfmathfloat@a@S\the\pgfmathfloat@a@Mtok e\the\pgfmathfloat@a@E}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}


% decomposes a lowlevel floating point representation into flags,
% mantisse and exponent.
%
% #4: integer register for the flags.
% #5: dimen registers for the mantisse.
% #6: integer register for the exponent.
\def\pgfmathfloat@decompose#1#2e#3\relax#4#5#6{%
   #4=#1\relax
   #5=#2pt%
   #6=#3\relax%
}
% overloaded, #5 needs to be a token register for the mantisse.
\def\pgfmathfloat@decompose@tok#1#2e#3\relax#4#5#6{%
   #4=#1\relax
   #5={#2}%
   #6=#3\relax%
}
% overloaded, returns only ONE of the three components into #4:
\def\pgfmathfloat@decompose@F#1#2e#3\relax#4{#4=#1\relax}%
\def\pgfmathfloat@decompose@M#1#2e#3\relax#4{#4=#2pt}%
\def\pgfmathfloat@decompose@Mtok#1#2e#3\relax#4{#4={#2}}%
\def\pgfmathfloat@decompose@E#1#2e#3\relax#4{#4=#3\relax}%

% Takes a floating point number #1 as input and writes flags to macro
% #2, mantisse to macro #3 and exponent to macro #4.
\def\pgfmathfloattomacro#1#2#3#4{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\xdef\pgfmathfloat@glob@TMP{%
		\noexpand\def\noexpand#2{\the\pgfmathfloat@a@S}%
		\noexpand\def\noexpand#3{\the\pgfmathfloat@a@Mtok}%
		\noexpand\def\noexpand#4{\the\pgfmathfloat@a@E}%
	}%
	\endgroup
	\pgfmathfloat@glob@TMP
}

% Takes a floating point number #1 as input and writes flags to count
% register #2, mantisse to dimen register #3 and exponent to count
% register #4.
\def\pgfmathfloattoregisters#1#2#3#4{%
	\expandafter\pgfmathfloat@decompose#1\relax{#2}{#3}{#4}%
}

% the same, but writes the mantisse into a token register.
\def\pgfmathfloattoregisterstok#1#2#3#4{%
	\expandafter\pgfmathfloat@decompose@tok#1\relax{#2}{#3}{#4}%
}

% Extracts the flags of #1 into the count register #2.
\def\pgfmathfloatgetflags#1#2{%
	\expandafter\pgfmathfloat@decompose@F#1\relax{#2}%
}
% Extracts the mantisse of #1 into the dimen register #2.
\def\pgfmathfloatgetmantisse#1#2{%
	\expandafter\pgfmathfloat@decompose@M#1\relax{#2}%
}
% Extracts the mantisse of #1 into the token register #2.
\def\pgfmathfloatgetmantissetok#1#2{%
	\expandafter\pgfmathfloat@decompose@Mtok#1\relax{#2}%
}
% Extracts the exponent of #1 into the count register #2.
\def\pgfmathfloatgetexponent#1#2{%
	\expandafter\pgfmathfloat@decompose@E#1\relax{#2}%
}

% Defines \pgfmathresult as the floating point number encoded by
% the flags #1, mantisse #2 and exponent #3.
%
% All arguments are characters and will be expanded using '\edef'.
\def\pgfmathfloatcreate#1#2#3{%
	\edef\pgfmathresult{#1#2e#3}%
}%


% Compares #1 with #2 and sets \pgfmathresult either to 1.0 or 0.0.
% 
% It also sets the boolean \ifpgfmathfloatcomparison (globally.
\def\pgfmathfloatlessthan@#1#2{%
%\def\pgfmathfloatlessthan#1#2#3\and#4#5#6{%
	\global\pgfmathfloatcomparisonfalse
	\begingroup
	\expandafter\pgfmathfloat@decompose#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@M\pgfmathfloat@a@E
	\expandafter\pgfmathfloat@decompose#2\relax\pgfmathfloat@b@S\pgfmathfloat@b@M\pgfmathfloat@b@E
	\ifcase\pgfmathfloat@a@S
		% x = 0 -> (x<y <=> y >0)
		\ifnum1=\pgfmathfloat@b@S
			\global\pgfmathfloatcomparisontrue
		\fi
	\or
		% x > 0 -> (x<y <=> ( y > 0 && |x| < |y|) )
		\ifnum1=\pgfmathfloat@b@S
			% y>0:
			\pgfmathfloatlessthan@positive
		\fi
	\or
		% x < 0 -> (x<y <=> (y >= 0 ||   |x| > |y|) )
		\ifnum2=\pgfmathfloat@b@S
			% 'y<0':
			\pgfmathfloatgreaterthan@positive
		\else
			\global\pgfmathfloatcomparisontrue
		\fi
	\else
		\pgfmath@error{Sorry, 'pgfmathfloatlessthan@{#1}{#2}' not yet supported.}%
	\fi
	\endgroup
	\ifpgfmathfloatcomparison
		\def\pgfmathresult{1.0}%
	\else
		\def\pgfmathresult{0.0}%
	\fi
}
\let\pgfmathfloatlessthan=\pgfmathfloatlessthan@

% compares \pgfmathfloat@a@[SME] < \pgfmathfloat@b@[SME]
\def\pgfmathfloatlessthan@positive{%
	\ifnum\pgfmathfloat@a@E<\pgfmathfloat@b@E
		\global\pgfmathfloatcomparisontrue
	\else
		\ifnum\pgfmathfloat@a@E=\pgfmathfloat@b@E
			\ifdim\pgfmathfloat@a@M<\pgfmathfloat@b@M
				\global\pgfmathfloatcomparisontrue
			\fi
		\fi
	\fi
}

% compares \pgfmathfloat@a@[SME] > \pgfmathfloat@b@[SME]
\def\pgfmathfloatgreaterthan@positive{%
	\ifnum\pgfmathfloat@a@E>\pgfmathfloat@b@E
		\global\pgfmathfloatcomparisontrue
	\else
		\ifnum\pgfmathfloat@a@E=\pgfmathfloat@b@E
			\ifdim\pgfmathfloat@a@M>\pgfmathfloat@b@M
				\global\pgfmathfloatcomparisontrue
			\fi
		\fi
	\fi
}


\def\pgfmathfloatmax@#1#2{%
	\pgfmathfloatlessthan{#1}{#2}%
	\ifpgfmathfloatcomparison
		\edef\pgfmathresult{#2}%
	\else
		\edef\pgfmathresult{#1}%
	\fi
}
\let\pgfmathfloatmax=\pgfmathfloatmax@

\def\pgfmathfloatmin@#1#2{%
	\pgfmathfloatlessthan{#1}{#2}%
	\ifpgfmathfloatcomparison
		\edef\pgfmathresult{#1}%
	\else
		\edef\pgfmathresult{#2}%
	\fi
}
\let\pgfmathfloatmin=\pgfmathfloatmin@

% Renormalizes #1 to extended precision mantisse, meaning
% 100 <= m < 1000
% instead of 1 <= m < 10.
% 
% The 'extended precision' means we have higher accuracy when we apply pgfmath operations to mantisses.
%
% The input argument is expected to be a normalized floating point number; the output argument is a non-normalized floating point number (well, normalized to extended precision).
%
% The operation is supposed to be very fast.
%
% @see \pgfmathfloatsetextprecision
%
% There is a routine for internal usage,
% \pgfmathfloattoextentedprecision@a. It also provides exponent and
% sign of #1 in output arguments and may be used to increase speed.
\def\pgfmathfloattoextentedprecision#1{%
	\begingroup
	\pgfmathfloattoextentedprecision@a{#1}%
	\pgfmathfloatcreate{\pgfmathfloat@a@S}{\pgfmathresult}{\pgfmathfloat@a@E}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

\def\pgfmathfloattoextentedprecision@@zero#1\pgfmathfloat@EOI{%
	\edef\pgfmathresult{#1}%
}%
\def\pgfmathfloattoextentedprecision@@one#1.#2#3\pgfmathfloat@EOI{%
	\edef\pgfmathresult{#1#2.#3}%
}%
\def\pgfmathfloattoextentedprecision@@two#1.#2#3#4\pgfmathfloat@EOI{%
	\edef\pgfmathresult{#1#2#3.#4}%
}%
\def\pgfmathfloattoextentedprecision@@three#1.#2#3#4#5\pgfmathfloat@EOI{%
	\edef\pgfmathresult{#1#2#3#4.#5}%
}%

% Sets extended precision to 10^#1.
%
% The different choices are
% 
% - 0:  normalization      0 <= m < 1 (disable extended precision)
% - 1:  normalization     10 <= m < 100
% - 2:  normalization    100 <= m < 1000  (default)
% - 3:  normalization   1000 <= m < 10000
%
% #1 is the exponent, #1 = 0,1,2 or 3.
%
% This setting applies to \pgfmathfloattoextentedprecision and friends.
\def\pgfmathfloatsetextprecision#1{%
	\ifcase#1\relax
		\let\pgfmathfloattoextentedprecision@@=\pgfmathfloattoextentedprecision@@zero
		\def\pgfmathfloatextprec@shift{0}%
	\or
		\let\pgfmathfloattoextentedprecision@@=\pgfmathfloattoextentedprecision@@one
		\def\pgfmathfloatextprec@shift{1}%
	\or
		\let\pgfmathfloattoextentedprecision@@=\pgfmathfloattoextentedprecision@@two
		\def\pgfmathfloatextprec@shift{2}%
	\else
		\let\pgfmathfloattoextentedprecision@@=\pgfmathfloattoextentedprecision@@three
		\def\pgfmathfloatextprec@shift{3}%
	\fi
}%
\pgfmathfloatsetextprecision{2}%

% Does the "hard" work for \pgfmathfloattoextentedprecision. It
% provides additional outputs.
%
% INPUT:
% #1  normalized floating point number. Maybe a macro (it will be expanded ONCE)
% 
% OUTPUT:
% - \pgfmathresult : the mantisse in extended precision
% - \pgfmathfloat@a@S : the sign of #1
% - \pgfmathfloat@a@E : the exponent of #1, adjusted for extended precision
% - \pgfmathfloat@a@Mtok : undefined (its contents will be destroyed.
%
\def\pgfmathfloattoextentedprecision@a#1{%
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\ifnum\pgfmathfloat@a@S<3
		\advance\pgfmathfloat@a@E by-\pgfmathfloatextprec@shift\relax% compensate for shift
		\expandafter\pgfmathfloattoextentedprecision@@\the\pgfmathfloat@a@Mtok 000\pgfmathfloat@EOI
	\else
		\edef\pgfmathresult{#1}%
	\fi
}%


% Similar to \pgfmathfloattoextentedprecision@a, this one here fills the '@b' registers.
\def\pgfmathfloattoextentedprecision@b#1{%
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@b@S\pgfmathfloat@a@Mtok\pgfmathfloat@b@E
	\ifnum\pgfmathfloat@b@S<3
		\advance\pgfmathfloat@b@E by-\pgfmathfloatextprec@shift\relax
		\expandafter\pgfmathfloattoextentedprecision@@\the\pgfmathfloat@a@Mtok 00\pgfmathfloat@EOI
	\else
		\edef\pgfmathresult{#1}%
	\fi
}%

% Addition of two floating point numbers using 8 significant digits.
\def\pgfmathfloatadd@#1#2{%
	\begingroup
	%
	% renormalize argument to 100 <= m < 1000 for extended accuracy:
	\pgfmathfloattoextentedprecision@a{#1}%
	\let\pgfmathfloat@arga=\pgfmathresult
	%
	\pgfmathfloattoextentedprecision@b{#2}%
	\let\pgfmathfloat@argb=\pgfmathresult
	%
	\pgfmathfloatcomparisontrue% re-use this boolean here to handle special cases.
	\ifcase\pgfmathfloat@a@S
		\edef\pgfmathresult{#2}%
		\pgfmathfloatcomparisonfalse
	\or
	\or
		\edef\pgfmathfloat@arga{-\pgfmathfloat@arga}%
	\else
		\pgfmathfloatcomparisonfalse
		\pgfmathfloatcreate{\the\pgfmathfloat@a@S}{0.0}{0}%
	\fi
	\ifcase\pgfmathfloat@b@S
		\edef\pgfmathresult{#1}%
		\pgfmathfloatcomparisonfalse
	\or
	\or
		\edef\pgfmathfloat@argb{-\pgfmathfloat@argb}%
	\else
		\pgfmathfloatcomparisonfalse
		\pgfmathfloatcreate{\the\pgfmathfloat@b@S}{0.0}{0}%
	\fi
	\ifpgfmathfloatcomparison
		% Shift lesser mantisse to fit the larger one:
		\ifnum\pgfmathfloat@a@E<\pgfmathfloat@b@E
			\pgfmathfloatadd@shift{\pgfmathfloat@arga}{\pgfmathfloat@a@E}{\pgfmathfloat@b@E}%
		\else
			\pgfmathfloatadd@shift{\pgfmathfloat@argb}{\pgfmathfloat@b@E}{\pgfmathfloat@a@E}%
		\fi
		% add them!
		\pgfmath@basic@add@{\pgfmathfloat@arga}{\pgfmathfloat@argb}%
		% renormalize sum. This is the only part were an expensive routine comes into play:
		\edef\pgfmathresult{\pgfmathresult e\the\pgfmathfloat@a@E}%
		\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

% #1= floating point number
% #2= TeX code to execute if #1 == 0
% #3= TeX code to execute if #1 != 0
\def\pgfmathfloatifzero#1#2#3{%
	\expandafter\pgfmathfloat@decompose@F#1\relax\pgfmathfloat@a@S
	\ifnum\pgfmathfloat@a@S=0 #2\else#3\fi
}%

% #1=mantisse which needs to be shifted (with smaller exponent)
% #2=smaller exponent
% #3=larger exponent
% 
% ATTENTION: this helper method DESTROYS contents of \pgfmathfloat@a@S.
\def\pgfmathfloatadd@shift#1#2#3{%
	\pgf@xa=#1 pt%
	\pgfmathfloat@a@S=#3\relax
	\advance\pgfmathfloat@a@S by-#2\relax
	\ifcase\pgfmathfloat@a@S
	\or
		\divide\pgf@xa by10\relax
	\or
		\divide\pgf@xa by100\relax
	\or
		\divide\pgf@xa by1000\relax
	\or
		\divide\pgf@xa by10000\relax
	\or
		\divide\pgf@xa by10000\relax
		\divide\pgf@xa by10\relax
	\or
		\divide\pgf@xa by10000\relax
		\divide\pgf@xa by100\relax
	\or
		\divide\pgf@xa by10000\relax
		\divide\pgf@xa by1000\relax
	\or
		\divide\pgf@xa by10000\relax
		\divide\pgf@xa by10000\relax
	\else
		\pgf@xa=0pt%
	\fi
	#2=#3\relax
	\edef#1{\pgf@sys@tonumber\pgf@xa}%
}

\let\pgfmathfloatadd=\pgfmathfloatadd@


% Subtracts two floating point numbers.
\def\pgfmathfloatsubtract@#1#2{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#2\relax\pgfmathfloat@b@S\pgfmathfloat@a@Mtok\pgfmathfloat@b@E
	\ifcase\pgfmathfloat@b@S
		\edef\pgfmathresult{#1}%
	\or
		\pgfmathfloatcreate{2}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@b@E}%
		\let\pgfmathfloatsub@arg=\pgfmathresult
		\pgfmathfloatadd@{#1}{\pgfmathfloatsub@arg}%
	\or
		\pgfmathfloatcreate{1}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@b@E}%
		\let\pgfmathfloatsub@arg=\pgfmathresult
		\pgfmathfloatadd@{#1}{\pgfmathfloatsub@arg}%
	\else
		\pgfmathfloatcreate{\the\pgfmathfloat@b@S}{0.0}{0}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

\let\pgfmathfloatsubtract=\pgfmathfloatsubtract@

% Scales a floating point number #1 with a fixed point number #2 using pgfmathmultiply.
% 
% Use this method if #2 is small number.
\def\pgfmathfloatmultiplyfixed@#1#2{%
	\begingroup
	%
	% renormalize argument to 100 <= m < 1000 for extended accuracy:
	\pgfmathfloattoextentedprecision@a{#1}%
	\let\pgfmathfloat@arga=\pgfmathresult
	%
	\pgfmathfloatcomparisontrue% re-use this boolean here to handle special cases.
	\ifcase\pgfmathfloat@a@S
		\edef\pgfmathresult{#1}%
		\pgfmathfloatcomparisonfalse
	\or
	\or
		\edef\pgfmathfloat@arga{-\pgfmathfloat@arga}%
	\else
		\pgfmathfloatcomparisonfalse
		\pgfmathfloatcreate{\the\pgfmathfloat@a@S}{0.0}{0}%
	\fi
	\ifpgfmathfloatcomparison
		\pgfmath@basic@multiply@{\pgfmathfloat@arga}{#2}%
		% renormalize product. This is the only part were an expensive routine comes into play:
		\edef\pgfmathresult{\pgfmathresult e\the\pgfmathfloat@a@E}%
		\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

\let\pgfmathfloatmultiplyfixed=\pgfmathfloatmultiplyfixed@


\def\pgfmathfloatmultiply@#1#2{%
	\begingroup
	\pgfmathfloatsetextprecision{1}%
	\edef\pgfmathfloat@arga{#1}%
	\pgfmathfloattoextentedprecision@a{\pgfmathfloat@arga}%
	\let\pgfmathfloat@arga=\pgfmathresult
	%
	\edef\pgfmathfloat@argb{#2}%
	\pgfmathfloattoextentedprecision@b{\pgfmathfloat@argb}%
	\let\pgfmathfloat@argb=\pgfmathresult
	%
	\pgfmathfloatcomparisontrue% re-use this boolean here to handle special cases.
	\ifcase\pgfmathfloat@a@S
	% 0
		\pgfmathfloatcreate{0}{0.0}{0}%
		\pgfmathfloatcomparisonfalse
	\or% +
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\def\pgfmathresult@S{1}%
		\or
			\def\pgfmathresult@S{2}%
		\else
			\expandafter\pgfmathfloatcreate\the\pgfmathfloat@b@S{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\or% -
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\def\pgfmathresult@S{2}%
		\or
			\def\pgfmathresult@S{1}%
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\or% nan
		\pgfmathfloatcreate{3}{0.0}{0}%
		\pgfmathfloatcomparisonfalse
	\or% +infty
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\or% -infty
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\fi
	\ifpgfmathfloatcomparison
		\pgfmath@basic@multiply@{\pgfmathfloat@arga}{\pgfmathfloat@argb}%
		\advance\pgfmathfloat@a@E by\pgfmathfloat@b@E
		% renormalize sum. This is the only part were an expensive routine comes into play:
		\edef\pgfmathresult{\pgfmathresult e\the\pgfmathfloat@a@E}%
		\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
		\expandafter\pgfmathfloat@decompose@tok\pgfmathresult\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
		\pgfmathfloatcreate{\pgfmathresult@S}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@a@E}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\let\pgfmathfloatmultiply=\pgfmathfloatmultiply@

% Defines \pgfmathresult to be #1 / #2 for two floating point numbers.
%
% It employs the basic math engine internally to divide mantissas.
\def\pgfmathfloatdivide@#1#2{%
	\begingroup
	\pgfmathfloatsetextprecision{1}% is not too important, I think. After all, 0.1 <= #1/#2 < 10 or so due to normalization (no matter, which)
	\edef\pgfmathfloat@arga{#1}%
	\pgfmathfloattoextentedprecision@a{\pgfmathfloat@arga}%
	\let\pgfmathfloat@arga=\pgfmathresult
	%
	\edef\pgfmathfloat@argb{#2}%
	\pgfmathfloattoextentedprecision@b{\pgfmathfloat@argb}%
	\let\pgfmathfloat@argb=\pgfmathresult
	%
	\pgfmathfloatcomparisontrue% re-use this boolean here to handle special cases.
	\ifcase\pgfmathfloat@a@S
	% 0
		\pgfmathfloatcreate{0}{0.0}{0}%
		\pgfmathfloatcomparisonfalse
	\or% +
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\def\pgfmathresult@S{1}%
		\or
			\def\pgfmathresult@S{2}%
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\else
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\or% -
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\def\pgfmathresult@S{2}%
		\or
			\def\pgfmathresult@S{1}%
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\else
			\pgfmathfloatcreate{0}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\or% nan
		\pgfmathfloatcreate{3}{0.0}{0}%
		\pgfmathfloatcomparisonfalse
	\or% +infty
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}% what is inf/inf ?
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}% or inf/-inf ?
			\pgfmathfloatcomparisonfalse
		\fi
	\or% -infty
		\ifcase\pgfmathfloat@b@S
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{3}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{5}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\or
			\pgfmathfloatcreate{4}{0.0}{0}%
			\pgfmathfloatcomparisonfalse
		\fi
	\fi
	\ifpgfmathfloatcomparison
		\pgfmath@basic@divide@{\pgfmathfloat@arga}{\pgfmathfloat@argb}%
		\advance\pgfmathfloat@a@E by-\pgfmathfloat@b@E
		% renormalize. This is the only part were an expensive float routine comes into play:
		\edef\pgfmathresult{\pgfmathresult e\the\pgfmathfloat@a@E}%
		\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
		% And re-insert the proper sign:
		\expandafter\pgfmathfloat@decompose@tok\pgfmathresult\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
		\pgfmathfloatcreate{\pgfmathresult@S}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@a@E}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\let\pgfmathfloatdivide=\pgfmathfloatdivide@

% Computes sqrt(#1) in floating point arithmetics.
%
% It employs sqrt( m * 10^e ) = sqrt(m) * sqrt(10^e).
\def\pgfmathfloatsqrt@#1{%
	\begingroup
	\pgfmathfloatsetextprecision{3}%
	\edef\pgfmathfloat@arga{#1}%
	\pgfmathfloattoextentedprecision@a{\pgfmathfloat@arga}%
	\let\pgfmathfloat@arga=\pgfmathresult
	%
	\ifcase\pgfmathfloat@a@S
	% 0
		\pgfmathfloatcreate{0}{0.0}{0}%
	\or% +
		\pgfmath@basic@sqrt@{\pgfmathfloat@arga}%
		\ifodd\pgfmathfloat@a@E
			\ifnum\pgfmathfloat@a@E>0
				\expandafter\pgfmathmultiply@\expandafter{\pgfmathresult}{3.16227766}% * sqrt(10)
			\else
				\expandafter\pgfmathmultiply@\expandafter{\pgfmathresult}{0.316227766}% * sqrt(0.1)
			\fi
		\fi
		\divide\pgfmathfloat@a@E by2 % sqrt(10^e) = 10^{e/2} (see above for odd e)
		% renormalize sum. This is the only part were an expensive routine comes into play:
		\edef\pgfmathfloat@arga{\pgfmathresult e\the\pgfmathfloat@a@E}%
		\pgfmathfloatqparsenumber{\pgfmathfloat@arga}%
	\or% -
		\pgfmathfloatcreate{3}{0.0}{0}%
	\or% nan
		\pgfmathfloatcreate{3}{0.0}{0}%
	\or% +infty
		\pgfmathfloatcreate{4}{0.0}{0}%
	\or% -infty
		\pgfmathfloatcreate{3}{0.0}{0}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\let\pgfmathfloatsqrt=\pgfmathfloatsqrt@

% Returns the integer part of the floating point number #1.
%
% The result is returned as floating point as well. 
%
% This operation is not limited to TeX's range of count registers (it
% works symbolly)
\def\pgfmathfloatint@#1{%
	\begingroup
	\edef\pgfmathresult{#1}%
	\expandafter\pgfmathfloat@decompose@tok\pgfmathresult\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\ifcase\pgfmathfloat@a@S
		% 0: nothing to do.
	\or% +
		\expandafter\pgfmathfloatint@@\the\pgfmathfloat@a@Mtok\pgfmathfloat@EOI
		\pgfmathfloatcreate{\the\pgfmathfloat@a@S}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@a@E}%
	\or% -
		\expandafter\pgfmathfloatint@@\the\pgfmathfloat@a@Mtok\pgfmathfloat@EOI
		\pgfmathfloatcreate{\the\pgfmathfloat@a@S}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@a@E}%
	\else
		% nothing to do
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\def\pgfmathfloatint@@#1.{%
	\ifnum\pgfmathfloat@a@E<0
		\pgfmathfloat@a@S=0
		\pgfmathfloat@a@Mtok={0.0}%
		\pgfmathfloat@a@E=0
		\expandafter\pgfmathfloatint@@loop@gobble
	\else
		\pgfmathfloat@a@Mtok={#1.}%
		\pgfmathfloat@b@E=\pgfmathfloat@a@E
		\expandafter\pgfmathfloatint@@loop
	\fi
}%
\def\pgfmathfloatint@@loop#1{%
	\def\pgfmathfloatint@@loop@{#1}%
	\ifx\pgfmathfloatint@@loop@\pgfmathfloat@EOI
		\let\pgfmathfloatint@@loop@next=\relax
	\else
		\ifnum\pgfmathfloat@b@E=0
			\let\pgfmathfloatint@@loop@next=\pgfmathfloatint@@loop@gobble
		\else
			\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok#1}%
			\advance\pgfmathfloat@b@E by-1
			\let\pgfmathfloatint@@loop@next=\pgfmathfloatint@@loop
		\fi
	\fi
	\pgfmathfloatint@@loop@next
}%
\def\pgfmathfloatint@@loop@gobble#1\pgfmathfloat@EOI{}%
\let\pgfmathfloatint=\pgfmathfloatint@

% Converts a composed floating point representation to fixed point.
%
% Example:
% \pgfmathfloattofixed{142e1}
% -> \pgfmathresult = 42.0
\def\pgfmathfloattofixed@#1{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\ifcase\pgfmathfloat@a@S
		\def\pgfmathresult{0.0}%
	\or
		\expandafter\pgfmathfloattofixed@impl\the\pgfmathfloat@a@Mtok\relax
	\or
		\expandafter\pgfmathfloattofixed@impl\the\pgfmathfloat@a@Mtok\relax
		\pgfmathfloat@a@Mtok=\expandafter{\pgfmathresult}%
		\edef\pgfmathresult{-\the\pgfmathfloat@a@Mtok}%
	\or\def\pgfmathresult{nan}%
	\or\def\pgfmathresult{inf}%
	\or\def\pgfmathresult{-inf}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}
\let\pgfmathfloattofixed=\pgfmathfloattofixed@

% Converts a floating point number to scientific format 1.234e5.
%
% This operation is very fast.
\def\pgfmathfloattosci@#1{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\ifcase\pgfmathfloat@a@S
		\def\pgfmathresult{0.0e0}%
	\or
		\edef\pgfmathresult{\the\pgfmathfloat@a@Mtok e\the\pgfmathfloat@a@E}%
	\or
		\edef\pgfmathresult{-\the\pgfmathfloat@a@Mtok e\the\pgfmathfloat@a@E}%
	\or\def\pgfmathresult{nan}%
	\or\def\pgfmathresult{inf}%
	\or\def\pgfmathresult{-inf}%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\let\pgfmathfloattosci=\pgfmathfloattosci@

% Divides or multiplies the input number by 10^#4 using an arithmetic
% left/right shift.
%
% Input:
% #1 a normalised floating point number.
% #2 a positive or negative integer number denoting the shift.
%
% Example:
% \pgfmathfloatshift{11e3}{4}%
% -> pgfmathresult = 11e7
\def\pgfmathfloatshift@#1#2{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\expandafter\advance\expandafter\pgfmathfloat@a@E#2\relax
	\edef\pgfmathresult{\the\pgfmathfloat@a@S\the\pgfmathfloat@a@Mtok e\the\pgfmathfloat@a@E}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}
\let\pgfmathfloatshift=\pgfmathfloatshift@

% Defines \pgfmathresult to be |#1|, the absolute value of the
% normalized floating point number #1.
\def\pgfmathfloatabs@#1{%
	\begingroup
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\ifcase\pgfmathfloat@a@S
		% 0: do nothing.
	\or
		% +: ok, is positive.
	\or
		% -: multiply with -1:
		\pgfmathfloat@a@S=1
	\or
		% nan: do nothing.
	\or
		% +infty: ok.
	\or
		% -infty: multiply with -1:
		\pgfmathfloat@a@S=4
	\fi
	\pgfmathfloatcreate{\the\pgfmathfloat@a@S}{\the\pgfmathfloat@a@Mtok}{\the\pgfmathfloat@a@E}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%
\let\pgfmathfloatabs=\pgfmathfloatabs@

% Computes the absolute error |#1 - #2| into \pgfmathresult.
\def\pgfmathfloatabserror@#1#2{%
	\pgfmathfloatsubtract@{#1}{#2}%
	\pgfmathfloatabs@{\pgfmathresult}%
}%
\let\pgfmathfloatabserror=\pgfmathfloatabserror@

% Computes the relative error |#1 - #2|/|#2| into \pgfmathresult,
% assuming #2 != 0.
\def\pgfmathfloatrelerror@#1#2{%
	\pgfmathfloatsubtract@{#1}{#2}%
	\pgfmathfloatdivide@{\pgfmathresult}{#2}%
	\pgfmathfloatabs@{\pgfmathresult}%
}%
\let\pgfmathfloatrelerror=\pgfmathfloatrelerror@

% Expands #2 using \edef and invokes #1 with the resulting string.
%
% DEPRECATED
% Example:
%   \pgfmath@y=7.9pt
%   \pgfmathlog@invoke@expanded\pgfmathexp@{{\pgf@sys@tonumber{\pgfmath@y}}}%
% will invoke
%   \pgfmathexp@{7.9}
\def\pgfmathlog@invoke@expanded#1#2{%
	\edef\pgfmath@resulttemp{#2}%
	\expandafter#1\pgfmath@resulttemp
}

% Computes log(x) into \pgfmathresult.
%
% This allows numbers such at 10000000 or 5.23e-10 to be represented
% properly, although TeX-registers would produce overflow/underflow
% errors in these cases. 
%
% The natural logarithm is computed using log(X*10^Y) = log(X) + log(10)*Y
\def\pgfmathlog@#1{%
	\pgfmathfloatparsenumber{#1}%
	\pgfmathlog@float{\pgfmathresult}%
}
\let\pgfmathlog=\pgfmathlog@
\def\pgfmathlog@float#1{%
	\begingroup%
		% compute #1 = M*10^E with normalised mantisse M = [+-]*[1-9].XXXXX
		\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
		\ifnum\pgfmathfloat@a@S=1
			% Now, compute log(#1) = log(M) + E*log(10)
			\expandafter\pgfmath@basic@ln@\expandafter{\the\pgfmathfloat@a@Mtok}%
			\pgfmathfloat@b@M=\pgfmathresult pt%
			\pgfmathfloat@a@M=2.302585pt% = log(10)
			\multiply\pgfmathfloat@a@M by\pgfmathfloat@a@E\relax
			\advance\pgfmathfloat@b@M by\pgfmathfloat@a@M
			\edef\pgfmathresult{\pgf@sys@tonumber{\pgfmathfloat@b@M}}%
		\else
			\let\pgfmathresult=\pgfutil@empty%
		\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup%
}

% Rounds a fixed point number #1 to \pgfmathfloat@round@precision digits precision and returns
% the result into \pgfmathresult.
%
% Any trailing zeros after the period are discarded.
% See \pgfmathroundtozerofill if you want trailing zeros and fixed
% width.
%
% This method is PURELY text based and can work with arbirtrary
% precision (well, limited to TeX's stack size and integer size).
%
% Examples:
% \pgfmathroundto{1}
% -> \pgfmathresult = '1'
%
% \pgfmathroundto{19999.9996}
% -> \pgfmathresult = '20000'
%
% Arguments:
% #1 may be either a number or a macro expanding to a number.
%
% SIDE EFFECT: the global variable \ifpgfmathfloatroundhasperiod will be set.
\def\pgfmathroundto#1{%
	\pgfmathfloatroundhasperiodtrue
	\begingroup
	\pgfmathfloat@fixed@digits@after@periodfalse
	\pgfmathroundto@impl{#1}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}


% Overloaded method. 
%
% This variant always uses a FIXED number behind the period and fills
% in zeros if necessary.
% Examples:
% \pgfmathroundtozerofill{1}
% -> \pgfmathresult = '1.00'
%
% \pgfmathroundtozerofill{19999.9996}
% -> \pgfmathresult = '20000.00'
%
% SIDE EFFECT: the global variable \ifpgfmathfloatroundhasperiod will be set.
\def\pgfmathroundtozerofill#1{%
	\pgfmathfloatroundhasperiodtrue
	\begingroup
	\pgfmathfloat@fixed@digits@after@periodtrue
	\pgfmathroundto@impl{#1}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

% see \pgfmathprintnumber@fixed@style for docs
\def\pgfmathprintnumber@fixed@styleDEFAULT#1#2#3e#4\relax{%
	\begingroup
	\pgfkeysgetvalue{/pgf/number format/set decimal separator}\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP
	\pgfkeysgetvalue{/pgf/number format/@dec sep mark}\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP@MARK
	\pgfkeysgetvalue{/pgf/number format/set thousands separator}\pgfmathprintnumber@fixed@styleDEFAULT@THOUSAND@SEP
	\c@pgf@counta=#4\relax
	\def\pgfmathresult{}%
	\ifpgfmathfloatroundhasperiod
		\expandafter\pgfmathprintnumber@fixed@styleDEFAULT@impl@period#1\pgfmathfloat@EOI
	\else
		\expandafter\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod#1\pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI%
		\begingroup
		\toks0=\expandafter{\pgfmathresult}%
		\toks1=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP@MARK}%
		\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 }%
		\endgroup
		\let\pgfmathresult=\pgfmathfloat@glob@TMP
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@period#1.#2\pgfmathfloat@EOI{%
	\ifpgfmathprintnumberskipzeroperiod
		\def\pgfmathfloat@loc@TMPb{#1}%
		\ifx\pgfmathfloatparsenumber@tok@ZERO\pgfmathfloat@loc@TMPb
		\else
			\def\pgfmathfloat@loc@TMPc{-0}%
			\ifx\pgfmathfloat@loc@TMPc\pgfmathfloat@loc@TMPb
				\def\pgfmathresult{-}%
			\else
				\def\pgfmathfloat@loc@TMPc{+0}%
				\ifx\pgfmathfloat@loc@TMPc\pgfmathfloat@loc@TMPb
					\def\pgfmathresult{+}%
				\else
					\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod#1\pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI
				\fi
			\fi
		\fi
	\else
		\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod#1\pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI
	\fi
	\begingroup
	\toks0=\expandafter{\pgfmathresult}%
	\toks1=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP@MARK}%
	\toks2=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP #2}%
	\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 \the\toks2 }%
	\endgroup
	\let\pgfmathresult=\pgfmathfloat@glob@TMP
}%
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod{%
	\ifx\pgfmathprintnumber@fixed@styleDEFAULT@THOUSAND@SEP\pgfutil@empty
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall}%
	\else
		\ifnum\c@pgf@counta<0\relax
			\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
				\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall}%
		\else
			\ifnum\c@pgf@counta<\pgfkeysvalueof{/pgf/number format/min exponent for 1000 sep}\relax
				\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
					\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall}%
			\else
				\advance\c@pgf@counta by1 % counta:= total number of digits, N.
				\c@pgf@countb=\c@pgf@counta
				\divide\c@pgf@countb by3 %  countb := N DIV 3
				\c@pgf@countc=\c@pgf@countb
				\multiply\c@pgf@countc by3
				\advance\c@pgf@counta by-\c@pgf@countc% now counta := N MOD 3
				\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
					\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printsign
				}%
			\fi
		\fi
	\fi
	\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printsign#1{%
	\def\pgfmathfloat@loc@TMPb{#1}%
	\ifx\pgfmathfloat@loc@TMPb\pgfmathfloatparsenumber@tok@MINUS
		\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1}%
		\let\pgfmathfloat@loc@TMPb=\pgfutil@empty
	\else
		\ifx\pgfmathfloat@loc@TMPb\pgfmathfloatparsenumber@tok@PLUS
			\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1}%
			\let\pgfmathfloat@loc@TMPb=\pgfutil@empty
		\else
			\ifpgfmathprintnumber@showpositive
				\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult +}%
			\fi
		\fi
	\fi
	\ifnum\c@pgf@counta>0
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\expandafter\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printtrailingdigits\pgfmathfloat@loc@TMPb
		}%
	\else
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\expandafter\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@counteverythird\pgfmathfloat@loc@TMPb
		}%
	\fi
	\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printtrailingdigits#1#2{%
	\ifcase\c@pgf@counta
	\or
		\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1}%
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@counteverythird#2%
		}%
	\or
		\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1#2}%
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@counteverythird%
		}%
	\fi
	\ifnum\c@pgf@countb>0\relax
		\begingroup
		\toks0=\expandafter{\pgfmathresult}%
		\toks1=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@THOUSAND@SEP}%
		\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 }%
		\endgroup
		\let\pgfmathresult=\pgfmathfloat@glob@TMP
	\fi
	\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@counteverythird#1#2#3{%
	\ifnum\c@pgf@countb>0\relax
		\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1#2#3}%
		\advance\c@pgf@countb by-1
		\ifnum\c@pgf@countb>0\relax
			\begingroup
			\toks0=\expandafter{\pgfmathresult}%
			\toks1=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@THOUSAND@SEP}%
			\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 }%
			\endgroup
			\let\pgfmathresult=\pgfmathfloat@glob@TMP
		\fi
		\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT{%
			\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@counteverythird%
		}%
	\else
		% in thise case, #1#2#3 are expected to be
		% \pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI
		%--------------------------------------------------
		% \def\pgfmathfloat@loc@TMPb{\pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI}%
		% \def\pgfmathfloat@loc@TMPc{#1#2#3}%
		% \ifx\pgfmathfloat@loc@TMPc\pgfmathfloat@loc@TMPb
		% \else
		% 	\pgfmath@error{INTERNAL ERROR in fixed style - The input sequence did not terminate as expected; which indicates a wrong exponent argument provided to \string\pgfmathprintnumber@fixed@style}%
		% \fi
		%-------------------------------------------------- 
		\let\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT=\relax
	\fi
	\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@NEXT
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall#1{%
	\def\pgfmathfloat@loc@TMPb{#1}%
	\let\pgfmathfloat@loc@TMPc=\pgfutil@empty
	\ifx\pgfmathfloat@loc@TMPb\pgfmathfloatparsenumber@tok@MINUS
	\else
		\ifx\pgfmathfloat@loc@TMPb\pgfmathfloatparsenumber@tok@PLUS
		\else
			\ifpgfmathprintnumber@showpositive
				\def\pgfmathfloat@loc@TMPc{+}%
			\fi
		\fi
	\fi
	\expandafter\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall@\pgfmathfloat@loc@TMPc#1%
}
\def\pgfmathprintnumber@fixed@styleDEFAULT@impl@noperiod@printall@#1\pgfmathfloat@EOI\pgfmathfloat@EOI\pgfmathfloat@EOI{%
	\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult #1}%
}%

% #1 maybe a macro
\def\pgfmathprintnumber@fixed@stylePERIOD#1#2#3e#4\relax{%
	\def\pgfmathresult{#1}%
}

% #1 maybe a macro
\def\pgfmathprintnumber@fixed@styleCOMMA#1#2#3e#4\relax{%
	\ifpgfmathfloatroundhasperiod
		\expandafter\pgfmathprintnumber@fixed@styleCOMMA@impl#1\pgfmathfloat@EOI
	\else
		\def\pgfmathresult{#1}%
	\fi
}
\def\pgfmathprintnumber@fixed@styleCOMMA@impl#1.#2\pgfmathfloat@EOI{\def\pgfmathresult{#1{,}#2}}

% The default style to display fixed point numbers.
%
% It does not apply numerics, but it is responsable to typeset the
% rounded number.
% It can access the \ifpgfmathfloatroundhasperiod boolean.
%
% Arguments:
% #1#2#3e#4\relax

% Input: 
% #1  the fixed point number to be displayed (maybe a macro).
% #2#3e#4:  the (possibly unformatted) floating point representation which belongs to #1.
%     It is used to determine sign and exponent.
\let\pgfmathprintnumber@fixed@style=\pgfmathprintnumber@fixed@styleDEFAULT


% Rounds a normalized floating point number to \pgfmathfloat@round@precision 
% digits precision and writes the result to \pgfmathresult.
%
% This method uses \pgfmathroundto for the mantisse.
%
% @see pgfmathfloatroundzerofill
%
% SIDE EFFECT: the global variable \ifpgfmathfloatroundhasperiod will be set to
% whether the final mantisse #5 has a period or not.
\def\pgfmathfloatround#1{%
	\pgfmathfloatroundhasperiodtrue
	\begingroup
	\pgfmathfloat@fixed@digits@after@periodfalse
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\pgfmathfloatround@impl
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

% Overload.
%
% This method uses a fixed width for the mantisse and fills in zeros
% if necessary.
%
% This method uses \pgfmathroundtozerofill for the mantisse.
%
% SIDE EFFECT: the global variable \ifpgfmathfloatroundhasperiod will be set to
% whether the final mantisse #5 has a period or not.
\def\pgfmathfloatroundzerofill#1{%
	\pgfmathfloatroundhasperiodtrue
	\begingroup
	\pgfmathfloat@fixed@digits@after@periodtrue
	\expandafter\pgfmathfloat@decompose@tok#1\relax\pgfmathfloat@a@S\pgfmathfloat@a@Mtok\pgfmathfloat@a@E
	\pgfmathfloatround@impl
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

\newif\ifpgfmathfloatround@allow@empty@mantisse
\def\pgfmathfloatround@mantisse@ONE{1.0}%

% #1: sign
% #2: mantisse
% #3: exponent
% #4: CODE to display if the mantisse is drawn.
% #5: CODE to display if the mantisse is NOT draw. (unused)
% #6: CODE to display the exponent.
\def\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax#4#5#6{%
	\pgfkeysgetvalue{/pgf/number format/@sci exponent mark}\pgfmathfloatrounddisplaystyle@e@mark
	\ifcase#1\relax
		\pgfmathprintnumber@fixed@style{#2}#1#2e0\relax%
		\expandafter\pgfmathfloatrounddisplaystyle@shared@impl@\expandafter{\pgfmathresult}{#4#6}%
	\or\pgfmathprintnumber@fixed@style{#2}#1#2e0\relax%
		\expandafter\pgfmathfloatrounddisplaystyle@shared@impl@\expandafter{\pgfmathresult}{#4#6}%
	\or\pgfmathprintnumber@fixed@style{-#2}#1#2e0\relax%
		\expandafter\pgfmathfloatrounddisplaystyle@shared@impl@\expandafter{\pgfmathresult}{#4#6}%
	\or
		\pgfmathfloatrounddisplaystyle@shared@impl@@{NaN}{}%
	\or
		\ifpgfmathprintnumber@showpositive
			\pgfmathfloatrounddisplaystyle@shared@impl@@{+\infty}{}%
		\else
			\pgfmathfloatrounddisplaystyle@shared@impl@@{\infty}{}%
		\fi
	\or
		\pgfmathfloatrounddisplaystyle@shared@impl@@{-\infty}{}%
	\fi
}

% #1: the part before the exponent code
% #2: the part for the exponent code.
\def\pgfmathfloatrounddisplaystyle@shared@impl@#1#2{%
	{\toks0={#1}%
	\toks1=\expandafter{\pgfmathfloatrounddisplaystyle@e@mark #2}%
	\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 }%
	}%
	\let\pgfmathresult=\pgfmathfloat@glob@TMP
}%
% Same as \pgfmathfloatrounddisplaystyle@shared@impl@, but it also
% inserts the '@dec sep mark' at the end.
\def\pgfmathfloatrounddisplaystyle@shared@impl@@#1#2{%
	{\toks0={#1}%
	\toks1=\expandafter{\pgfmathfloatrounddisplaystyle@e@mark #2}%
	\pgfkeysgetvalue{/pgf/number format/@dec sep mark}\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP@MARK
	\toks2=\expandafter{\pgfmathprintnumber@fixed@styleDEFAULT@DEC@SEP@MARK}%
	\xdef\pgfmathfloat@glob@TMP{\the\toks0 \the\toks1 \the\toks2 }%
	}%
	\let\pgfmathresult=\pgfmathfloat@glob@TMP
}

\def\pgfmathfloatrounddisplaystyle@std#1#2e#3\relax{%
	\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax{\cdot}{}{10^{#3}}%
}
\def\pgfmathfloatrounddisplaystyle@subscript#1#2e#3\relax{%
	\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax{}{1}{_{#3}}%
}
\def\pgfmathfloatrounddisplaystyle@superscript#1#2e#3\relax{%
	\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax{}{1}{^{#3}}%
}
\def\pgfmathfloatrounddisplaystyle@e#1#2e#3\relax{%
	\ifnum#3<0\relax
		{\count0=#3\relax
		\multiply\count0 by-1
		\xdef\pgfmathfloat@glob@TMP{e{-}\the\count0}%
		}%
		\let\pgfmathresult=\pgfmathfloat@glob@TMP
	\else
		\def\pgfmathresult{e{+}#3}%
	\fi
	\def\pgfmathfloat@loc@TMPb{\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax{}{1}}%
	\expandafter\pgfmathfloat@loc@TMPb\expandafter{\pgfmathresult}%
}
\def\pgfmathfloatrounddisplaystyle@E#1#2e#3\relax{%
	\ifnum#3<0\relax
		{\count0=#3\relax
		\multiply\count0 by-1
		\xdef\pgfmathfloat@glob@TMP{E{-}\the\count0}%
		}%
		\let\pgfmathresult=\pgfmathfloat@glob@TMP
	\else
		\def\pgfmathresult{E{+}#3}%
	\fi
	\def\pgfmathfloat@loc@TMPb{\pgfmathfloatrounddisplaystyle@shared@impl#1#2e#3\relax{}{1}}%
	\expandafter\pgfmathfloat@loc@TMPb\expandafter{\pgfmathresult}%
}

% A macro which takes three arguments, sign, mantisse and exponent and
% expands to the final TeX-representation for that floating point
% number.
%
% PRECONDITION:
%   the floating point number has already been rounded properly and
%   the mantisse has been rounded correcty.
%
% #1: SIGN
% #2: MANTISSE
% #3: EXPONENT
\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@std
\newif\ifpgfmathfloat@usezerofill@sci
\newif\ifpgfmathfloat@usezerofill@fixed
\newif\ifpgfmathprintnumber@assumemathmode
\newif\ifpgfmathprintnumber@showpositive

\pgfkeys{%
	/pgf/number format/.is family,
	/pgf/number format,
	fixed/.code=			\pgfmath@set@number@printer{pgfmathprintnumber@FIXED},
	sci/.code=				\pgfmath@set@number@printer{pgfmathprintnumber@SCI},
	std/.code=				\pgfmath@set@number@printer{pgfmathprintnumber@STD},
	int detect/.code=		\pgfmath@set@number@printer{pgfmathprintnumber@INT@DETECT},
	int trunc/.code=		\pgfmath@set@number@printer{pgfmathprintnumber@INT@TRUNC},
	assume math mode/.is if=pgfmathprintnumber@assumemathmode,
	assume math mode/.default=true,
	fixed zerofill/.is if=	pgfmathfloat@usezerofill@fixed,
	fixed zerofill/.default=true,
	sci zerofill/.is if=	pgfmathfloat@usezerofill@sci,
	sci zerofill/.default=true,
	zerofill/.style=		{/pgf/number format/fixed zerofill=#1,/pgf/number format/sci zerofill=#1},
	zerofill/.default=		true,
	precision/.store in=	\pgfmathfloat@round@precision,
	fixed default/.code=		{\let\pgfmathprintnumber@fixed@style=\pgfmathprintnumber@fixed@styleDEFAULT},
	set decimal separator/.initial=,
	dec sep/.style={/pgf/number format/set decimal separator=#1},
	@dec sep mark/.initial=,
	@sci exponent mark/.initial=,
	set thousands separator/.initial=,
	1000 sep/.style={/pgf/number format/set thousands separator=#1},
	min exponent for 1000 sep/.initial=0,
	use period/.style=		{/pgf/number format/set decimal separator={.},/pgf/number format/set thousands separator={{{,}}}},
	use comma/.style=		{/pgf/number format/set decimal separator={{{,}}},/pgf/number format/set thousands separator={.}},
	showpos/.is if=pgfmathprintnumber@showpositive,
	showpos/.default=true,
	print sign/.is if=pgfmathprintnumber@showpositive,
	print sign/.default=true,
	skip 0./.is if=pgfmathprintnumberskipzeroperiod,
	skip 0./.default=true,
	skip 0.= false,
	use period,
	sci 10^e/.code=			{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@std},
	sci 10e/.code=			{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@std},
	sci e/.code=			{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@e},
	sci E/.code=			{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@E},
	sci subscript/.code=	{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@subscript},
	sci superscript/.code=	{\let\pgfmathfloatrounddisplaystyle=\pgfmathfloatrounddisplaystyle@superscript},
%	sci may skip mantisse/.is if=pgfmathfloatround@allow@empty@mantisse,
%	sci may skip mantisse/.default=true,
}



\def\pgfmathprintnumber@STD#1{%
	% parse the input:
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfmathprintnumber@STD@issci\pgfmathresult\relax
}

\def\pgfmathprintnumber@STD@issci#1#2e#3\relax{%
	\expandafter\ifnum#1<3
		\expandafter\ifnum#3>4
			\pgfmathprintnumber@SCI@issci#1#2e#3\relax%
		\else
			\begingroup
			\c@pgf@counta=\pgfmathfloat@round@precision\relax
			\divide\c@pgf@counta by-2\relax
			\ifnum#3<\c@pgf@counta
				\pgfmathprintnumber@SCI@issci#1#2e#3\relax%
			\else
				\pgfmathprintnumber@FIXED@issci#1#2e#3\relax%
			\fi
			\pgfmath@smuggleone\pgfmathresult
			\endgroup
		\fi
	\else% nan or inf:
		\pgfmathfloatrounddisplaystyle#1#2e#3\relax%
	\fi
}


\def\pgfmathprintnumber@INT@TRUNC#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfmathprintnumber@INT@TRUNC@issci\pgfmathresult\relax
}

\def\pgfmathprintnumber@INT@TRUNC@impl#1.#2\relax#3#4e#5\relax{%
	\pgfmathfloatroundhasperiodfalse
	\pgfmathprintnumber@fixed@style{#1}#3#4e#5\relax%
}
\def\pgfmathprintnumber@INT@TRUNC@issci#1#2e#3\relax{%
	\ifnum#1<3\relax
		\pgfmathfloattofixed{#1#2e#3}%
		\expandafter\pgfmathprintnumber@INT@TRUNC@impl\pgfmathresult\relax#1#2e#3\relax
	\else
		\pgfmathfloatrounddisplaystyle#1#2e#3\relax%
	\fi
}


\def\pgfmathprintnumber@INT@DETECT#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfmathprintnumber@INT@DETECT@issci\pgfmathresult\relax
}

\def\pgfmathprintnumber@INT@DETECT@issci#1#2e#3\relax{%
	\begingroup
	\ifnum#1<3\relax
		\pgfmathfloattofixed{#1#2e#3}%
		\def\pgfmathfloat@round@precision{6}%
		\expandafter\pgfmathroundto\expandafter{\pgfmathresult}%
		\ifpgfmathfloatroundhasperiod
			\pgfmathprintnumber@SCI@issci#1#2e#3\relax
		\else
			\expandafter\pgfmathprintnumber@fixed@style\expandafter{\pgfmathresult}#1#2e#3\relax
		\fi
	\else
		\pgfmathfloatrounddisplaystyle#1#2e#3\relax%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

\def\pgfmathprintnumber@FIXED#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfmathprintnumber@FIXED@issci\pgfmathresult\relax
}

\def\pgfmathprintnumber@FIXED@issci#1#2e#3\relax{%
	\begingroup
	\ifnum#1<3
		\pgfmathfloattofixed{#1#2e#3}%
		\ifpgfmathfloat@usezerofill@fixed
			\expandafter\pgfmathroundtozerofill\expandafter{\pgfmathresult}%
		\else
			\expandafter\pgfmathroundto\expandafter{\pgfmathresult}%
		\fi
		\ifpgfmathfloatroundmayneedrenormalize
			\pgfmathfloat@a@E=#3\relax
			\advance\pgfmathfloat@a@E by1
			\edef\pgfmathfloat@loc@TMPb{\noexpand\pgfmathprintnumber@fixed@style{\pgfmathresult}#1#2e\the\pgfmathfloat@a@E}%
			\pgfmathfloat@loc@TMPb\relax%
		\else
			\expandafter\pgfmathprintnumber@fixed@style\expandafter{\pgfmathresult}#1#2e#3\relax%
		\fi
	\else% nan or inf:
		\pgfmathfloatrounddisplaystyle#1#2e#3\relax%
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}


\def\pgfmathprintnumber@SCI#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfmathprintnumber@SCI@issci\pgfmathresult\relax
}

\def\pgfmathprintnumber@SCI@issci#1#2e#3\relax{%
	\ifpgfmathfloat@usezerofill@sci
		\pgfmathfloatroundzerofill{#1#2e#3}%
	\else
		\pgfmathfloatround{#1#2e#3}%
	\fi
	\expandafter\pgfmathfloatrounddisplaystyle\pgfmathresult\relax
}

% Prints argument #1 using the current pretty printer environment (all
% variables in /pgf/number format).
%
% You may specify optional arguments with \pgfmathprintnumber[...].
\def\pgfmathprintnumber{%
	\pgfutil@ifnextchar[%
		{\pgfmathprintnumber@OPT}%
		{\pgfmathprintnumber@noopt}%
}

\def\pgfmathprintnumber@noopt#1{%
	\pgfmathprintnumber@{#1}%
	\ifpgfmathprintnumber@assumemathmode
		\pgfmathresult
	\else
		\pgfutilensuremath{\pgfmathresult}%
	\fi
}%
\def\pgfmathprintnumber@OPT[#1]#2{%
	\begingroup
	\pgfqkeys{/pgf/number format}{#1}%
	\pgfmathprintnumber@{#2}%
	\ifpgfmathprintnumber@assumemathmode
		\pgfmathresult
	\else
		\pgfutilensuremath{\pgfmathresult}%
	\fi
	\endgroup
}%

% As \pgfmathprintnumber, but it produces its output into the second
% argument.
\def\pgfmathprintnumberto{%
	\pgfutil@ifnextchar[%
		{\pgfmathprintnumberto@OPT}%
		{\pgfmathprintnumberto@noopt}%
}

\def\pgfmathprintnumberto@noopt#1#2{%
	\begingroup
	\pgfmathprintnumber@{#1}%
	\ifpgfmathprintnumber@assumemathmode
		\global\let\pgfmathfloat@glob@TMP=\pgfmathresult
	\else
		\toks0=\expandafter{\pgfmathresult}%
		\xdef\pgfmathfloat@glob@TMP{\noexpand\pgfutilensuremath{\the\toks0 }}%
	\fi
	\endgroup
	\let#2=\pgfmathfloat@glob@TMP
}%
\def\pgfmathprintnumberto@OPT[#1]#2#3{%
	\begingroup
	\pgfqkeys{/pgf/number format}{#1}%
	\pgfmathprintnumber@{#2}%
	\ifpgfmathprintnumber@assumemathmode
		\global\let\pgfmathfloat@glob@TMP=\pgfmathresult
	\else
		\toks0=\expandafter{\pgfmathresult}%
		\xdef\pgfmathfloat@glob@TMP{\noexpand\pgfutilensuremath{\the\toks0 }}%
	\fi
	\endgroup
	\let#3=\pgfmathfloat@glob@TMP
}%
	

% Changes the current number pretty printer to #1.
%
% #1 is the macro base name for the pretty print routine, without the
% leading '\'.
\def\pgfmath@set@number@printer#1{%
	\expandafter\let\expandafter\pgfmathprintnumber@\csname #1\endcsname
	\expandafter\let\expandafter\pgfmathprintnumber@issci\csname #1@issci\endcsname
}

\pgfmath@set@number@printer{pgfmathprintnumber@STD}
%\pgfmath@set@number@printer{pgfmathprintnumber@FIXED}
%\pgfmath@set@number@printer{pgfmathprintnumber@FIXED@ZEROFILL}
%\pgfmath@set@number@printer{pgfmathprintnumber@SCI@ZEROFILL}
%\pgfmath@set@number@printer{pgfmathprintnumber@SCI}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% IMPL
%
%%%%%%%%%%%%%%%%%%%%%%%%%%

% equals only itsself when compared with \ifx:
\def\pgfmathfloat@EOI{\pgfmathfloat@EOI}%

% Re-use counters internally.
%
% They are always grouped and only used inside of the rounding
% routines.
\let\c@pgfmathroundto@prec=\pgfmathfloat@b@S% ATTENTION: DOUBLE-USED REGISTERS!
\let\c@pgfmathroundto@offsetbehindperiod=\pgfmathfloat@b@E
\newcount\c@pgfmathroundto@lastzeros

\newif\ifpgfmathround@impl@PREPERIOD@is@negative@zero

% PRECONDITION:
%  	\ifpgfmathfloatroundhasperiod=\iftrue  holds outside of the
%  	current TeX group.
%
% POSTCONDITION:
%   \ifpgfmathfloatroundhasperiod will be set correctly AFTER the
%   current TeX group.
%   \ifpgfmathfloatroundmayneedrenormalize will be set globally
\def\pgfmathroundto@impl#1{%
	\global\pgfmathfloatroundmayneedrenormalizefalse
	\pgfmathfloat@tmptoks={}%
	\let\pgfmathround@next=\pgfutil@empty
	\let\pgfmathround@cur=\pgfutil@empty
	\let\pgfmathresult=\pgfutil@empty
	\edef\pgfmathround@input{#1}%
	\expandafter\c@pgfmathroundto@prec\pgfmathfloat@round@precision\relax
	\c@pgfmathroundto@lastzeros=0
	\c@pgfmathroundto@offsetbehindperiod=-1 % means: no period found so far
	\pgfmathround@impl@PREPERIOD@is@negative@zerotrue
	\expandafter\pgfmathroundto@impl@ITERATE@NODOT@firstcall\pgfmathround@input\pgfmathfloat@EOI
}

% \pgfmathroundto implementation in WORDS:
%
% coarse idea: 
%    1. collect all digits/sign BEFORE the first period in REVERSE order
%    2. then, collect UP TO \prec digits after the period in REVERSE order
% Steps 1. and 2. lead to the digit [sign] sequence
%    "x_{-p} x_{-p+1} ... x_{-2} x_{-1} '.' x_0 ... x_r"
% where 'r' is the total number of digits. The integer 'p' denotes the
% ACTUALLY collected number of digits behind the period.
%
% Let 'k' be the desired precision.
%
% Please note that pgfmathroundto rounds the mantisse, that means |abs(x)|.
%
% There are exactly TWO cases:
% 1. The case with p<=k and x_{-p-1} = end of input.
% 2. The case with p=k and x_{-p-1} is a further, next character.
%
% Then, for case 1.):
% 	discard any unused zeros at the tail of our number (possibly
% 	including the period)
%
% and in case 2.)
%   if NEXT DIGIT < 5:
%       do exactly the same as in case 1.) above and discard any
%       following digits.
%   else
%   	let q := -p
%   	while(x_q = 9 and q<=r )
%   		if q>=0
%   			set x_q = '0'
%   		else
%   			discard digit x_q='9'
%   		fi
%   		++q
%   		if q=0
%   			discard the period 
%   		fi
%   	end while
%   	if q = r+1
%   		insert a '1'
%   	else
%   		set x_q = x_q + 1
%   	fi
%   fi
%
% All these loops have been implemented in spaghetti-code below.
% Sorry, I fear its hard to understand. In principle, everything is
% realised using more or less finite state machines (with some number
% counting logic).
%
% Some comments:
%   - The token register \pgfmathfloat@tmptoks is used to accumulate the REVERSED input number.
%	- \pgfmathfloat@EOI always denotes 'END OF INPUT'.
%	- in the second stage, we need to reverse \pgfmathfloat@tmptoks.
%	  This is -again- done with \pgfmathfloat@tmptoks.

\def\pgfmathroundto@impl@discard@period#1.#2\pgfmathfloat@EOI{%
	\pgfmathfloatroundhasperiodfalse
	\aftergroup\pgfmathfloatroundhasperiodfalse
	\def\pgfmathresult{#1}%
}

\def\pgfmathroundto@impl@gobble@rest@and@start#1\pgfmathfloat@EOI{%
	\pgfmathroundto@impl@start
}
\def\pgfmathroundto@impl@gobble@and@start\pgfmathfloat@EOI{%
	\pgfmathroundto@impl@start
}
\def\pgfmathroundto@impl@gobble\pgfmathfloat@EOI{}%
\def\pgfmathroundto@impl@gobble@rest#1\pgfmathfloat@EOI{}%

% This method will be invoked as soon as the first step, the reverse
% collection of up to PREC digits after the period, has finished.
\def\pgfmathroundto@impl@start{%
	\ifx\pgfmathround@next\pgfutil@empty
		\ifnum\c@pgfmathroundto@offsetbehindperiod<0
			% no period found.
			\ifpgfmathfloat@fixed@digits@after@period
				\ifnum\c@pgfmathroundto@prec=0\relax
					\pgfmathfloatroundhasperiodfalse
					\aftergroup\pgfmathfloatroundhasperiodfalse
					\edef\pgfmathresult{\pgfmathround@input}%
				\else
					\pgfmathfloat@tmptoks=\expandafter{\pgfmathround@input.}%
					\c@pgfmathroundto@offsetbehindperiod=\c@pgfmathroundto@prec
					\pgfmathroundto@impl@append@zeros
					\edef\pgfmathresult{\the\pgfmathfloat@tmptoks}%
				\fi
			\else
				\pgfmathfloatroundhasperiodfalse
				\aftergroup\pgfmathfloatroundhasperiodfalse
				\edef\pgfmathresult{\pgfmathround@input}%
			\fi
		\else
			%\ifnum\c@pgfmathroundto@offsetbehindperiod>\c@pgfmathroundto@prec
			%	\pgfmath@error{Internal logic error in pgfmathroundto at [I] - should not have happened!?}%
			%\fi
			\pgfmathroundto@impl@finish@with@truncation
		\fi
	\else
		%\ifnum\c@pgfmathroundto@offsetbehindperiod=\c@pgfmathroundto@prec
		%\else
		%	\pgfmath@error{Internal logic error in pgfmathroundto at [II] - should not have happened!? I have offsetbehindperiod=\the\c@pgfmathroundto@offsetbehindperiod and prec = \the\c@pgfmathroundto@prec}%
		%\fi
		\expandafter\ifnum\pgfmathround@next<5\relax
			\pgfmathroundto@impl@finish@with@truncation
		\else
			\multiply\c@pgfmathroundto@offsetbehindperiod by-1
			\expandafter\pgfmathroundto@impl@ADD@ONE\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
		\fi
	\fi
}
			
% takes the current input and decides whether trailing zeros shall be
% discarded or more zeros need to be filled in.
\def\pgfmathroundto@impl@finish@with@truncation{%
	\ifpgfmathfloat@fixed@digits@after@period
		\expandafter\pgfmathroundto@impl@REVERSE\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
		\ifnum\c@pgfmathroundto@lastzeros=\c@pgfmathroundto@offsetbehindperiod
			\ifpgfmathround@impl@PREPERIOD@is@negative@zero
				% write '0.0000' instead of '-0.0000':
				\expandafter\pgfmathroundto@impl@discard@minus\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
			\fi
		\fi
		\ifnum\c@pgfmathroundto@prec=0\relax
			\expandafter\pgfmathroundto@impl@discard@period\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
		\else
			\advance\c@pgfmathroundto@prec by-\c@pgfmathroundto@offsetbehindperiod
			\c@pgfmathroundto@offsetbehindperiod=\c@pgfmathroundto@prec
			\pgfmathroundto@impl@append@zeros
			\edef\pgfmathresult{\the\pgfmathfloat@tmptoks}%
		\fi
	\else
		\pgfmathroundto@impl@discard@suffix@zeros
	\fi
}

\def\pgfmathroundto@impl@discard@minus-#1\pgfmathfloat@EOI{\pgfmathfloat@tmptoks={#1}}%

% appends \c@pgfmathroundto@offsetbehindperiod zeros at the end of \pgfmathfloat@tmptoks.
\def\pgfmathroundto@impl@append@zeros{%
	\ifnum\c@pgfmathroundto@offsetbehindperiod>0
		\pgfmathfloat@tmptoks=\expandafter{\the\pgfmathfloat@tmptoks0}%
		\advance\c@pgfmathroundto@offsetbehindperiod by-1
		\pgfmathroundto@impl@append@zeros
	\fi
}

\def\pgfmathroundto@impl@ADD@ONE{%
	\pgfmathfloat@tmptoks={}% no longer needed because its old value will be read from input
	\pgfmathroundto@impl@ADD@ONE@ITERATE
}
\def\pgfmathroundto@impl@ADD@ONE@ITERATE{%
	\pgfutil@ifnextchar\pgfmathfloat@EOI{%
		\global\pgfmathfloatroundmayneedrenormalizetrue
		\edef\pgfmathresult{1\the\pgfmathfloat@tmptoks}%
		\pgfmathroundto@impl@gobble
	}{%
		\pgfutil@ifnextchar.{%
			\ifnum\c@pgfmathroundto@prec=0
				% silently discard period in special case precision=0
				\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ADD@ONE@ITERATE@gobble@dot}%
			\else
				\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ADD@ONE@NEXT@COLLECT}%
			\fi
			\pgfmathround@nextcmd
		}{%
			\pgfutil@ifnextchar+{%
				\global\pgfmathfloatroundmayneedrenormalizetrue
				\edef\pgfmathresult{1\the\pgfmathfloat@tmptoks}%
				\pgfmathroundto@impl@gobble@rest
			}{%
				\pgfutil@ifnextchar-{%
					\global\pgfmathfloatroundmayneedrenormalizetrue
					\edef\pgfmathresult{-1\the\pgfmathfloat@tmptoks}%
					\pgfmathroundto@impl@gobble@rest
				}{%
					\pgfmathroundto@impl@ADD@ONE@NEXT
				}%
			}%
		}%
	}%
}

\def\pgfmathroundto@impl@ADD@ONE@ITERATE@gobble@dot.{%
	\pgfmathfloatroundhasperiodfalse
	\aftergroup\pgfmathfloatroundhasperiodfalse
	\pgfmathroundto@impl@ADD@ONE@ITERATE
}

\def\pgfmathroundto@impl@ADD@ONE@NEXT@COLLECT#1{%
	\pgfmathfloat@tmptoks=\expandafter{\expandafter#1\the\pgfmathfloat@tmptoks}%
	\pgfmathroundto@impl@ADD@ONE@ITERATE
}
\def\pgfmathroundto@impl@ADD@ONE@NEXT#1{%
	\ifnum#1=9
		\ifnum\c@pgfmathroundto@offsetbehindperiod<0
			\ifpgfmathfloat@fixed@digits@after@period
				\pgfmathfloat@tmptoks=\expandafter{\expandafter0\the\pgfmathfloat@tmptoks}%
			\else
				% silently DROP digit
			\fi
		\else
			\pgfmathfloat@tmptoks=\expandafter{\expandafter0\the\pgfmathfloat@tmptoks}%
		\fi
		\advance\c@pgfmathroundto@offsetbehindperiod by1
		\ifnum\c@pgfmathroundto@offsetbehindperiod=0
			\ifpgfmathfloat@fixed@digits@after@period
				\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ADD@ONE@ITERATE}%
			\else
				\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ADD@ONE@ITERATE@gobble@dot}%
			\fi
		\else
			\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ADD@ONE@ITERATE}%
		\fi
	\else
		% re-use this counter:
		\c@pgfmathroundto@lastzeros=#1
		\advance\c@pgfmathroundto@lastzeros by1
		\edef\pgfmathresult{\the\c@pgfmathroundto@lastzeros\the\pgfmathfloat@tmptoks}%
		\pgfmathfloat@tmptoks=\expandafter{\pgfmathresult}%
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@REVERSE@ITERATE}%
	\fi
	\pgfmathround@nextcmd
}


\def\pgfmathroundto@impl@discard@suffix@zeros{%
	\ifnum\c@pgfmathroundto@lastzeros=\c@pgfmathroundto@offsetbehindperiod
		\ifpgfmathround@impl@PREPERIOD@is@negative@zero
			\pgfmathfloatroundhasperiodfalse
			\aftergroup\pgfmathfloatroundhasperiodfalse
			\def\pgfmathresult{0}% write '0' instead of '-0'
		\else
			\expandafter\pgfmathroundto@impl@discard@period\pgfmathround@input\pgfmathfloat@EOI
		\fi
	\else
		\ifnum\c@pgfmathroundto@lastzeros=0
			\expandafter\pgfmathroundto@impl@REVERSE\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
		\else
			\expandafter\pgfmathroundto@impl@discard@suffix@zeros@ITERATE\the\pgfmathfloat@tmptoks\pgfmathfloat@EOI
		\fi
	\fi
}

% PRECONDITION: 
%    \c@pgfmathroundto@lastzeros > 0
\def\pgfmathroundto@impl@discard@suffix@zeros@ITERATE#1{%
	\advance\c@pgfmathroundto@lastzeros by-1
	\ifnum\c@pgfmathroundto@lastzeros=0
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@REVERSE}%
	\else
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@discard@suffix@zeros@ITERATE}%
	\fi
	\pgfmathround@nextcmd
}

% Usage:
% \pgfmathroundto@impl@REVERSE#1\pgfmathfloat@EOI
% -> writes #1 reversed into \pgfmathfloat@tmptoks
\def\pgfmathroundto@impl@REVERSE{%
	\pgfmathfloat@tmptoks={}%
	\pgfmathroundto@impl@REVERSE@ITERATE
}

\def\pgfmathroundto@impl@REVERSE@ITERATE{%
	\pgfutil@ifnextchar\pgfmathfloat@EOI{%
		\edef\pgfmathresult{\the\pgfmathfloat@tmptoks}%
		\pgfmathroundto@impl@gobble
	}{%
		\pgfmathroundto@impl@REVERSE@NEXT
	}%
}

\def\pgfmathroundto@impl@REVERSE@NEXT#1{%
	\pgfmathfloat@tmptoks=\expandafter{\expandafter#1\the\pgfmathfloat@tmptoks}%
	\pgfmathroundto@impl@REVERSE@ITERATE
}

\def\pgfmathroundto@impl@BEGIN@DOT.{%
	\pgfmathfloat@tmptoks=\expandafter{\expandafter.\the\pgfmathfloat@tmptoks}%
	\c@pgfmathroundto@offsetbehindperiod=0
	\pgfmathroundto@impl@ITERATE@DOT
}
\def\pgfmathroundto@impl@ITERATE@DOT{%
	\pgfutil@ifnextchar\pgfmathfloat@EOI{%
		% finished.
		\pgfmathroundto@impl@gobble@and@start
	}{%
		\pgfmathroundto@impl@NEXT@DOT
	}%
}
\def\pgfmathroundto@impl@NEXT@DOT#1{%
	\ifnum\c@pgfmathroundto@offsetbehindperiod=\c@pgfmathroundto@prec
		\def\pgfmathround@next{#1}%
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@gobble@rest@and@start}%
	\else
		\advance\c@pgfmathroundto@offsetbehindperiod by1
		\ifnum#1=0
			\advance\c@pgfmathroundto@lastzeros by1
		\else
			\c@pgfmathroundto@lastzeros=0
		\fi
		\pgfmathfloat@tmptoks=\expandafter{\expandafter#1\the\pgfmathfloat@tmptoks}%
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ITERATE@DOT}%
	\fi
	\pgfmathround@nextcmd
}%

% in contrast to pgfmathroundto@impl@ITERATE@NODOT, this method here
% checks also for signs
\def\pgfmathroundto@impl@ITERATE@NODOT@firstcall#1{%
	\def\pgfmathround@cur{#1}%
	\ifx\pgfmathround@cur\pgfmathfloat@EOI
		\pgfmathround@impl@PREPERIOD@is@negative@zerofalse
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@start}%
	\else
		\ifx\pgfmathround@cur\pgfmathfloatparsenumber@tok@PERIOD
			\pgfmathround@impl@PREPERIOD@is@negative@zerofalse
			\def\pgfmathround@nextcmd{\pgfmathroundto@impl@BEGIN@DOT.}%
		\else
			\ifx\pgfmathround@cur\pgfmathfloatparsenumber@tok@MINUS
			\else
				\pgfmathround@impl@PREPERIOD@is@negative@zerofalse
			\fi
			\pgfmathfloat@tmptoks=\expandafter{\expandafter#1\the\pgfmathfloat@tmptoks}%
			\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ITERATE@NODOT}%
		\fi
	\fi
	\pgfmathround@nextcmd
}

\def\pgfmathroundto@impl@ITERATE@NODOT#1{%
	\def\pgfmathround@cur{#1}%
	\ifx\pgfmathround@cur\pgfmathfloat@EOI
		\def\pgfmathround@nextcmd{\pgfmathroundto@impl@start}%
	\else
		\ifx\pgfmathround@cur\pgfmathfloatparsenumber@tok@PERIOD
			\def\pgfmathround@nextcmd{\pgfmathroundto@impl@BEGIN@DOT.}%
		\else
			\ifx\pgfmathround@cur\pgfmathfloatparsenumber@tok@ZERO
			\else
				\pgfmathround@impl@PREPERIOD@is@negative@zerofalse
			\fi
			\pgfmathfloat@tmptoks=\expandafter{\expandafter#1\the\pgfmathfloat@tmptoks}%
			\def\pgfmathround@nextcmd{\pgfmathroundto@impl@ITERATE@NODOT}%
		\fi
	\fi
	\pgfmathround@nextcmd
}

%--------------------------------------------
% END of pgfmathroundto implementation.
%--------------------------------------------


% flags, mantisse and exponent has already been stored into
% \pgfmathfloat@a@* [using ...@Mtok]
%
% PRECONDITION:
%   \ifpgfmathfloatroundhasperiod = \iftrue outside of the current
%   group
%
% POSTCONDITION:
%   \ifpgfmathfloatroundhasperiod will be set after the current TeX
%   group.
\def\pgfmathfloatround@impl{%
	\expandafter\pgfmathroundto@impl\expandafter{\the\pgfmathfloat@a@Mtok}%
	\ifpgfmathfloatroundmayneedrenormalize
		\ifpgfmathfloatroundhasperiod
			\expandafter\pgfmathfloatround@impl@renormalize\pgfmathresult\pgfmathfloat@EOI%
		\else
			\expandafter\pgfmathfloatround@impl@renormalize\pgfmathresult.\pgfmathfloat@EOI%
		\fi
		\advance\pgfmathfloat@a@E by1
	\fi
	\edef\pgfmathresult{\the\pgfmathfloat@a@S\pgfmathresult e\the\pgfmathfloat@a@E}%
}

\def\pgfmathfloatround@impl@renormalize#1#2.#3\pgfmathfloat@EOI{%
	\pgfmathroundto@impl{#1.#2#3}%
}





% ATTENTION: this thing REQUIRES a period in the mantisse!
% collects everything into \pgfmathresult
\def\pgfmathfloattofixed@impl#1.#2\relax{%
	\ifnum\pgfmathfloat@a@E<0
		\ifcase-\pgfmathfloat@a@E
		\or%e-1
			\pgfmathfloat@a@Mtok={0.}%
		\or%e-2
			\pgfmathfloat@a@Mtok={0.0}%
		\or%e-3
			\pgfmathfloat@a@Mtok={0.00}%
		\or%e-4
			\pgfmathfloat@a@Mtok={0.000}%
		\or%e-5
			\pgfmathfloat@a@Mtok={0.0000}%
		\or%e-6
			\pgfmathfloat@a@Mtok={0.00000}%
		\or%e-7
			\pgfmathfloat@a@Mtok={0.000000}%
		\or%e-8
			\pgfmathfloat@a@Mtok={0.0000000}%
		\or%e-9
			\pgfmathfloat@a@Mtok={0.00000000}%
		\or%e-10
			\pgfmathfloat@a@Mtok={0.000000000}%
		\else%<= -11
			\pgfmathfloat@a@Mtok={0.0000000000}%
			\advance\pgfmathfloat@a@E by10
			\pgfutil@loop
			\ifnum\pgfmathfloat@a@E<-1
				\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok 0}%
				\advance\pgfmathfloat@a@E by1
			\pgfutil@repeat
		\fi
		\def\pgfmathfloat@loc@TMPb{#2}%
		\def\pgfmathfloat@loc@TMPc{0}%
		\ifx\pgfmathfloat@loc@TMPb\pgfmathfloat@loc@TMPc
			\edef\pgfmathresult{\the\pgfmathfloat@a@Mtok #1}%
		\else
			\edef\pgfmathresult{\the\pgfmathfloat@a@Mtok #1#2}%
		\fi
	\else
		%--------------------------------------------------
		% \ifnum\pgfmathfloat@a@E=0%
		% 	\edef\pgfmathresult{#1.#2}%
		% \else
		% 	\pgfmathfloat@a@Mtok={#1}%
		% 	\pgfmathfloattofixed@impl@collectmantisse#2\count\pgfmathfloat@a@E
		% 	\edef\pgfmathresult{\the\pgfmathfloat@a@Mtok}%
		% \fi
		%-------------------------------------------------- 
		\pgfmathfloat@a@Mtok{#1}%
		\pgfmathfloattofixed@impl@pos#2000000000\pgfmathfloat@EOI
		\edef\pgfmathresult{\the\pgfmathfloat@a@Mtok}%
	\fi
}

% FIXME: this implementation here is very fast, but it introduces trailing zeros. Is that acceptable?
\def\pgfmathfloattofixed@impl@pos#1#2#3#4#5#6#7#8#9\pgfmathfloat@EOI{%
	\ifcase\pgfmathfloat@a@E
	% e+0
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok .#1#2#3#4#5#6#7#8#9}%
	\or%e+1
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1.#2#3#4#5#6#7#8#9}%
	\or%e+2
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2.#3#4#5#6#7#8#9}%
	\or%e+3
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3.#4#5#6#7#8#9}%
	\or%e+4
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4.#5#6#7#8#9}%
	\or%e+5
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4#5.#6#7#8#9}%
	\or%e+6
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4#5#6.#7#8#9}%
	\or%e+7
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4#5#6#7.#8#9}%
	\or%e+8
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4#5#6#7#8.#9}%
	\else%>=9
		\pgfmathfloat@a@Mtok\expandafter{\the\pgfmathfloat@a@Mtok #1#2#3#4#5#6#7#8}%
		\advance\pgfmathfloat@a@E by-8
		\pgfmathfloattofixed@impl@collectmantisse#9\count\pgfmathfloat@a@E
	\fi
}%

\def\pgfmathfloattofixed@impl@collectmantisse#1#2\count#3{%
	\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok #1}%
	\advance\pgfmathfloat@a@E by-1%
	\def\pgfmathfloat@loc@TMPb{#2}%
	\ifx\pgfmathfloat@loc@TMPb\pgfutil@empty
		\pgfutil@loop
		\ifnum\pgfmathfloat@a@E>0%
			\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok 0}%
			\advance\pgfmathfloat@a@E by-1%
		\pgfutil@repeat
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok .0}%
	\else
		\ifnum\pgfmathfloat@a@E=0
			\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok .#2}%
		\else
			\pgfmathfloattofixed@impl@collectmantisse#2\count#3%
		\fi
	\fi
}


% ============================================
%
%
% \pgfmathfloatparsenumber implementation
%
%
% ============================================

% accepted parser tokens:
\def\pgfmathfloatparsenumber@tok@ZERO{0}
\def\pgfmathfloatparsenumber@tok@PLUS{+}
\def\pgfmathfloatparsenumber@tok@MINUS{-}
\def\pgfmathfloatparsenumber@tok@PERIOD{.}

\newif\ifpgfmathfloatparsenumberpendingperiod

\def\pgfflt@EOI{p@EOI}%

% Starts a finite-start-machine parser to read a number.
%
% The machine's state is represented by the macro which is currently
% processed; state transitions are realised using \csname...#1\endcsname
% constructions.
%
% It assigns \pgfmathfloat@a@S, \pgfmathfloat@a@Mtok, \pgfmathfloat@a@E.
\def\pgfflt@impl#1{%
	\pgfmathfloatparsenumberpendingperiodfalse
	\pgfmathfloat@tmptoks={}% this register is used to collect PENDING ZEROS
	\pgfmathfloat@a@E=0
	% start parsing: check for sign:
	\expandafter\ifx\csname pgfflt@#1\endcsname\relax
		\pgfmathfloat@a@S=1 % leave this space!
		\expandafter\pgfflt@init\expandafter#1%
	\else
		\expandafter\expandafter\csname pgfflt@#1\endcsname
	\fi
}
% State transitions:
\expandafter\def\csname pgfflt@+\endcsname{%
	\pgfmathfloat@a@S=1 %
	\pgfflt@init}%
\expandafter\def\csname pgfflt@-\endcsname{%
	\pgfmathfloat@a@S=2 %
	\pgfflt@init}%

% FROM: checksign.
%
\def\pgfflt@init#1{%
	\expandafter\ifx\csname pgffltA@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltA@#1\endcsname
	\fi}
% state transitions:
\expandafter\def\csname pgffltA@0\endcsname{\pgfflt@leadingzero}% FIXME: inline optimization!
\expandafter\def\csname pgffltA@1\endcsname{\pgfflt@nonzerodigit1}%
\expandafter\def\csname pgffltA@2\endcsname{\pgfflt@nonzerodigit2}%
\expandafter\def\csname pgffltA@3\endcsname{\pgfflt@nonzerodigit3}%
\expandafter\def\csname pgffltA@4\endcsname{\pgfflt@nonzerodigit4}%
\expandafter\def\csname pgffltA@5\endcsname{\pgfflt@nonzerodigit5}%
\expandafter\def\csname pgffltA@6\endcsname{\pgfflt@nonzerodigit6}%
\expandafter\def\csname pgffltA@7\endcsname{\pgfflt@nonzerodigit7}%
\expandafter\def\csname pgffltA@8\endcsname{\pgfflt@nonzerodigit8}%
\expandafter\def\csname pgffltA@9\endcsname{\pgfflt@nonzerodigit9}%
\def\pgfflt@nonzerodigit#1{%
	\pgfmathfloat@a@Mtok={#1}%
	\pgfmathfloatparsenumberpendingperiodtrue
	\pgfflt@positiveexp}%
\expandafter\def\csname pgffltA@n\endcsname{\pgfflt@readnan}% FIXME: inlining?
\expandafter\def\csname pgffltA@N\endcsname{\pgfflt@readNaN}% FIXME: inlining?
\expandafter\def\csname pgffltA@i\endcsname{\pgfflt@readinf}% FIXME: inlining?
\expandafter\def\csname pgffltA@I\endcsname{\pgfflt@readINF}% FIXME: inlining?


\def\pgfflt@error#1\pgfflt@EOI{%
	\begingroup
	\pgfmathfloat@a@Mtok={#1}%
	\pgfmath@error{Could not read input number '\pgfmathresult', sorry. The unreadable part was near '\the\pgfmathfloat@a@Mtok'.}%
	\endgroup
}%

\def\pgfflt@finish#1\pgfflt@EOI{}

\def\pgfflt@readnan an{%
	\pgfmathfloat@a@S=3\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0%
	\pgfflt@finish
}
\def\pgfflt@readNaN aN{%
	\pgfmathfloat@a@S=3\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0%
	\pgfflt@finish
}
\def\pgfflt@readinf nf{%
	\ifnum\pgfmathfloat@a@S=1
		\pgfmathfloat@a@S=4\relax%
		\pgfmathfloat@a@Mtok={0.0}%
	\else
		\pgfmathfloat@a@S=5\relax%
		\pgfmathfloat@a@Mtok={0.0}%
	\fi
	\pgfmathfloat@a@E=0%
	\pgfflt@finish
}
\def\pgfflt@readINF NF{%
	\ifnum\pgfmathfloat@a@S=1
		\pgfmathfloat@a@S=4\relax%
		\pgfmathfloat@a@Mtok={0.0}%
	\else
		\pgfmathfloat@a@S=5\relax%
		\pgfmathfloat@a@Mtok={0.0}%
	\fi
	\pgfmathfloat@a@E=0%
	\pgfflt@finish
}
\def\pgfflt@leadingzero#1{%
	\expandafter\ifx\csname pgffltB@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltB@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltB@0\endcsname{\pgfflt@leadingzero}%
\expandafter\def\csname pgffltB@1\endcsname{\pgfmathfloat@a@Mtok={1}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@2\endcsname{\pgfmathfloat@a@Mtok={2}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@3\endcsname{\pgfmathfloat@a@Mtok={3}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@4\endcsname{\pgfmathfloat@a@Mtok={4}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@5\endcsname{\pgfmathfloat@a@Mtok={5}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@6\endcsname{\pgfmathfloat@a@Mtok={6}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@7\endcsname{\pgfmathfloat@a@Mtok={7}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@8\endcsname{\pgfmathfloat@a@Mtok={8}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@9\endcsname{\pgfmathfloat@a@Mtok={9}\pgfmathfloatparsenumberpendingperiodtrue \pgfflt@positiveexp}
\expandafter\def\csname pgffltB@.\endcsname{%
	\pgfmathfloat@a@E=-1
	\pgfflt@leadingzero@foundperiod}%
\expandafter\def\csname pgffltB@e\endcsname{%
	\pgfmathfloat@a@S=0\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0%
	\pgfflt@readexponent}%
\let\pgffltB@E=\pgffltB@e
\expandafter\def\csname pgffltB@\pgfflt@EOI\endcsname{%
	\pgfmathfloat@a@S=0\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0}%

\def\pgfflt@leadingzero@foundperiod#1{%
	\expandafter\ifx\csname pgffltC@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltC@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltC@0\endcsname{%
	\advance\pgfmathfloat@a@E by-1
	\pgfflt@leadingzero@foundperiod}%
\expandafter\def\csname pgffltC@1\endcsname{\pgfmathfloat@a@Mtok={1}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@2\endcsname{\pgfmathfloat@a@Mtok={2}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@3\endcsname{\pgfmathfloat@a@Mtok={3}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@4\endcsname{\pgfmathfloat@a@Mtok={4}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@5\endcsname{\pgfmathfloat@a@Mtok={5}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@6\endcsname{\pgfmathfloat@a@Mtok={6}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@7\endcsname{\pgfmathfloat@a@Mtok={7}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@8\endcsname{\pgfmathfloat@a@Mtok={8}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@9\endcsname{\pgfmathfloat@a@Mtok={9}\pgfmathfloatparsenumberpendingperiodtrue\pgfflt@finish@number@after@period}%
\expandafter\def\csname pgffltC@e\endcsname{%
	\pgfmathfloat@a@S=0\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0%
	\pgfflt@readexponent}%
\let\pgffltC@E=\pgffltC@e
\expandafter\def\csname pgffltC@\pgfflt@EOI\endcsname{%
	\pgfmathfloat@a@S=0\relax%
	\pgfmathfloat@a@Mtok={0.0}%
	\pgfmathfloat@a@E=0}%


\def\pgfflt@positiveexp#1{%
	\expandafter\ifx\csname pgffltD@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltD@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltD@0\endcsname{%
	\advance\pgfmathfloat@a@E by1
	\pgfmathfloat@tmptoks=\expandafter{\the\pgfmathfloat@tmptoks0}%
	\pgfflt@pendingzeros@positiveexp}%
\expandafter\def\csname pgffltD@1\endcsname{\pgffltD@nonzerodigit1}%
\expandafter\def\csname pgffltD@2\endcsname{\pgffltD@nonzerodigit2}%
\expandafter\def\csname pgffltD@3\endcsname{\pgffltD@nonzerodigit3}%
\expandafter\def\csname pgffltD@4\endcsname{\pgffltD@nonzerodigit4}%
\expandafter\def\csname pgffltD@5\endcsname{\pgffltD@nonzerodigit5}%
\expandafter\def\csname pgffltD@6\endcsname{\pgffltD@nonzerodigit6}%
\expandafter\def\csname pgffltD@7\endcsname{\pgffltD@nonzerodigit7}%
\expandafter\def\csname pgffltD@8\endcsname{\pgffltD@nonzerodigit8}%
\expandafter\def\csname pgffltD@9\endcsname{\pgffltD@nonzerodigit9}%
\expandafter\def\csname pgffltD@.\endcsname{\pgfflt@finish@number@after@period}% FIXME : inlining?
\expandafter\def\csname pgffltD@e\endcsname{\pgfflt@readexponent}% FIXME : inlining?
\let\pgffltD@E=\pgffltD@e
\expandafter\def\csname pgffltD@\pgfflt@EOI\endcsname{}% NOP
\def\pgffltD@nonzerodigit#1{%
	\advance\pgfmathfloat@a@E by1
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.}%
		\pgfmathfloatparsenumberpendingperiodfalse
	\fi
	\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok#1}%
	\pgfflt@positiveexp}%

\def\pgfflt@readexponent#1\pgfflt@EOI{%
	\advance\pgfmathfloat@a@E by#1\relax
}

\def\pgfflt@pendingzeros@positiveexp#1{%
	\expandafter\ifx\csname pgffltE@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltE@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltE@0\endcsname{%
	\pgfmathfloat@tmptoks=\expandafter{\the\pgfmathfloat@tmptoks0}%
	\advance\pgfmathfloat@a@E by1
	\pgfflt@pendingzeros@positiveexp}%
\expandafter\def\csname pgffltE@1\endcsname{\pgffltE@nonzerodigit1}%
\expandafter\def\csname pgffltE@2\endcsname{\pgffltE@nonzerodigit2}%
\expandafter\def\csname pgffltE@3\endcsname{\pgffltE@nonzerodigit3}%
\expandafter\def\csname pgffltE@4\endcsname{\pgffltE@nonzerodigit4}%
\expandafter\def\csname pgffltE@5\endcsname{\pgffltE@nonzerodigit5}%
\expandafter\def\csname pgffltE@6\endcsname{\pgffltE@nonzerodigit6}%
\expandafter\def\csname pgffltE@7\endcsname{\pgffltE@nonzerodigit7}%
\expandafter\def\csname pgffltE@8\endcsname{\pgffltE@nonzerodigit8}%
\expandafter\def\csname pgffltE@9\endcsname{\pgffltE@nonzerodigit9}%
\expandafter\def\csname pgffltE@.\endcsname{\pgfflt@finish@number@after@period}% FIXME : inlining?
\def\pgffltE@e{\pgfflt@readexponent}% FIXME : inlining?
\let\pgffltE@E=\pgffltE@e
\expandafter\def\csname pgffltE@\pgfflt@EOI\endcsname{}% NOP
\def\pgffltE@nonzerodigit#1{%
	\advance\pgfmathfloat@a@E by1
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.}%
		\pgfmathfloatparsenumberpendingperiodfalse
	\fi
	\pgfmathfloat@a@Mtok=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfmathfloat@a@Mtok\the\pgfmathfloat@tmptoks}%
	\pgfmathfloat@tmptoks={}%
	\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok#1}%
	\pgfflt@positiveexp}%

\def\pgfflt@finish@number@after@period#1{%
	\expandafter\ifx\csname pgffltF@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltF@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltF@0\endcsname{%
	\pgfmathfloat@tmptoks=\expandafter{\the\pgfmathfloat@tmptoks0}%
	\pgfflt@pendingzeros}%
\expandafter\def\csname pgffltF@1\endcsname{\pgffltF@nonzerodigit1}%
\expandafter\def\csname pgffltF@2\endcsname{\pgffltF@nonzerodigit2}%
\expandafter\def\csname pgffltF@3\endcsname{\pgffltF@nonzerodigit3}%
\expandafter\def\csname pgffltF@4\endcsname{\pgffltF@nonzerodigit4}%
\expandafter\def\csname pgffltF@5\endcsname{\pgffltF@nonzerodigit5}%
\expandafter\def\csname pgffltF@6\endcsname{\pgffltF@nonzerodigit6}%
\expandafter\def\csname pgffltF@7\endcsname{\pgffltF@nonzerodigit7}%
\expandafter\def\csname pgffltF@8\endcsname{\pgffltF@nonzerodigit8}%
\expandafter\def\csname pgffltF@9\endcsname{\pgffltF@nonzerodigit9}%
\def\pgffltF@e{\pgfflt@readexponent}%
\let\pgffltF@E=\pgffltF@e
\expandafter\def\csname pgffltF@\pgfflt@EOI\endcsname{}% NOP
\def\pgffltF@nonzerodigit#1{%
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.}%
		\pgfmathfloatparsenumberpendingperiodfalse
	\fi
	\pgfmathfloat@a@Mtok=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfmathfloat@a@Mtok\the\pgfmathfloat@tmptoks}%
	\pgfmathfloat@tmptoks={}%
	\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok#1}%
	\pgfflt@finish@number@after@period}%


\def\pgfflt@pendingzeros#1{%
	\expandafter\ifx\csname pgffltG@#1\endcsname\relax
		\expandafter\pgfflt@error\expandafter#1%
	\else
		\expandafter\expandafter\csname pgffltG@#1\endcsname
	\fi}
% State transitions:
\expandafter\def\csname pgffltG@0\endcsname{%
	\pgfmathfloat@tmptoks=\expandafter{\the\pgfmathfloat@tmptoks0}%
	\pgfflt@pendingzeros}%
\expandafter\def\csname pgffltG@1\endcsname{\pgffltG@nonzerodigit1}%
\expandafter\def\csname pgffltG@2\endcsname{\pgffltG@nonzerodigit2}%
\expandafter\def\csname pgffltG@3\endcsname{\pgffltG@nonzerodigit3}%
\expandafter\def\csname pgffltG@4\endcsname{\pgffltG@nonzerodigit4}%
\expandafter\def\csname pgffltG@5\endcsname{\pgffltG@nonzerodigit5}%
\expandafter\def\csname pgffltG@6\endcsname{\pgffltG@nonzerodigit6}%
\expandafter\def\csname pgffltG@7\endcsname{\pgffltG@nonzerodigit7}%
\expandafter\def\csname pgffltG@8\endcsname{\pgffltG@nonzerodigit8}%
\expandafter\def\csname pgffltG@9\endcsname{\pgffltG@nonzerodigit9}%
\def\pgffltG@e{\pgfflt@readexponent}% FIXME: inlining?
\let\pgffltG@E=\pgffltG@e
\expandafter\def\csname pgffltG@\pgfflt@EOI\endcsname{}% NOP
\def\pgffltG@nonzerodigit#1{%
	\ifpgfmathfloatparsenumberpendingperiod
		\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok.}%
		\pgfmathfloatparsenumberpendingperiodfalse
	\fi
	\pgfmathfloat@a@Mtok=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfmathfloat@a@Mtok\the\pgfmathfloat@tmptoks}%
	\pgfmathfloat@tmptoks={}%
	\pgfmathfloat@a@Mtok=\expandafter{\the\pgfmathfloat@a@Mtok#1}%
	\pgfflt@finish@number@after@period}%

\endinput
