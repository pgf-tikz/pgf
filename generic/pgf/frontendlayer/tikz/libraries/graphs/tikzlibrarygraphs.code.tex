% Copyright 2010 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS[v\pgfversion] $Header$


% 
% Interface keys 
%

\def\tikzgraphsset{\pgfqkeys{/tikz/graphs}}

\tikzgraphsset{
  new ->/.code n args={4}{%
    \path [draw,->,every new ->/.try,#3]
      (#1\tikzgraphleftanchor)
      to #4
      (#2\tikzgraphrightanchor);},
  new --/.code n args={4}{
      \path [draw,-,every new --/.try,#3]
      (#1\tikzgraphleftanchor)
      to #4
      (#2\tikzgraphrightanchor);},
  new <->/.code n args={4}{
    \path [draw,<->,every new <->/.try,#3]
      (#1\tikzgraphleftanchor)
      to #4
      (#2\tikzgraphrightanchor);},
  new -!-/.code n args={4}{},
  new <-/.code n args={4}{%
    \path [draw,<-,every new <-/.try,#3]
      (#1\tikzgraphleftanchor)
      to #4
      (#2\tikzgraphrightanchor);
  }
}


\def\tikz@lib@graph@store@anchor#1#2{%
  \def\tikz@temp{#1}
  \ifx\tikz@temp\pgfutil@empty%
    \let#2\tikz@temp%
  \else%
    \def\tikz@temp{.#1}
    \let#2\tikz@temp%
  \fi%    
}

\tikzgraphsset{
  default edge kind/.initial=--,
  --/.style={default edge kind=--},
  ->/.style={default edge kind=->},
  <-/.style={default edge kind=<-},
  <->/.style={default edge kind=<->},
  -!-/.style={default edge kind=-!-},
  default edge operator/.initial=matching and star,
  left anchor/.code=\tikz@lib@graph@store@anchor{#1}{\tikzgraphleftanchor},
  right anchor/.code=\tikz@lib@graph@store@anchor{#1}{\tikzgraphrightanchor},
  left anchor=,
  right anchor=
}


%
% Keys for using nodes declared outside a graph inside a graph as if
% it were declared there
% 

\tikzgraphsset{
  use existing nodes/.is if=tikz@lib@graph@all
}

\tikzset{
  new set/.code={
    \expandafter\global\expandafter\let\csname tikz@lg@node@set #1\endcsname\pgfutil@empty%
  },
  set/.code={
    \tikz@fig@mustbenamed%
    \expandafter\def\expandafter\tikz@alias\expandafter{\tikz@alias%
      \expandafter\def\expandafter\pgf@temp\expandafter{\csname tikz@lg@node@set #1\endcsname}%
      \expandafter\expandafter\expandafter\pgfutil@g@addto@macro\expandafter\pgf@temp\expandafter{\expandafter\tikz@lg@do\expandafter{\tikz@fig@name}}%
    }%
  },%
}

\newif\iftikz@lib@graph@all


% 
% Simple versus multi graphs 
%
\tikzgraphsset{
  simple/.code={
    \iftikz@lib@graph@simple%
      % is already simple, ignore
    \else
      \tikz@lib@graph@simpletrue%
      \pgfkeysalso{operator=\tikz@lib@graph@simple@done}%
    \fi%
  },
  multi/.code={
    \tikz@lib@graph@simplefalse%
  }
}

\newif\iftikz@lib@graph@simple

\def\tikz@lib@graph@set@simple@edge#1#2#3#4#5{%
  % #1 = kind (<-, ->, ...)
  % #2 = from
  % #3 = to
  % #4 = options
  % #5 = edge nodes
  % 
  % Ok, first, test, whether edge exists:
  \ifcsname tikz@lg@e@#3@#2\endcsname%
    \expandafter\global\expandafter\let\csname tikz@lg@e@#3@#2\endcsname\relax% reset
  \fi%
  \expandafter\gdef\csname tikz@lg@e@#2@#3\endcsname{\tikz@lib@graph@make@simple@edge{#1}{#2}{#3}{#4}{#5}}%
}

\def\tikz@lib@graph@make@simple@edge#1#2#3#4#5{%
  \pgfqkeys{/tikz/graphs}{new #1={#2}{#3}{#4}{#5}}%
}


\def\tikz@lib@graph@simple@done{%
  \tikz@lib@graph@pack@node@list%
  {%
    \let\tikz@lg@do\tikz@lib@graph@simple@node%
    \tikz@lib@graph@node@list
  }%
}

\def\tikz@lib@graph@simple@node#1{%
  {%
    \def\tikz@lib@graph@simple@from@node{#1}%
    \let\tikz@lg@do\tikz@lib@graph@simple@other@node%
    \tikz@lib@graph@node@list%
  }%    
}

\def\tikz@lib@graph@simple@other@node#1{%
  \ifcsname tikz@lg@e@\tikz@lib@graph@simple@from@node @#1\endcsname%
    \csname tikz@lg@e@\tikz@lib@graph@simple@from@node @#1\endcsname%
    \expandafter\global\expandafter\let\csname tikz@lg@e@\tikz@lib@graph@simple@from@node @#1\endcsname\relax%
  \fi%
}


% 
% Basic options 
%

\tikzgraphsset{
  @nodes styling/.style=,
  nodes/.style={/tikz/graphs/@nodes styling/.append style={,#1}},
  @edges styling/.initial=,
  edges/.style={/tikz/graphs/@edges styling/.append={,#1}},
  edge/.style={edges={#1}},
  @edges node/.initial=,
  edge node/.style={/tikz/graphs/@edges node/.append={#1}},
  edge label/.style={/tikz/graphs/@edges node/.append={node[auto]{#1}}},
  edge label'/.style={/tikz/graphs/@edges node/.append={node[auto,swap]{#1}}},
  @operators/.initial=,
  operator/.style={/tikz/graphs/@operators/.append={#1}},
  @extra group options/.style=,
}


\def\tikzgraphinvokeoperator#1{%
  {%
    \pgfkeyslet{/tikz/graphs/@operators}\pgfutil@empty%
    \pgfkeys{/tikz/graphs/.cd,#1}%
    \pgfkeysgetvalue{/tikz/graphs/@operators}\tikz@lib@graph@temp%
    \global\let\tikz@lib@graph@temp\tikz@lib@graph@temp%
  }%
  \tikz@lib@graph@temp%
  \global\let\tikz@lib@graph@temp\relax%
}


% 
% The parser 
%

\def\tikz@lib@graph@parser{%
  \pgfutil@ifnextchar[{\tikz@lib@graph@parser@}{\tikz@lib@graph@parser@[]}%]
}

\long\def\tikz@lib@graph@parser@[#1]#2{%
  \setbox\tikz@figbox=\hbox\bgroup%
    \unhbox\tikz@figbox%
    \hbox\bgroup
      \bgroup%
        \pgfinterruptpath%
          \scope[graphs/.cd,,@operators=,every graph/.try,#1]%
            \pgfkeysgetvalue{/tikz/graphs/@operators}\tikz@lib@graph@outer@operators%
            \let\tikz@lib@graph@options\pgfutil@empty%
            \let\tikz@lib@graph@node@list\pgfutil@empty%
            \pgfkeyssetvalue{/tikz/graphs/placement/depth}{0}%
            \pgfkeyssetvalue{/tikz/graphs/placement/width}{0}%
            \pgfkeyssetvalue{/tikz/graphs/placement/level}{0}%
            \tikz@lib@graph@start@hint@group%
              \tikz@lib@graph@parse@group{#2}%
            \tikz@lib@graph@end@hint@group
            \tikz@lib@graph@outer@operators%  
            \let\tikz@lg@do=\tikz@lib@graph@cleanup%
            \tikz@lib@graph@node@list%
          \endscope%
        \endpgfinterruptpath%
      \egroup
    \egroup%
  \egroup%
  \tikz@lib@graph@parser@done%
}





\def\tikz@lib@graph@start@hint@group{%
  \pgfkeyssetvalue{/tikz/graphs/placement/local depth}{0}%
  \pgfkeyssetvalue{/tikz/graphs/placement/local width}{0}%
  \pgfkeyssetvalue{/tikz/graphs/placement/chain count}{0}%
  \pgfkeyssetvalue{/tikz/graphs/placement/element count}{0}%
}

\def\tikz@lib@graph@end@hint@group{%
  % Get local depth and width outside
  \xdef\tikz@lib@graph@group@depth{\pgfkeysvalueof{/tikz/graphs/placement/local depth}}
  \xdef\tikz@lib@graph@group@width{\pgfkeysvalueof{/tikz/graphs/placement/local width}}
}

\def\tikz@lib@graph@hint@aftergroup{%
  \pgfkeysgetvalue{/tikz/graphs/placement/width}\tikz@temp@h%
  \pgfkeysgetvalue{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeysgetvalue{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  \pgfmathsetmacro\tikz@temp@h{\tikz@lib@graph@group@width+\tikz@temp@h}
  \pgfmathsetmacro\tikz@temp@lh{\tikz@lib@graph@group@width+\tikz@temp@lh}
  \pgfmathsetmacro\tikz@temp@lw{max(\tikz@lib@graph@group@depth,\tikz@temp@lw)}
  \pgfkeyslet{/tikz/graphs/placement/width}\tikz@temp@h%
  \pgfkeyslet{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeyslet{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  % 
  \pgfkeysgetvalue{/tikz/graphs/placement/element count}\tikz@temp%
  \c@pgf@counta=\tikz@temp\relax%
  \advance\c@pgf@counta by1\relax%
  \edef\tikz@temp{\the\c@pgf@counta}%
  \pgfkeyslet{/tikz/graphs/placement/element count}\tikz@temp%  
}

\def\tikz@lib@graph@placement@update{%
  \pgfkeys{/tikz/graphs/placement/logical node depth/.expand once=\tikz@lib@graph@name}
  \let\tikz@lib@graph@node@depth\pgfmathresult
  \pgfkeys{/tikz/graphs/placement/logical node width/.expand once=\tikz@lib@graph@name}
  \let\tikz@lib@graph@node@width\pgfmathresult
  % This is a single node, so update the lengths accordingly
  \pgfkeysgetvalue{/tikz/graphs/placement/width}\tikz@temp@h%
  \pgfkeysgetvalue{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeysgetvalue{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  \pgfmathsetmacro\tikz@temp@h{\tikz@lib@graph@node@width+\tikz@temp@h}
  \pgfmathsetmacro\tikz@temp@lh{\tikz@lib@graph@node@width+\tikz@temp@lh}
  \pgfmathsetmacro\tikz@temp@lw{max(\tikz@lib@graph@node@depth,\tikz@temp@lw)}
  \pgfkeyslet{/tikz/graphs/placement/width}\tikz@temp@h%
  \pgfkeyslet{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeyslet{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  % 
  \pgfkeysgetvalue{/tikz/graphs/placement/element count}\tikz@temp%
  \c@pgf@counta=\tikz@temp\relax%
  \advance\c@pgf@counta by1\relax%
  \edef\tikz@temp{\the\c@pgf@counta}%
  \pgfkeyslet{/tikz/graphs/placement/element count}\tikz@temp%  
}

\def\tikz@lib@graph@placement@after@chain@update{%
  \pgfkeysgetvalue{/tikz/graphs/placement/depth}\tikz@temp@w%
  \pgfkeysgetvalue{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeysgetvalue{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  \pgfmathsetmacro\tikz@temp@w{\tikz@lib@graph@chain@depth+\tikz@temp@w}%
  \pgfmathsetmacro\tikz@temp@lw{\tikz@lib@graph@chain@depth+\tikz@temp@lw}%
  \pgfmathsetmacro\tikz@temp@lh{max(\tikz@lib@graph@chain@width,\tikz@temp@lh)}%
  \pgfkeyslet{/tikz/graphs/placement/depth}\tikz@temp@w%
  \pgfkeyslet{/tikz/graphs/placement/local width}\tikz@temp@lh%
  \pgfkeyslet{/tikz/graphs/placement/local depth}\tikz@temp@lw%
  % 
  \pgfkeysgetvalue{/tikz/graphs/placement/chain count}\tikz@temp%
  \c@pgf@counta=\tikz@temp\relax%
  \advance\c@pgf@counta by1\relax%
  \edef\tikz@temp{\the\c@pgf@counta}%
  \pgfkeyslet{/tikz/graphs/placement/chain count}\tikz@temp%  
}


%
% Parse a group
% 

\long\def\tikz@lib@graph@parse@group#1{
  \let\tikz@lib@graph@group@c\pgfutil@empty%
  \let\tikz@lib@graph@group@cont\pgfutil@empty%
  \let\tikz@lib@graph@group@conta\pgfutil@empty%
  \tikz@lib@graph@group@check#1\par\pgf@stop@eogroup%
}



% 
% Start of a group 
%
\def\tikz@lib@graph@group@check{%
  \pgfutil@ifnextchar[\tikz@lib@graph@group@opt{\tikz@lib@graph@group@opt[]}%]
}

\def\tikz@lib@graph@group@opt[#1]{%
  \let\tikz@lib@graph@parse@extras\pgfutil@empty%
  \tikzgraphsset{
    @operators=,
    every group/.try,
    @extra group options,
    @extra group options/.style=,%
    #1}%
  \expandafter\tikz@lib@graph@par\tikz@lib@graph@parse@extras%
}

\tikzgraphsset{
  parse/.code={\expandafter\def\expandafter\tikz@lib@graph@parse@extras\expandafter{\tikz@lib@graph@parse@extras#1}},
}


% 
% Remove \par 
%

\def\tikz@lib@graph@par{%
  \pgfutil@ifnextchar\bgroup{\tikz@lib@graph@par@@}{\tikz@lib@graph@par@}%
}
\long\def\tikz@lib@graph@par@#1\par{%
  \pgfutil@ifnextchar\pgf@stop@eogroup{%
    \expandafter\tikz@lib@graph@encloser\tikz@lib@graph@group@c#1[}{%
    \expandafter\def\expandafter\tikz@lib@graph@group@c\expandafter{\tikz@lib@graph@group@c#1}%
    \tikz@lib@graph@par%
  }%
}
\long\def\tikz@lib@graph@par@@#1{%
  \expandafter\def\expandafter\tikz@lib@graph@group@c\expandafter{\tikz@lib@graph@group@c{#1}}%
  \tikz@lib@graph@par
}

% 
% Replace ...[...]... by ...[{...}]...
% 
\def\tikz@lib@graph@encloser{%
  \pgfutil@ifnextchar\bgroup{\tikz@lib@graph@encloser@@}{\tikz@lib@graph@encloser@}%
}%
\def\tikz@lib@graph@encloser@#1[{%
  \pgfutil@ifnextchar\pgf@stop@eogroup{%
    \expandafter\tikz@lib@graph@semi\tikz@lib@graph@group@cont#1;%
  }{%
    \expandafter\def\expandafter\tikz@lib@graph@group@cont\expandafter{\tikz@lib@graph@group@cont#1[}%]
    \tikz@lib@graph@encloser@cont%
  }%
}

\def\tikz@lib@graph@encloser@cont#1]#2[{%
  \pgfutil@ifnextchar\pgf@stop@eogroup{%
    \expandafter\tikz@lib@graph@semi\tikz@lib@graph@group@cont{#1}]#2;}{%
    \expandafter\def\expandafter\tikz@lib@graph@group@cont\expandafter{\tikz@lib@graph@group@cont{#1}]#2[}%
    \tikz@lib@graph@encloser@cont}%
}

\def\tikz@lib@graph@encloser@@#1{%
  \expandafter\def\expandafter\tikz@lib@graph@group@cont\expandafter{\tikz@lib@graph@group@cont{#1}}%
  \tikz@lib@graph@encloser%
}


% 
% Replace ; by , 
%

\def\tikz@lib@graph@semi{%
  \pgfutil@ifnextchar\bgroup{\tikz@lib@graph@semi@@}{\tikz@lib@graph@semi@}%
}
\def\tikz@lib@graph@semi@#1;{%
  \pgfutil@ifnextchar\pgf@stop@eogroup{%
    \expandafter\tikz@lib@graph@main@parser\tikz@lib@graph@group@conta#1,}{%
    \expandafter\def\expandafter\tikz@lib@graph@group@conta\expandafter{\tikz@lib@graph@group@conta#1,}%
    \tikz@lib@graph@semi%
  }%
}
\def\tikz@lib@graph@semi@@#1{%
  \expandafter\def\expandafter\tikz@lib@graph@group@conta\expandafter{\tikz@lib@graph@group@conta{#1}}%
  \tikz@lib@graph@semi%
}


% 
% Main parse 
%

\def\tikz@lib@graph@main@parser{%
  \begingroup%
    \pgfkeyssetvalue{/tikz/graphs/placement/local depth}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/local width}{0}%
    \let\tikz@lib@graph@stored@actions\pgfutil@empty%
    \let\tikz@lib@graph@node@list\pgfutil@empty% reset
    \tikz@lib@graph@main@parser@start%
}
\def\tikz@lib@graph@main@parser@start{%
  \pgfutil@ifnextchar\bgroup{\tikz@lib@graph@protect@group}{\tikz@lib@graph@main@parser@cont}%
}

\def\tikz@lib@graph@protect@group#1{% skip space
  \pgfutil@ifnextchar\relax{\tikz@lib@graph@main@parser@cont{{#1}}}{\tikz@lib@graph@main@parser@cont{{#1}}}%
}

\def\tikz@lib@graph@main@parser@cont#1,{%
  \tikz@lib@graph@parse@one#1-\pgf@stop@eodashes%
}

\def\tikz@lib@graph@parse@one{%
  \pgfutil@ifnextchar\bgroup\tikz@lib@graph@scope\tikz@lib@graph@node%
}




% A normal node

\def\tikz@lib@graph@node#1-{%
  % Detect trailing <
  \tikz@lib@graph@@node#1<\pgf@stop%
}

\def\tikz@lib@graph@@node#1<#2\pgf@stop%
{
  % 
  % #1 will be a node (not a group)
  % 
  % Syntax: node name [options]
  % 
  % Grab node name
  \tikz@lib@graph@grab@name#1[\pgf@stop%
  \tikz@lib@graph@stored@actions%
  \pgfutil@ifnextchar\pgf@stop@eodashes{%
    \tikz@lib@graph@graph@done%
  }{%
    % 
    % Now, get arrow kind 
    % 
    \def\pgf@test{#2}% 
    \ifx\pgf@test\pgfutil@empty%
      \expandafter\tikz@lib@graph@no@back@arrow%
    \else%
      \expandafter\tikz@lib@graph@back@arrow%
    \fi%
  }%
}

\def\tikz@lib@graph@no@back@arrow{%
  \pgfutil@ifnextchar>\tikz@lib@graph@forward@arrow{%
    \pgfutil@ifnextchar-\tikz@lib@graph@undirected@arrow{%
      \pgfutil@ifnextchar!\tikz@lib@graph@no@arrow{%
        \PackageError{graphs library}{One of the arrow types <-, --, ->, -!- or <-> expected}{}%
        \tikz@lib@graph@undirected@arrow%
      }%
    }%
  }%
}

\def\tikz@lib@graph@undirected@arrow-{%
  \def\tikz@lib@graph@arrow@type{--}%
  \tikz@lib@graph@after@arrow%
}

\def\tikz@lib@graph@forward@arrow>{%
  \def\tikz@lib@graph@arrow@type{->}%
  \tikz@lib@graph@after@arrow%
}

\def\tikz@lib@graph@bi@arrow>{%
  \def\tikz@lib@graph@arrow@type{<->}%
  \tikz@lib@graph@after@arrow%
}

\def\tikz@lib@graph@no@arrow!-{%
  \def\tikz@lib@graph@arrow@type{-!-}%
  \tikz@lib@graph@after@arrow%
}

\def\tikz@lib@graph@back@arrow{%
  \pgfutil@ifnextchar>{\tikz@lib@graph@bi@arrow}{%
    \def\tikz@lib@graph@arrow@type{<-}%
    \tikz@lib@graph@after@arrow%
  }%
}

\def\tikz@lib@graph@after@arrow{%
  \pgfutil@ifnextchar[{\tikz@lib@graph@after@arrow@opt}{\tikz@lib@graph@after@arrow@opt[]}%]
}

\def\tikz@lib@graph@after@arrow@opt[#1]{%
  % 
  % Ok, first recolor 
  %
  \tikzgraphinvokeoperator{recolor source by=source''}
  \tikzgraphinvokeoperator{recolor target by=target'}
  % Save action for next node
  \expandafter\def\expandafter\tikz@lib@graph@stored@actions\expandafter{%
    \expandafter\tikz@lib@graph@joiner\expandafter{\tikz@lib@graph@arrow@type}{#1}}%
  \tikz@lib@graph@parse@one%
}

\def\tikz@lib@graph@joiner#1#2{%
  \tikzgraphinvokeoperator{recolor source by=source'}
  \tikzgraphinvokeoperator{recolor source'' by=source}
  {%
    \pgfkeyssetvalue{/tikz/graphs/default edge kind}{#1}%
    \pgfkeys{/tikz/graphs/.cd,@operators=,%
      /tikz/graphs/.unknown/.code=\tikz@lib@graph@unknown@edge@option{##1},#2}%
    \pgfkeysgetvalue{/tikz/graphs/@operators}\pgf@temp%
    \ifx\pgf@temp\pgfutil@empty%
      \edef\pgf@temp{\noexpand\pgfkeys{/tikz/graphs/.cd,\pgfkeysvalueof{/tikz/graphs/default edge operator}}}%
      \pgf@temp%
      \pgfkeysgetvalue{/tikz/graphs/@operators}\pgf@temp%
    \fi%
    \pgf@temp%
  }%
  \tikzgraphinvokeoperator{not source',not target'}
}

\def\tikz@lib@graph@unknown@edge@option#1{%
  \def\tikz@temp{/tikz/graphs/@edges styling/.append=}
  \expandafter\expandafter\expandafter\pgfkeys%
  \expandafter\expandafter\expandafter{\expandafter\tikz@temp\expandafter{\expandafter,\pgfkeyscurrentname={#1}}}
}

\def\tikz@lib@graph@graph@done\pgf@stop@eodashes{%
    % Get local depth and width outside
    \xdef\tikz@lib@graph@chain@depth{\pgfkeysvalueof{/tikz/graphs/placement/local depth}}
    \xdef\tikz@lib@graph@chain@width{\pgfkeysvalueof{/tikz/graphs/placement/local width}}
    % Get node list outside...
    \expandafter%  
  \endgroup%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
  \expandafter\expandafter\expandafter{\expandafter\tikz@lib@graph@node@list\tikz@lib@graph@node@list}%
  % Compute new local depth and width of group...
  \tikz@lib@graph@placement@after@chain@update
  % 
  \pgfutil@ifnextchar\pgf@stop@eogroup%
  \tikz@lib@graph@graph@group@done%
  \tikz@lib@graph@main@parser%
}

\def\tikz@lib@graph@graph@group@done\pgf@stop@eogroup{%
  \pgfkeysvalueof{/tikz/graphs/@operators}%
}



%
% Handle node
%
\def\tikz@lib@graph@grab@name{%
  \pgfutil@ifnextchar\foreach\tikz@lib@graph@do@foreach\tikz@lib@graph@grab@name@@%
}

\def\tikz@lib@graph@do@foreach\foreach#1in{%
  \pgfutil@ifnextchar\bgroup{\tikz@lib@graph@do@foreach@normal{#1}}{\def\tikz@temp{#1}\tikz@lib@graph@do@foreach@macro}%
}
\def\tikz@lib@graph@do@foreach@macro#1{%
  \expandafter\expandafter\expandafter\tikz@lib@graph@do@foreach@normal\expandafter\tikz@temp\expandafter{#1}%
}

\def\tikz@lib@graph@do@foreach@normal#1#2#3[\pgf@stop{%
  % Ok, we do a parse on a foreach loop.
  \begingroup
    \let\tikz@lib@graph@node@list@saved\pgfutil@empty%
    \xdef\tikz@lib@graph@saved@placement{%
      {\pgfkeysvalueof{/tikz/graphs/placement/local depth}}%
      {\pgfkeysvalueof{/tikz/graphs/placement/local width}}%
      {\pgfkeysvalueof{/tikz/graphs/placement/chain count}}%
      {\pgfkeysvalueof{/tikz/graphs/placement/element count}}%
      {\pgfkeysvalueof{/tikz/graphs/placement/width}}%
      {\pgfkeysvalueof{/tikz/graphs/placement/depth}}%
    }%
    \foreach #1 in {#2}%
    {%
      \let\tikz@lib@graph@node@list\tikz@lib@graph@node@list@saved%
      \expandafter\tikz@lib@graph@setup@placement\tikz@lib@graph@saved@placement%
      \tikz@lib@graph@parse@group{#3}%
      \xdef\tikz@lib@graph@saved@placement{%
        {\pgfkeysvalueof{/tikz/graphs/placement/local depth}}%
        {\pgfkeysvalueof{/tikz/graphs/placement/local width}}%
        {\pgfkeysvalueof{/tikz/graphs/placement/chain count}}%
        {\pgfkeysvalueof{/tikz/graphs/placement/element count}}%
        {\pgfkeysvalueof{/tikz/graphs/placement/width}}%
        {\pgfkeysvalueof{/tikz/graphs/placement/depth}}%
      }%
      % TODO: Need to also save hints!
      \global\let\tikz@lib@graph@node@list@saved\tikz@lib@graph@node@list%
    }%
    \expandafter%  
  \endgroup%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
  \expandafter\expandafter\expandafter{\expandafter\tikz@lib@graph@node@list\tikz@lib@graph@node@list@saved}%  
  \expandafter\tikz@lib@graph@setup@placement\tikz@lib@graph@saved@placement%
}

\def\tikz@lib@graph@setup@placement#1#2#3#4#5#6{%
  \pgfkeyssetvalue{/tikz/graphs/placement/local depth}{#1}%
  \pgfkeyssetvalue{/tikz/graphs/placement/local width}{#2}%
  \pgfkeyssetvalue{/tikz/graphs/placement/chain count}{#3}%
  \pgfkeyssetvalue{/tikz/graphs/placement/element count}{#4}%
  \pgfkeyssetvalue{/tikz/graphs/placement/width}{#5}%
  \pgfkeyssetvalue{/tikz/graphs/placement/depth}{#6}%
}

\def\tikz@lib@graph@grab@name@@#1[{%
  \tikz@lib@graph@read#1\pgf@stop%
  \let\tikz@lib@graph@as\tikz@lib@graph@as@default%
  \pgfutil@ifnextchar\pgf@stop{%
    \ifx\tikz@lib@graph@name\pgfutil@empty%
    \else
      \expandafter\tikz@lib@graph@noskip%
    \fi%
  }{\tikz@lib@graph@node@opt[}%
}
\def\tikz@lib@graph@noskip{\tikz@lib@graph@node@opt[][}%]

\def\tikz@lib@graph@as@default{%
  \let\tikzgraphnodetext\tikz@lib@graph@node@text%
  \let\tikzgraphnodepath\tikz@lib@graph@path%
  \let\tikzgraphnodefullname\tikz@lib@graph@name%
  \tikz@lib@graph@typesetter%
}

\def\tikz@lib@graph@read#1\pgf@stop{%
  \pgfkeys@spdef\tikz@lib@graph@name@only{#1}%
  \edef\tikz@lib@graph@name{\tikz@lib@graph@path\tikz@lib@graph@name@only}%
}



\newif\iftikz@lib@graph@use@list
\def\tikz@lib@graph@test@use@list{%
  \pgfutil@ifnextchar({\tikz@lib@graph@use@list@grap}{\tikz@lib@graph@test@use@list@done}%)
}

\def\tikz@lib@graph@test@use@list@done#1\pgf@stop{\tikz@lib@graph@use@listfalse}
\def\tikz@lib@graph@use@list@grap(#1)\pgf@stop{\def\tikz@lib@graph@use@list{#1}\tikz@lib@graph@use@listtrue}

\def\tikz@lib@graph@node@opt[#1]#2[\pgf@stop{%
  \expandafter\tikz@lib@graph@test@use@list\tikz@lib@graph@name@only\pgf@stop
  \iftikz@lib@graph@use@list%
    % Ok, make a list of the nodes stored in #1:
    \let\tikz@lg@temp\pgfutil@empty%
    \foreach \tikz@lg@node@name in \tikz@lib@graph@use@list {\expandafter\tikz@lib@graph@handle@use\expandafter{\tikz@lg@node@name}}
    % Ok, now add the nodes to the node list
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
    \expandafter\expandafter\expandafter{%
      \expandafter\tikz@lib@graph@node@list\tikz@lg@temp}%
    % Then color and initialize them:
    \let\tikz@lg@do\tikz@lib@graph@do@use%
    \tikz@lg@temp%
  \else%
    \tikz@lg@test@underscore%
    \expandafter\ifx\csname tikz@lib@graph@def@\tikz@lib@graph@name@only\endcsname\relax%
      \pgfkeysgetvalue{/tikz/graphs/placement/level}\tikz@temp%
      \c@pgf@counta=\tikz@temp\relax%
      \advance\c@pgf@counta by1\relax%
      \edef\tikz@temp{\the\c@pgf@counta}%
      \pgfkeyslet{/tikz/graphs/placement/level}\tikz@temp%  
      \tikzgraphsset{
        level/.try=\pgfkeysvalueof{/tikz/graphs/placement/level},
        level \pgfkeysvalueof{/tikz/graphs/placement/level}/.try
      }
      {%
        \edef\tikz@lib@graph@node@list{\noexpand\tikz@lg@do{\tikz@lib@graph@name}}%
        \global\tikz@lib@graph@node@createdfalse%
        \pgfkeyslet{/tikz/graphs/@operators}\pgfutil@empty%
        \tikz@lg@if@local@node{\tikz@lib@graph@name}%
        {\tikzgraphsset{source,target,#1}\pgfkeysvalueof{/tikz/graphs/@operators}}%
        {%
          \tikz@lg@init@color{\tikz@lib@graph@name}{\tikz@lgc@all@true\tikz@lgc@source@true\tikz@lgc@target@true}%
          \iftikz@lib@graph@all%
            \tikzgraphsset{#1}\pgfkeysvalueof{/tikz/graphs/@operators}%
          \else%
            % 
            \pgfkeys{/tikz/graphs/placement/place}%
            \node [%
              name=\tikz@lib@graph@name,%
              execute at end node={%
                \pgfkeysgetvalue{/tikz/graphs/@operators}\tikz@lib@graph@op@save%
                \global\let\tikz@lib@graph@op@save\tikz@lib@graph@op@save%
              },%
              graphs/.unknown/.code={%
                \let\tikz@key\pgfkeyscurrentname% 
                \pgfkeys{tikz/.cd,\tikz@key={##1},/tikz/graphs/.cd}%
              },%
              /tikz/graphs/.cd,%
              /tikz/graphs/@nodes styling,%
              #1]%
              {%
                \tikz@lib@graph@as%
              };%
            \tikz@lib@graph@op@save\global\let\tikz@lib@graph@op@save\relax%%
            \global\tikz@lib@graph@node@createdtrue%
          \fi
        }%
      }%
      \iftikz@lib@graph@node@created\tikz@lib@graph@placement@update\fi%
      \expandafter\expandafter\expandafter\def%
      \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
      \expandafter\expandafter\expandafter{%
        \expandafter\tikz@lib@graph@node@list\expandafter\tikz@lg@do\expandafter{\tikz@lib@graph@name}}%
    \else
      % The name of the node is a graph name
      \tikz@lib@graph@handle@graph{#1}%      
    \fi
  \fi%  
}

\def\tikz@lg@test@underscore{%
  \expandafter\pgfutil@in@\expandafter{\expandafter_\expandafter_\expandafter}\expandafter{\tikz@lib@graph@name@only}%
  \ifpgfutil@in@%
    \expandafter\tikz@lg@is@underscore\tikz@lib@graph@name@only\pgf@stop%
  \else%
    \let\tikz@lib@graph@node@text\tikz@lib@graph@name@only%
  \fi  
}
\def\tikz@lg@is@underscore#1__#2\pgf@stop{%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\pgfutil@empty%
    \global\advance\tikz@fig@count by1\relax
    \edef\tikz@lib@graph@name@only{tikz@f@\the\tikz@fig@count}%
  \else%
    \def\tikz@lib@graph@name@only{#1}%
  \fi%  
  \edef\tikz@lib@graph@name{\tikz@lib@graph@path\tikz@lib@graph@name@only}%
  \def\tikz@lib@graph@node@text{#2}%
}

\newif\iftikz@lib@graph@node@created

\def\tikz@lib@graph@handle@use#1{%
  % Is #1 the name of a node set?
  \expandafter\let\expandafter\pgf@temp\csname tikz@lg@node@set #1\endcsname
  \ifx\pgf@temp\relax
    \pgfutil@g@addto@macro\tikz@lg@temp{\tikz@lg@do{#1}}    
  \else%
    \expandafter\pgfutil@g@addto@macro\expandafter\tikz@lg@temp\expandafter{\pgf@temp}
  \fi  
}

\def\tikz@lib@graph@do@use#1{%
  \tikz@lg@init@color{#1}{\tikz@lgc@all@true\tikz@lgc@source@true\tikz@lgc@target@true}%
}

\tikzgraphsset{
  typeset/.store in=\tikz@lib@graph@typesetter,
  math nodes/.style={/tikz/graphs/typeset=$\tikzgraphnodetext$},
  empty nodes/.style={/tikz/graphs/typeset=},
  typeset=\tikzgraphnodetext
}


% 
% Handle scope 
%
\def\tikz@lib@graph@scope#1{
  \begingroup
    \let\tikz@lib@graph@node@list\pgfutil@empty%
    \tikz@lib@graph@start@hint@group%
      \tikz@lib@graph@parse@group{#1}%
    \tikz@lib@graph@end@hint@group%
    \expandafter%  
  \endgroup%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
  \expandafter\expandafter\expandafter{\expandafter\tikz@lib@graph@node@list\tikz@lib@graph@node@list}%
  \tikz@lib@graph@hint@aftergroup%
  \tikz@lib@graph@stored@actions%
  \pgfutil@ifnextchar-{\tikz@lib@graph@scope@minus}{%
    \pgfutil@ifnextchar<{\tikz@lib@graph@scope@less}{%
      \PackageError{graphs library}{One of the arrow types <-, --, ->, -!-, or <-> expected}{}%
    }%
  }%
}

\def\tikz@lib@graph@scope@minus-{
  \pgfutil@ifnextchar>\tikz@lib@graph@forward@arrow{%
    \pgfutil@ifnextchar-\tikz@lib@graph@undirected@arrow{%
      \pgfutil@ifnextchar!\tikz@lib@graph@no@arrow{%
        \pgfutil@ifnextchar\pgf@stop@eodashes\tikz@lib@graph@graph@done{%
          \PackageError{graphs library}{One of the arrow types <-, --, ->, -!-, or <-> expected}{}%
          \tikz@lib@graph@undirected@arrow%
        }%
      }%
    }%
  }%
}

\def\tikz@lib@graph@scope@less<-{\tikz@lib@graph@back@arrow}%




% 
% Predefining graphs 
% 

\tikzgraphsset{
  declare/.code 2 args={\expandafter\def\csname tikz@lib@graph@def@#1\endcsname{\tikz@lib@graph@do@graph{#2}}}%
}

\def\tikz@lib@graph@handle@graph#1{%
  \begingroup%
    \let\tikz@lib@graph@node@list\pgfutil@empty%
    \tikzgraphsset{@extra group options/.style={#1}}%
    \tikz@lib@graph@start@hint@group%
      \csname tikz@lib@graph@def@\tikz@lib@graph@name@only\endcsname%
    \tikz@lib@graph@end@hint@group%
    \expandafter%  
  \endgroup%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\tikz@lib@graph@node@list%
  \expandafter\expandafter\expandafter{\expandafter\tikz@lib@graph@node@list\tikz@lib@graph@node@list}% 
  \tikz@lib@graph@hint@aftergroup%
}

\def\tikz@lib@graph@do@graph#1{%
  \tikz@lib@graph@parse@group{#1}%
}

\let\tikz@lib@graph@path\pgfutil@empty

\tikzgraphsset{name/.code={%
    \edef\tikz@lib@graph@path{#1\space\tikz@lib@graph@path}%
  }%
}


%
% Colors
% 
\def\tikz@lg@newif{\csname newif\endcsname}
\tikzgraphsset{
  as/.code=\def\tikz@lib@graph@as{#1},%
  color class/.style={%
    /utils/exec=\expandafter\tikz@lg@newif\csname iftikz@lgc@#1@\endcsname,
    #1/.style={operator={%
      \edef\tikz@lg@col{\expandafter\noexpand\csname tikz@lgc@#1@true\endcsname}%
      \let\tikz@lg@do\tikz@lg@colorize%
      \tikz@lib@graph@node@list%
    }},
    not #1/.style={operator={%
      \edef\tikz@lg@old@col{\expandafter\noexpand\csname tikz@lgc@#1@true\endcsname}%
      \def\tikz@lg@new@col{}%
      \let\tikz@lg@do\tikz@lg@change@color%
      \tikz@lib@graph@node@list%
    }},
    recolor #1 by/.style={operator={%
      \edef\tikz@lg@old@col{\expandafter\noexpand\csname tikz@lgc@#1@true\endcsname}%
      \edef\tikz@lg@new@col{\expandafter\noexpand\csname tikz@lgc@##1@true\endcsname}%
      \let\tikz@lg@do\tikz@lg@change@color%
      \tikz@lib@graph@node@list%
    }},
    !#1/.style=not #1,
  },
  color class=source,
  color class=source',
  color class=source'',
  color class=target,
  color class=target',
  color class=all
}

\def\tikz@lg@init@color#1#2{%
  \expandafter\gdef\csname tikz@lgc@#1\endcsname{#2}%
}

\def\tikz@lib@graph@cleanup#1{%
  \expandafter\global\expandafter\let\csname tikz@lgc@#1\endcsname\relax%
}

\def\tikz@lg@colorize#1{%
  \expandafter\let\expandafter\pgf@temp\csname tikz@lgc@#1\endcsname%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@temp%
  \expandafter\expandafter\expandafter{%
    \expandafter\tikz@lg@col\pgf@temp}%
  \expandafter\global\expandafter\let\csname tikz@lgc@#1\endcsname\pgf@temp%
}

\def\tikz@lg@change@color#1{%
  \def\tikz@lg@temp@save{#1}%
  \let\tikz@lg@collect\pgfutil@empty%
  \expandafter\let\expandafter\pgf@temp\csname tikz@lgc@#1\endcsname%
  \expandafter\tikz@lg@change@check\pgf@temp\pgf@stop%
}
\def\tikz@lg@change@check#1{%
  \ifx#1\pgf@stop%
    \tikz@lg@change@write@back%
  \else%
    \def\pgf@temp{#1}%
    \ifx\pgf@temp\tikz@lg@old@col%
      \expandafter\tikz@lg@change@add\expandafter{\tikz@lg@new@col}% Found!
    \else%
      \tikz@lg@change@add{#1}%
    \fi%
    \expandafter\tikz@lg@change@check
  \fi%
}
\def\tikz@lg@change@add#1{%
  \expandafter\def\expandafter\tikz@lg@collect\expandafter{\tikz@lg@collect#1}%
}

\def\tikz@lg@change@write@back{%
  \expandafter\global\expandafter\let\csname tikz@lgc@\tikz@lg@temp@save\endcsname\tikz@lg@collect%
}



\def\tikz@lg@if@has@color#1#2#3#4{%
  {%
    \csname tikz@lgc@#1\endcsname%
    \expandafter\let\expandafter\pgf@temp\csname iftikz@lgc@#2@\endcsname%
    \ifx\pgf@temp\relax%
      \tikz@lib@reset@temp%
    \fi%
    \pgf@temp%
      \global\tikz@color@testtrue%
    \else%
      \global\tikz@color@testfalse%
    \fi%
  }%
  \iftikz@color@test#3\else#4\fi%
}
\newif\iftikz@color@test

\def\tikz@lg@if@local@node#1#2#3{\expandafter\ifx\csname tikz@lgc@#1\endcsname\relax#3\else#2\fi}

\def\tikz@lib@reset@temp{\let\pgf@temp\iffalse}


% Packing a node list: Replace the node list by a new node list where
% each node is mentioned at most once.

\def\tikz@lib@graph@pack@node@list{%
  {%
    \let\tikz@lg@packed\pgfutil@empty%
    \let\tikz@lg@do\tikz@lg@packer%
    \tikz@lib@graph@node@list%
    \expandafter
  }\expandafter%
  \def\expandafter\tikz@lib@graph@node@list\expandafter{\tikz@lg@packed}%
}

\def\tikz@lg@packer#1{%
  \expandafter\ifx\csname tikz@lg@p@#1\endcsname\pgf@stop%
  \else%
    \expandafter\let\csname tikz@lg@p@#1\endcsname\pgf@stop%
    \expandafter\def\expandafter\tikz@lg@packed\expandafter{\tikz@lg@packed\tikz@lg@do{#1}}
  \fi
}

%
% Color functions
%

% Do something for all nodes having a certain color
%
% #1 = the color name
% #2 = a macro
% 
% Description:
% 
% For each node having color #1, the macro #2 will be called. This
% macro should take a single parameter, which will be set 
% to the node's name.

\def\tikzgraphforeachcolorednode#1#2{%
  \tikz@lib@graph@pack@node@list%
  \expandafter\def\expandafter\iftikz@lib@graph@color@picker\expandafter{\csname iftikz@lgc@#1@\endcsname}%
  \let\tikz@lib@graph@action#2%
  \let\tikz@lg@do\tikz@lg@pick%
  \tikz@lib@graph@node@list%  
}
\def\tikz@lg@pick#1{
  {%
    \csname tikz@lgc@#1\endcsname%
    \iftikz@lib@graph@color@picker
      \global\tikz@color@testtrue%
    \else%
      \global\tikz@color@testfalse%
    \fi%
  }%
  \iftikz@color@test\tikz@lib@graph@action{#1}\fi%
}


% Prepare a color 
%
% #1 is the color name
% #2 is a counter
% #3 is a prefix
% 
% Description:
% 
% You can call this function inside a connector. It will do the
% following: First, its counts how many nodes exist that have color
% #1. This number is stored in the counter passed as #2. Furthermore,
% let <name> be the name of the <i>-th vertex that has color #1. Then, a
% macro called \#3<i> will store <name>. For instance, if #1 is "red"
% and the third red node is called foo and if #3 is "bar", then a
% macro called "\bar3" is set to "foo" as if you had said
% "\expandafter\def\csname bar3\endcsname{foo}".
% 
% The bottom line of all this is that after a preparation you can
% easily iterate over nodes having a certain color. If you wish to
% iterate over a single color, it will be quicker and easier to call
% \tikzgraphforeachcolorednode, but if you need to iterate over two
% colors simultaneously, it will be better to first prepare the color.

\def\tikzgraphpreparecolor#1#2#3{%
  \let\tikz@lib@graph@count#2%
  \tikz@lib@graph@count0\relax
  \def\tikz@lib@graph@prefix{#3}%
  \tikzgraphforeachcolorednode{#1}\tikz@lib@graph@prepare%
}

\def\tikz@lib@graph@prepare#1{%
  \advance\tikz@lib@graph@count by1\relax%
  \expandafter\def\csname\tikz@lib@graph@prefix\the\tikz@lib@graph@count\endcsname{#1}%
}




% 
% The bipartite connector 
%

\tikzgraphsset{
  complete bipartite/.style 2 args={operator={
    \def\tikz@lg@shoreb{#2}%
    \tikzgraphforeachcolorednode{#1}\tikz@lib@graph@bipartite@outer
  }},
  complete bipartite/.default={target'}{source'},
  induced complete bipartite/.style 2 args={
    induced independent set={#1},
    induced independent set={#2},
    complete bipartite={#1}{#2}
  },
  induced complete bipartite/.default={target'}{source'},
}

\def\tikz@lib@graph@bipartite@outer#1{%
  \def\tikz@lib@graph@from{#1}%
  {%
    \tikzgraphforeachcolorednode{\tikz@lg@shoreb}\tikz@lib@graph@bipartite@inner%
  }%
}

\def\tikz@lib@graph@bipartite@inner#1{%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\tikz@lib@graph@from\else%
    \tikz@lib@graph@default@new@edge{\tikz@lib@graph@from}{#1}%
  \fi%
}

\def\tikz@lib@graph@default@new@edge{%
  \pgfkeysgetvalue{/tikz/graphs/@edges styling}\pgf@temp
  \pgfkeysgetvalue{/tikz/graphs/@edges node}\pgf@temp@b
  \expandafter\expandafter\expandafter\tikz@lib@graph@default@new@edge@%
  \expandafter\expandafter\expandafter{\expandafter\pgf@temp\expandafter}\expandafter{\pgf@temp@b}%
}
\def\tikz@lib@graph@default@new@edge@#1#2#3#4{%
  \iftikz@lib@graph@simple%
    \edef\tikz@temp{{\pgfkeysvalueof{/tikz/graphs/default edge kind}}{#3}{#4}}
    \expandafter\tikz@lib@graph@set@simple@edge\tikz@temp{#1}{#2}%
  \else%
    \pgfkeys{/tikz/graphs/.cd,new \pgfkeysvalueof{/tikz/graphs/default edge kind}={#3}{#4}{#1}{#2}}%
  \fi%
}

  
% 
% The clique connector 
%

\tikzgraphsset{
  clique/.style={operator={
      \tikzgraphpreparecolor{#1}\c@pgf@counta{tikz@lg}%
      \tikz@lg@clique@loop%
    }},
  clique/.default=all
}

\def\tikz@lg@clique@loop{%
  \ifnum\c@pgf@counta=0\relax%
  \else
    \c@pgf@countb=\c@pgf@counta\relax%
    \tikz@lg@clique@loop@inner%
    \advance\c@pgf@counta by-1\relax%
    \expandafter\tikz@lg@clique@loop%
  \fi%
}

\def\tikz@lg@clique@loop@inner{%
  \advance\c@pgf@countb by-1\relax%
  \ifnum\c@pgf@countb>0\relax%
    \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@countb\endcsname}{\csname tikz@lg\the\c@pgf@counta\endcsname}%
    \expandafter\tikz@lg@clique@loop@inner%
  \fi%
}


% 
% The independent set connector 
%

\tikzgraphsset{
  induced independent set/.style={operator={
      \pgfkeysgetvalue{/tikz/graphs/default edge kind}\tikz@lg@default%
      \pgfkeyssetvalue{/tikz/graphs/default edge kind}{-!-}%
      \tikzgraphpreparecolor{#1}\c@pgf@counta{tikz@lg}%
      \tikz@lg@indep@loop%
      \pgfkeyslet{/tikz/graphs/default edge kind}\tikz@lg@default%
    }},
  induced independent set/.default=all
}

\def\tikz@lg@indep@loop{%
  \ifnum\c@pgf@counta=0\relax%
  \else
    \c@pgf@countb=\c@pgf@counta\relax%
    \tikz@lg@indep@loop@inner%
    \advance\c@pgf@counta by-1\relax%
    \expandafter\tikz@lg@indep@loop%
  \fi%
}

\def\tikz@lg@indep@loop@inner{%
  \advance\c@pgf@countb by-1\relax%
  \ifnum\c@pgf@countb>0\relax%
    \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@counta\endcsname}{\csname tikz@lg\the\c@pgf@countb\endcsname}%
    \expandafter\tikz@lg@indep@loop@inner%
  \fi%
}


% 
% The path connector 
%

\tikzgraphsset{
  path/.style={operator={%
      \let\tikz@lg@prev\relax%
        \tikzgraphforeachcolorednode{#1}\tikz@lib@graph@path@do%
  }},   
  path/.default=all,
  induced path/.style={induced independent set={#1},path={#1}},
  induced path/.default=all,
}

\def\tikz@lib@graph@path@do#1{%
  \ifx\tikz@lg@prev\relax%
  \else%
    \tikz@lib@graph@default@new@edge{\tikz@lg@prev}{#1}%
  \fi
  \def\tikz@lg@prev{#1}%
}


% 
% The cycle connector 
%

\tikzgraphsset{
  cycle/.style={operator={%
    \let\tikz@lg@prev\relax%
    \let\tikz@lg@first\relax%
    \tikzgraphforeachcolorednode{#1}\tikz@lib@graph@cycle@do%
    \ifx\tikz@lg@first\relax%
    \else%
      \tikz@lib@graph@default@new@edge{\tikz@lg@prev}{\tikz@lg@first}%
    \fi%
  }},
  cycle/.default=all,
  induced cycle/.style={induced independent set={#1},cycle={#1}},
  induced cycle/.default=all,
}

\def\tikz@lib@graph@cycle@do#1{%
  \ifx\tikz@lg@prev\relax%
    \def\tikz@lg@prev{#1}%
    \let\tikz@lg@first\tikz@lg@prev%
  \else%
    \tikz@lib@graph@default@new@edge{\tikz@lg@prev}{#1}%
    \def\tikz@lg@prev{#1}%
  \fi%
}




% 
% The matching and star connector 
%

\tikzgraphsset{
  matching and star/.style 2 args={operator=%
    {%
      \tikzgraphpreparecolor{#1}\c@pgf@counta{tikz@lg}
      \c@pgf@countb=0\relax%
      \let\tikz@lg@prev\relax
      \tikzgraphforeachcolorednode{#2}\tikz@lib@graph@flow@do%
      \tikz@lib@graph@flow@rest%
    }%
  },
  matching and star/.default={target'}{source'}
}

\def\tikz@lib@graph@flow@do#1{%
  \advance\c@pgf@countb by1\relax%
  \ifnum\c@pgf@countb>\c@pgf@counta\relax%
    \c@pgf@countb=\c@pgf@counta\relax%
  \fi%
  \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@countb\endcsname}{#1}%
  \def\tikz@lg@prev{#1}%
}

\def\tikz@lib@graph@flow@rest{%
  \ifnum\c@pgf@countb<\c@pgf@counta\relax%
    \advance\c@pgf@countb by1\relax%
    \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@countb\endcsname}{\tikz@lg@prev}%
    \expandafter\tikz@lib@graph@flow@rest%
  \fi%
}



% 
% The matching connector 
%

\tikzgraphsset{
  matching/.style 2 args={operator=
    {%
      \tikzgraphpreparecolor{#1}\c@pgf@counta{tikz@lg}
      \c@pgf@countb=0\relax%
      \tikzgraphforeachcolorednode{#2}\tikz@lib@graph@matching@do%
    }%
  },
  matching/.default={target'}{source'}
}

\def\tikz@lib@graph@matching@do#1{%
  \advance\c@pgf@countb by1\relax%
  \ifnum\c@pgf@countb>\c@pgf@counta\relax%
  \else%
    \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@countb\endcsname}{#1}%
  \fi%
}





% 
% The butterfly connector 
%

\tikzgraphsset{
  butterfly/.style={operator=
    {}{%
      \pgfkeys{/tikz/graphs/butterfly/.cd,#1}%
      \ifnum\pgfkeysvalueof{/tikz/graphs/butterfly/level}=0\relax%
        \tikzgraphinvokeoperator{matching and star={\pgfkeysvalueof{/tikz/graphs/butterfly/from}}{\pgfkeysvalueof{/tikz/graphs/butterfly/to}}}%
      \else%
        {%
          \tikzgraphpreparecolor{\pgfkeysvalueof{/tikz/graphs/butterfly/from}}\c@pgf@counta{tikz@lg}
          \c@pgf@countb=0\relax%
          \tikzgraphforeachcolorednode{\pgfkeysvalueof{/tikz/graphs/butterfly/to}}\tikz@lib@graph@butterfly@do%
        }%
        \iftikz@butterfly@prime\else\tikzgraphinvokeoperator{matching and star={\pgfkeysvalueof{/tikz/graphs/butterfly/from}}{\pgfkeysvalueof{/tikz/graphs/butterfly/to}}}\fi%
      \fi%
    }%
  },
  butterfly/.default=,
  butterfly/level/.initial=1,
  butterfly/from/.initial=target',
  butterfly/to/.initial=source',
  butterfly'/.style={operator={}{\tikz@butterfly@primetrue\pgfkeysalso{butterfly={#1}}}},
  butterfly'/.default=,
}

\newif\iftikz@butterfly@prime

\def\tikz@lib@graph@butterfly@do#1{%
  \advance\c@pgf@countb by1\relax%
  % Compute other side...
  \c@pgf@countc=\pgfkeysvalueof{/tikz/graphs/butterfly/level}\relax%
  {%
    % Computer countb mod (2level)
    \count0=\c@pgf@countc\relax%
    \multiply\count0 by2\relax%
    \count1=\c@pgf@countb\relax%
    \advance\count1 by-1\relax%
    \count2=\count1\relax%
    \count3=\count1\relax%
    \divide\count1 by\count0\relax%
    \multiply\count1 by\count0\relax%
    \advance\count2 by-\count1\relax%
    % count0 = 2*level
    % count2 = countb mod (2level) (starting with 0)
    % count1 = countb - count2 (starting with 0)
    \ifnum\count2<\c@pgf@countc\relax%
      \advance\count3 by \c@pgf@countc\relax%
    \else%
      \advance\count3 by -\c@pgf@countc\relax%
    \fi%
    \expandafter%
  }%
  \expandafter\c@pgf@countc\the\count3\relax%
  \advance\c@pgf@countc by1\relax%
  \ifnum\c@pgf@countc>\c@pgf@counta\relax%
    \c@pgf@countc=\c@pgf@counta\relax%
  \fi%
  \tikz@lib@graph@default@new@edge{\csname tikz@lg\the\c@pgf@countc\endcsname}{#1}%
}




% 
% The no edges connector 
%
\tikzgraphsset{no edges/.style={operator=\relax}}




% Positioning
%
% It is not the job of the graph library to compute good positions for
% nodes in a graph. However, some basic support is provided for simple
% cases.
% 
% The idea is at follows: Graphs are specified hierarchically. For
% instance, consider the following graph specification:
% 
% graph { a, b, c -> d -> {e -> f -> g, h} -> i, j -> k }
% 
% Here, we have the *group* {e->f->g,h} inside the larger graph
% specification. Each group consists of sequence of *chains* like
% e->f->g or j->k.
% 
% In order to facilitate the automatic positioning of nodes, the graph
% library will provide you with information about the position of
% nodes inside their groups and chains.
% 
% As a chain is being parsed, a counter stored in
% /tikz/graphs/placement/element count is available that is advanced for
% each element in the chain. 
% 
% Additionally, a counter stored in placement/width is
% available. This "logical" width is defined recursively as follows: The
% width of a single node is computed by calling the key
% placement/logical node width, which should return a real or logical
% width of the node passed as a parameter in the macor \pgfmathresult. The
% width of a chain is the sum of the widths of its elements. The
% width of a  group is the maximum of the widths of its elements.
% 
%
% Symmetrically, as a group is being constructed, a counter stored in
% placement/chain count is available that is advanced for each chain
% in the group. The number placement/depth is the defined
% recursively as follows: For a single node, the depth is
% computed by the key placement/logical node depth. The depth
% of a group is the sum of the depths of its elements. The depth of a
% chain is the maximum of the depth of its elements. 
%
% 
% The above keys get updated automatically. You should setup the key
% placement/compute position such that it uses the above keys to
% compute a good position for a new node based on the above
% keys. Typically, this key should execute node={shift=(...)} to setup
% the necessary shift for a new node.
% 
% The key placment/compute position should not be called
% directly. Instead, the key placement/place should be used. This key
% has two effects: First, it calls placement/compute position. Second,
% it resets the length and normal counters. It will setup a completely
% new counting of lengths and counters inside the current scope.
% 
% The placmenet/place key is executed automatically whenever a new
% node is automatically created. Furthermore, placement strategies
% will call this key.

\tikzgraphsset{
  placement/.cd,
  compute position/.code=\tikz@lib@graph@linear@pos,
  place/.code={%
    \pgfkeys{/tikz/graphs/placement/compute position}%
    \aftergroup\tikz@lib@graph@reset@locals%
    \pgfkeyssetvalue{/tikz/graphs/placement/element count}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/chain count}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/depth}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/width}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/local depth}{0}%
    \pgfkeyssetvalue{/tikz/graphs/placement/local width}{0}%
  },
  element count/.initial=0,
  chain count/.initial=0,
  depth/.initial=0,
  width/.initial=0,
  level/.initial=0,
  logical node depth/.code=\def\pgfmathresult{1},
  logical node width/.code=\def\pgfmathresult{1},
}

\def\tikz@lib@graph@reset@locals{%
  \gdef\tikz@lib@graph@group@depth{0}%
  \gdef\tikz@lib@graph@group@width{0}%
}


% Arrange nodes evenly 
% 
% This strategy works as follows: You specify a "chain shift vector"
% and a "group shift vector". Then each new element on a chain is
% shifted by the chain shift vector relative to the previous element
% on the chain. Similarly for each new element of a group. 

\tikzgraphsset{
  Cartesian placement/.style={
    placement/place,
    placement/compute position/.code=\tikz@lib@graph@linear@pos%
  },
  chain shift/.initial={(1,0)},
  group shift/.initial={(0,-1)},
  grow right/.style={
    Cartesian placement,
    chain shift={(#1,0)},
    @auto anchor horizontal=center,
    placement/logical node width/.code=\def\pgfmathresult{1}
  },
  grow right/.default=1,
  grow left/.style={
    Cartesian placement,
    chain shift={(-#1,0)},
    @auto anchor horizontal=center,
    placement/logical node width/.code=\def\pgfmathresult{1}
  },
  grow left/.default=1,
  grow up/.style={
    Cartesian placement,
    chain shift={(0,#1)},
    @auto anchor horizontal=center,
    placement/logical node width/.code=\def\pgfmathresult{1}
  },
  grow up/.default=1,
  grow down/.style={
    Cartesian placement,
    chain shift={(0,-#1)},
    @auto anchor vertical=center,
    placement/logical node width/.code=\def\pgfmathresult{1}
  },
  grow down/.default=1,
  branch right/.style={
    Cartesian placement,
    group shift={(#1,0)},
    @auto anchor horizontal=center,
    placement/logical node depth/.code=\def\pgfmathresult{1}
  },
  branch right/.default=1,
  branch left/.style={
    Cartesian placement,
    group shift={(-#1,0)},
    @auto anchor horizontal=center,
    placement/logical node depth/.code=\def\pgfmathresult{1}
  },
  branch left/.default=1,
  branch up/.style={
    Cartesian placement,
    group shift={(0,#1)},
    @auto anchor vertical=center,
    placement/logical node depth/.code=\def\pgfmathresult{1}
  },
  branch up/.default=1,
  branch down/.style={
    Cartesian placement,
    group shift={(0,-#1)},
    @auto anchor vertical=center,
    placement/logical node depth/.code=\def\pgfmathresult{1}
  },
  branch down/.default=1,
  % 
  % Sep shifts 
  % 
  grow right sep/.style={
    Cartesian placement,
    chain shift={(1pt,0)},
    @auto anchor horizontal=west,
    placement/logical node width/.code=\tikz@lib@graph@width@sep{##1}{#1}
  },
  grow right sep/.default=1em,
  grow left sep/.style={
    Cartesian placement,
    chain shift={(-1pt,0)},
    @auto anchor horizontal=east,
    placement/logical node width/.code=\tikz@lib@graph@width@sep{##1}{#1}
  },
  grow left sep/.default=1em,
  grow up sep/.style={
    Cartesian placement,
    chain shift={(0,1pt)},
    @auto anchor vertical=south,
    placement/logical node width/.code=\tikz@lib@graph@depth@sep{##1}{#1}
  },
  grow up sep/.default=1em,
  grow down sep/.style={
    Cartesian placement,
    chain shift={(0,-1pt)},
    @auto anchor vertical=north,
    placement/logical node width/.code=\tikz@lib@graph@depth@sep{##1}{#1}
  },
  grow down sep/.default=1em,
  grow right sep/.style={
    Cartesian placement,
    chain shift={(1pt,0)},
    @auto anchor horizontal=west,
    placement/logical node width/.code=\tikz@lib@graph@width@sep{##1}{#1}
  },
  %
  branch right sep/.style={
    Cartesian placement,
    group shift={(1pt,0)},
    @auto anchor horizontal=west,
    placement/logical node depth/.code=\tikz@lib@graph@width@sep{##1}{#1}
  },
  branch right sep/.default=1em,
  branch left sep/.style={
    Cartesian placement,
    group shift={(-1pt,0)},
    @auto anchor horizontal=east,
    placement/logical node depth/.code=\tikz@lib@graph@width@sep{##1}{#1}
  },
  branch left sep/.default=1em,
  branch up sep/.style={
    Cartesian placement,
    group shift={(0,1pt)},
    @auto anchor vertical=south,
    placement/logical node depth/.code=\tikz@lib@graph@depth@sep{##1}{#1}
  },
  branch up sep/.default=1em,
  branch down sep/.style={
    Cartesian placement,
    group shift={(0,-1pt)},
    @auto anchor vertical=north,
    placement/logical node depth/.code=\tikz@lib@graph@depth@sep{##1}{#1}
  },
  branch down sep/.default=1em,
  %
  @auto anchor horizontal/.style={
    nodes={anchor=\csname tikz@lib@graph@auto@\tikz@lib@graph@auto@h @\tikz@lib@graph@auto@v\endcsname},
    /utils/exec=\def\tikz@lib@graph@auto@h{#1}
  },
  @auto anchor vertical/.style={
    nodes={anchor=\csname tikz@lib@graph@auto@\tikz@lib@graph@auto@h @\tikz@lib@graph@auto@v\endcsname},
    /utils/exec=\def\tikz@lib@graph@auto@v{#1}
  },
  % 
  % 
  no placement/.style={
    placement/place,
    placement/compute position/.code=%
  }
}

\def\tikz@lib@graph@auto@h{center}
\def\tikz@lib@graph@auto@v{center}

\def\tikz@lib@graph@auto@center@center{center}
\def\tikz@lib@graph@auto@west@center{west}
\def\tikz@lib@graph@auto@east@center{east}
\def\tikz@lib@graph@auto@center@north{north}
\def\tikz@lib@graph@auto@west@north{north west}
\def\tikz@lib@graph@auto@east@north{north east}
\def\tikz@lib@graph@auto@center@south{south}
\def\tikz@lib@graph@auto@west@south{south west}
\def\tikz@lib@graph@auto@east@south{south east}

\def\tikz@lib@graph@linear@pos{%
  \pgfkeysgetvalue{/tikz/graphs/chain shift}\tikz@temp
  \expandafter\tikz@scan@one@point\expandafter\pgf@process\tikz@temp
  \pgf@process{\pgfpointscale{\pgfkeysvalueof{/tikz/graphs/placement/width}}{}}%
  \pgf@xa=\pgf@x%
  \pgf@ya=\pgf@y%
  \pgfkeysgetvalue{/tikz/graphs/group shift}\tikz@temp
  \expandafter\tikz@scan@one@point\expandafter\pgf@process\tikz@temp
  \pgf@process{\pgfpointscale{\pgfkeysvalueof{/tikz/graphs/placement/depth}}{}}%
  \advance\pgf@xa by\pgf@x%
  \advance\pgf@ya by\pgf@y%
  \edef\tikz@lib@graph@shift{(\the\pgf@xa,\the\pgf@ya)}
  \pgfkeys{/tikz/graphs/nodes/.expanded={shift={\tikz@lib@graph@shift}}}
}


\def\tikz@lib@graph@width@sep#1#2{%
  \pgf@process{\pgfpointdiff{\pgfpointanchor{#1}{west}}{\pgfpointanchor{#1}{east}}}%
  \pgfmathparse{#2+\the\pgf@x}%
}

\def\tikz@lib@graph@depth@sep#1#2{%
  \pgf@process{\pgfpointdiff{\pgfpointanchor{#1}{south}}{\pgfpointanchor{#1}{north}}}%
  \pgfmathparse{#2+\the\pgf@y}%
}


% Circular arrangements 
% 
% This strategy works a bit like the arrange evenly strategy, but in
% polar coordinates. Both for the chains and the groups you specify a
% polar shift, which must be in the form "(delta degree:delta
% distance)". For each element in a chain, the delta degree is added
% to the chain degree, likewise for each element the delta distance is
% added. Similarly for groups.
% 
% There is an initial degree and radius, stored in the key "phase" and
% "radius".

\tikzgraphsset{,
  circular placement/.style={
    placement/place,
    placement/compute position/.code=\tikz@lib@graph@circular@pos,%
    placement/logical node depth/.code=\def\pgfmathresult{1},
    placement/logical node width/.code=\def\pgfmathresult{1},
  },
  clockwise/.style={
    circular placement,
    group polar shift={(-360/#1:0)}
  },
  clockwise/.default=\tikzgraphVnum,
  counterclockwise/.style={
    circular placement,
    group polar shift={(360/#1:0)}
  },
  counterclockwise/.default=\tikzgraphVnum,
  chain polar shift/.initial={(0:1cm)},
  group polar shift/.initial={(60:0)},
  radius/.initial=1cm,
  phase/.initial=90,
}

\def\tikz@lib@graph@circular@pos{%
  \pgfkeysgetvalue{/tikz/graphs/chain polar shift}\tikz@temp
  \expandafter\tikz@lib@graph@decompose@polar\tikz@temp%
  \pgf@process{\pgfpointscale{\pgfkeysvalueof{/tikz/graphs/placement/width}}{}}%
  \pgf@xa=\pgf@x%
  \pgf@ya=\pgf@y%
  \pgfkeysgetvalue{/tikz/graphs/group polar shift}\tikz@temp
  \expandafter\tikz@lib@graph@decompose@polar\tikz@temp%
  \pgf@process{\pgfpointscale{\pgfkeysvalueof{/tikz/graphs/placement/depth}}{}}%
  \advance\pgf@xa by\pgf@x%
  \advance\pgf@ya by\pgf@y%
  \pgfmathparse{\pgfkeysvalueof{/tikz/graphs/radius}}%
  \advance\pgf@ya by\pgfmathresult pt%
  \pgfmathsetmacro\tikz@temp{\the\pgf@xa+\pgfkeysvalueof{/tikz/graphs/phase}}%
  \edef\tikz@lib@graph@shift{(\tikz@temp:\the\pgf@ya)}
  \pgfkeys{/tikz/graphs/nodes/.expanded={shift={\tikz@lib@graph@shift}}}
}


\def\tikz@lib@graph@decompose@polar(#1:#2){%
  \pgfmathsetlength\pgf@x{#1}%
  \pgfmathsetlength\pgf@y{#2}%
}


\tikzgraphsset{
  V/.code={%
    \def\tikzgraphV{#1}
    \c@pgf@counta=0\foreach \tikz@dummy in {#1} {\global\advance\c@pgf@counta by1\relax}
    \edef\tikzgraphVnum{\the\c@pgf@counta}
  },
  V={1},
  n/.style={V={1,...,#1},name shore V/.style={name=V}},
  W/.code={%
    \def\tikzgraphW{#1}
    \c@pgf@counta=0\foreach \tikz@dummy in {#1} {\global\advance\c@pgf@counta by1\relax}
    \edef\tikzgraphWnum{\the\c@pgf@counta}
  },
  W={1},
  m/.style={W={1,...,#1},name shore W/.style={name=W}},
  % Shores:
  name shore V/.style=,
  name shore W/.style=,
}

\endinput
