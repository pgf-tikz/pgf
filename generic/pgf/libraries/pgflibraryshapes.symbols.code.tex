% Copyright 2007 by Till Tantau and Mark Wibrow
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS[v\pgfversion] $Header$

\pgfdeclareshape{forbidden sign}
{
  \inheritsavedanchors[from=circle] % this is nearly a circle
  \inheritanchorborder[from=circle]
  \inheritanchor[from=circle]{north}
  \inheritanchor[from=circle]{north west}
  \inheritanchor[from=circle]{north east}
  \inheritanchor[from=circle]{center}
  \inheritanchor[from=circle]{west}
  \inheritanchor[from=circle]{east}
  \inheritanchor[from=circle]{mid}
  \inheritanchor[from=circle]{mid west}
  \inheritanchor[from=circle]{mid east}
  \inheritanchor[from=circle]{base}
  \inheritanchor[from=circle]{base west}
  \inheritanchor[from=circle]{base east}
  \inheritanchor[from=circle]{south}
  \inheritanchor[from=circle]{south west}
  \inheritanchor[from=circle]{south east}
  \inheritbackgroundpath[from=circle]
  \foregroundpath{
    \centerpoint%
    \pgf@xc=\pgf@x%
    \pgf@yc=\pgf@y%
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%  
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%  
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
    \pgfpathmoveto{\pgfpointadd{\pgfqpoint{\pgf@xc}{\pgf@yc}}{\pgfqpoint{-0.707107\pgfutil@tempdima}{-0.707107\pgfutil@tempdima}}}
    \pgfpathlineto{\pgfpointadd{\pgfqpoint{\pgf@xc}{\pgf@yc}}{\pgfqpoint{0.707107\pgfutil@tempdima}{0.707107\pgfutil@tempdima}}}
  }
}





% Keys for starburst shape
%
% /pgf/starburst point height : The maximum height of the outer points.
% /pgf/starburst points       : The number of points.
% /pgf/random starburst       : The seed for the random number generator.
%
\pgfkeys{/pgf/random starburst/%
	.code={%
		\ifx\pgfkeysnovalue#1%
			\pgfmathgeneratepseudorandomnumber%
		\else%
			\pgfmathtruncatemacro\pgfmathresult{#1}%
		\fi%
		\pgfkeyslet{/pgf/random starburst}{\pgfmathresult}%
	}%
}
\pgfkeys{/pgf/random starburst=100}

\pgfkeys{/pgf/starburst point height/.value required}
\pgfkeys{/pgf/starburst point height/.code={%
		\pgfmathparse{#1}%
		\edef\pgfmathresult{\pgfmathresult pt}%
		\pgfkeyslet{/pgf/starburst point height}{\pgfmathresult}%
	}%
}%
\pgfkeys{/pgf/starburst point height=.5cm}

\pgfkeys{/pgf/starburst points/.value required}
\pgfkeys{/pgf/starburst points/.code={%
		\pgfmathtruncatemacro\pgfmathresult{#1}%
		\pgfkeyslet{/pgf/starburst points}{\pgfmathresult}%
	}%	
}%
\pgfkeys{/pgf/starburst points=17}

\pgfdeclareshape{starburst}{%
	\savedmacro\anglestep{%
		\pgfmathdivide@{180}{\pgfkeysvalueof{/pgf/starburst points}}%
		\let\anglestep\pgfmathresult%
	}
	\savedmacro\calculatestarburstpoints{%
		%
		% Get the angle step.
		%
		\pgfmathdivide@{180}{\pgfkeysvalueof{/pgf/starburst points}}%
		\let\anglestep\pgfmathresult%
		%
		% Get the total number of points.
		%
		\pgfmathsetcounter{pgf@counta}{\pgfkeysvalueof{/pgf/starburst points}}%
		\multiply\c@pgf@counta2\relax%
		\edef\totalpoints{\the\c@pgf@counta}%
		\addtosavedmacro{\totalpoints}%
		%
		% Calculate the centerpoint.
		%
		\pgfsavepgf@process\centerpoint{%
			\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
			\pgfmathsetlength\pgf@y{+.5\ht\pgfnodeparttextbox}%
			\pgfmathaddtolength\pgf@y{-.5\dp\pgfnodeparttextbox}%
		}%
		%
		% Get the larger of the outer sep.
		%
		\pgfmathsetlength\pgf@x{+\pgfkeysvalueof{/pgf/outer xsep}}%
		\pgfmathsetlength\pgf@y{+\pgfkeysvalueof{/pgf/outer ysep}}%
		\ifdim\pgf@x<\pgf@y%
			\pgf@x\pgf@y%
		\fi%
		\edef\outersep{\the\pgf@x}%
		% 
		% Get the node dimensions.
		% 
		\pgfmathsetlength\pgf@x{+\pgfkeysvalueof{/pgf/inner xsep}}%
		\pgfmathaddtolength\pgf@x{+.5\wd\pgfnodeparttextbox}%		
		\pgfmathsetlength\pgf@y{+\pgfkeysvalueof{/pgf/inner ysep}}%
		\pgfmathaddtolength\pgf@y{+.5\ht\pgfnodeparttextbox}%
		\pgfmathaddtolength\pgf@y{+.5\dp\pgfnodeparttextbox}%
		%
		%  Calculate the inner radii.
		%
		\ifpgfshapeborderusesincircle%
			\pgfkeysgetvalue{/pgf/shape border rotate}{\rotate}%
			%
			% Use the incircle...
			%
			\ifdim\pgf@y>\pgf@x%
				\pgf@x\pgf@y%
			\fi%
			\pgf@x1.41421\pgf@x%
			\pgf@y\pgf@x%
		\else%
			%
			% Get the rotation (with rounding).
			%
			\pgfkeysgetvalue{/pgf/shape border rotate}{\rotate}%
			\pgfmathmod@{\rotate}{360}%
			\afterassignment\pgfmath@gobbletilpgfmath@%
			\expandafter\c@pgf@counta\pgfmathresult\relax\pgfmath@%
			\advance\c@pgf@counta45\relax%
			\divide\c@pgf@counta90\relax%
			\multiply\c@pgf@counta90\relax%
			\ifnum\c@pgf@counta<0\relax%
				\advance\c@pgf@counta360\relax%
			\fi%
			%
			% Calculate the width and height of the node
			% contents, according to any border rotation.
			%
			\ifnum\c@pgf@counta=90\relax%
				\pgf@xc\pgf@x%
				\pgf@x\pgf@y%
				\pgf@y\pgf@xc%
			\else%
				\ifnum\c@pgf@counta=270\relax%
					\pgf@xc\pgf@x%
					\pgf@x\pgf@y%
					\pgf@y\pgf@xc%
				\fi%
			\fi%
			\edef\rotate{\the\c@pgf@counta}%
			%
			% ...or not.
			%		
			\pgf@x=1.41421\pgf@x%
			\pgf@y=1.41421\pgf@y%
		\fi%
		\addtosavedmacro{\rotate}%
		% 
		% Adjust innerradius for minimum width and height.
		%
		\pgf@xa\pgf@x% 
		\pgfmathsetlength\pgf@xb{+\pgfkeysvalueof{/pgf/starburst point height}}%
		\advance\pgf@xa\pgf@xb%
		\pgfmathsetlength\pgf@xc{+\pgfkeysvalueof{/pgf/minimum width}}%
		\ifdim\pgf@xa<.5\pgf@xc%
			\pgf@x.5\pgf@xc%
			\advance\pgf@x-\pgf@xb%
		\fi%
		\pgf@ya\pgf@y% 
		\pgfmathsetlength\pgf@yb{+\pgfkeysvalueof{/pgf/starburst point height}}%
		\advance\pgf@ya\pgf@yb%
		\pgfmathsetlength\pgf@yc{+\pgfkeysvalueof{/pgf/minimum height}}%
		\ifdim\pgf@ya<.5\pgf@yc%
			\pgf@y.5\pgf@yc%
			\advance\pgf@y-\pgf@yb%
		\fi%	
		\edef\xinnerradius{\the\pgf@x}%
		\edef\yinnerradius{\the\pgf@y}%
		\addtosavedmacro{\xinnerradius}%
		\addtosavedmacro{\yinnerradius}%
		%
		% Calculate a radius outside the starburst.
		%
		\ifdim\pgf@y>\pgf@x%
			\pgf@x\pgf@y%
		\fi%
		\pgfmathaddtolength\pgf@x{+\pgfkeysvalueof{/pgf/starburst point height}}%
		\edef\externalradius{\the\pgf@x}%
		\addtosavedmacro{\externalradius}%
		%
		% Set the seed for the random number generator.
		%
		\pgfmathsetseed{\pgfkeysvalueof{/pgf/random starburst}}%	
		%
		% Now create the points on the shape and also 
		% the miter length and angle for each point.
		%
		\def\angle{90}% Start at the top.
		%
		% At point a, the miter length and angle are calculated for point b = a - 1.
		%
		\c@pgf@counta1\relax%
		\c@pgf@countb0\relax%
		%
		% As 3 consecutive points are required to be defined for miter
		% calculations, it is necessary to go over the first two points
		% again.
		% 
		\c@pgf@countc\totalpoints\relax%
		\advance\c@pgf@countc2\relax%
		\edef\looppoints{\the\c@pgf@countc}%
		\let\secondpoint\pgfutil@empty%
		\let\thirdpoint\pgfutil@empty%
		\pgfmathloop%
			%
			% Cycle the point definitions.
			%
			\let\firstpoint\secondpoint%	
			\let\secondpoint\thirdpoint%	
			\ifnum\pgfmathcounter>\looppoints%
			\else%
				\ifnum\pgfmathcounter>\totalpoints%
					\expandafter\let\expandafter\thirdpoint\csname point@\the\c@pgf@counta @\endcsname%
				\else%
					\ifodd\pgfmathcounter%
						%
						% An outer point.
						%
						\ifnum\pgfkeysvalueof{/pgf/random starburst}=0\relax%
							\pgf@xa\pgfkeysvalueof{/pgf/starburst point height}\relax%
						\else%
							\pgf@x\pgfkeysvalueof{/pgf/starburst point height}\relax%
							\pgf@xa.75\pgf@x%
							\pgf@xb.25\pgf@x%
							\pgfmathrnd%
							\pgf@xa\pgfmathresult\pgf@xa%
							\advance\pgf@xa\pgf@xb%
						\fi%
						\pgf@x\xinnerradius\relax%
						\advance\pgf@x\pgf@xa%
						\pgf@y\yinnerradius\relax%
						\advance\pgf@y\pgf@xa%
						\expandafter\pgfsavepgf@process\csname point@\the\c@pgf@counta @\endcsname{%
							\pgfpointpolar{\angle}{\the\pgf@x and \the\pgf@y}%
							\pgf@xa\pgf@x%
							\pgf@ya\pgf@y%
							\centerpoint%
							\advance\pgf@x\pgf@xa%
							\advance\pgf@y\pgf@ya%
						}%
					\else%
						%
						% An inner point.
						%
						\expandafter\pgfsavepgf@process\csname point@\the\c@pgf@counta @\endcsname{%
							\pgfpointpolar{\angle}{\xinnerradius and \yinnerradius}%
							\pgf@xa\pgf@x%
							\pgf@ya\pgf@y%
							\centerpoint%
							\advance\pgf@x\pgf@xa%
							\advance\pgf@y\pgf@ya%
						}%						
					\fi%
					%
					% Add the points to the saved macro.
					%
					\expandafter\let\expandafter\thirdpoint\csname point@\the\c@pgf@counta @\endcsname%
					\expandafter\addtosavedmacro\expandafter{\csname point@\the\c@pgf@counta @\endcsname}%
				\fi%				
				%
				% It is only possible to do the miter calculations if three points are defined.
				%
				\ifx\firstpoint\pgfutil@empty%
				\else%
					%
					% Calculate the miter length...
					%
					\pgfmathanglebetweenlines{\secondpoint}{\thirdpoint}{\secondpoint}{\firstpoint}%
					\pgfmathdivide@{\pgfmathresult}{2}%
					\let\defaultmiterangle\pgfmathresult%
					\pgfmathcosec@{\pgfmathresult}%
					\pgf@x\outersep\relax%
					\pgf@x\pgfmathresult\pgf@x%
					\edef\miterlength{\the\pgf@x}%
					%
					% ...the miter angle...
					%
					\pgfmathanglebetweenlines{\firstpoint}{\secondpoint}{\firstpoint}{\thirdpoint}%
					\pgfmathadd@{\pgfmathresult}{\defaultmiterangle}%
					\pgfmathsubtract@{180}{\pgfmathresult}%
					\let\angletemp\pgfmathresult%
					\pgfmathanglebetweenpoints{\firstpoint}{\thirdpoint}%
					\pgfmathsubtract@{180}{\pgfmathresult}%
					\pgfmathsubtract@{\angletemp}{\pgfmathresult}%
					\edef\miterangle{\pgfmathresult}%
					%
					% ...and thus the border point.
					%
					\pgfsavepgf@process\borderpoint{%
						\secondpoint%
						\pgf@xa\pgf@x
						\pgf@ya\pgf@y%
						\pgfpointpolar{\miterangle}{\miterlength}%
						\advance\pgf@x\pgf@xa%
						\advance\pgf@y\pgf@ya%
					}%
					%
					% Get the angle from the centerpoint to the *unrotated* border points.
					%
					\pgfmathanglebetweenpoints{\centerpoint}{\borderpoint}%
					\expandafter\edef\csname angletoborderpoint@\the\c@pgf@countb @\endcsname{\pgfmathresult}%
					\expandafter\addtosavedmacro\expandafter{\csname angletoborderpoint@\the\c@pgf@countb @\endcsname}%
					%
					% Rotatee the border points and save.
					%
					\expandafter\pgfsavepgf@process\csname borderpoint@\the\c@pgf@countb @\endcsname{%
						\pgfmathrotatepointaround{\borderpoint}{\centerpoint}{\rotate}%
					}%
					\expandafter\addtosavedmacro\expandafter{\csname borderpoint@\the\c@pgf@countb @\endcsname}%				
					%
					% Now create the anchors.
					%
					\c@pgf@countc\c@pgf@countb%
					\advance\c@pgf@countc1\relax%
					\divide\c@pgf@countc2\relax%
					\ifodd\c@pgf@countb\relax%
						\pgfutil@ifundefined{pgf@anchor@starburst@outer point\space\the\c@pgf@countc}{%
							\expandafter\xdef\csname pgf@anchor@starburst@outer point\space\the\c@pgf@countc\endcsname{%
								\noexpand\calculatestarburstpoints%
								\noexpand\csname borderpoint@\the\c@pgf@countb @\noexpand\endcsname%
							}%
						}{}%
					\else%
						\pgfutil@ifundefined{pgf@anchor@starburst@inner point\space\the\c@pgf@countc}{%
							\expandafter\xdef\csname pgf@anchor@starburst@inner point\space\the\c@pgf@countc\endcsname{%
								\noexpand\calculatestarburstpoints%
								\noexpand\csname borderpoint@\the\c@pgf@countb @\noexpand\endcsname%
							}%
						}{}%
					\fi%
				\fi%
				\pgfmathadd@{\angle}{\anglestep}%
				\pgfmathmod@{\pgfmathresult}{360}%	
				\let\angle\pgfmathresult%
				\advance\c@pgf@counta1\relax%
				\ifnum\c@pgf@counta>\totalpoints%
					\c@pgf@counta1\relax%
				\fi%
				\advance\c@pgf@countb1\relax%
				\ifnum\c@pgf@countb>\totalpoints%
					\c@pgf@countb1\relax%
				\fi%
		\repeatpgfmathloop%
	}
	\savedanchor\centerpoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgfmathsetlength\pgf@y{+.5\ht\pgfnodeparttextbox}%
		\pgfmathaddtolength\pgf@y{-.5\dp\pgfnodeparttextbox}%
	}%
	\savedanchor\midpoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgfmathsetlength\pgf@y{+.5ex}%
	}%
	\savedanchor\basepoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgf@y0pt\relax%
	}%
	\anchor{center}{\centerpoint}
	\anchor{base}{\basepoint}
	\anchor{mid}{\midpoint}
	\anchor{north}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{0pt}{\externalradius}}%
	}
	\anchor{south}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{0pt}{-\externalradius}}%
	}
	\anchor{east}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{\externalradius}{0pt}}%
	}
	\anchor{west}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{-\externalradius}{0pt}}%
	}
	\anchor{north west}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{-\externalradius}{\externalradius}}%
	}
	\anchor{south west}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{-\externalradius}{-\externalradius}}%
	}
	\anchor{north east}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{\externalradius}{\externalradius}}%
	}
	\anchor{south east}{%
		\calculatestarburstpoints%
		\csname pgf@anchor@starburst@border\endcsname{\pgfqpoint{\externalradius}{-\externalradius}}%
	}
	\backgroundpath{%	
		\calculatestarburstpoints%
		\pgfmathloop%
			\ifnum\pgfmathcounter>\totalpoints%
			\else%
				\ifnum\pgfmathcounter=1\relax%
					\let\starburstaction\pgfpathmoveto%
				\else%
					\let\starburstaction\pgfpathlineto%
				\fi%
				\starburstaction{%
					\pgfmathrotatepointaround{\csname point@\pgfmathcounter @\endcsname}{\centerpoint}{\rotate}}%
			\repeatpgfmathloop%
		\pgfpathclose%		
	}
	\anchorborder{%
		%
		% Save x and y.
		%
		\edef\externalx{\the\pgf@x}%
		\edef\externaly{\the\pgf@y}%
		%
		% Adjust the location of the external 
		% point relative to \centerpoint.
		%
		\centerpoint%
		\pgf@xa\externalx\relax%
		\pgf@ya\externaly\relax%
		\advance\pgf@xa\pgf@x%
		\advance\pgf@ya\pgf@y%
		\edef\externalx{\the\pgf@xa}%
		\edef\externaly{\the\pgf@ya}%
		%
		% Get the starburst points.
		%
		\calculatestarburstpoints%
		%
		% Get the angle of the external point to the \centerpoint.
		%
		\pgfmathanglebetweenpoints{\centerpoint}{\pgfqpoint{\externalx}{\externaly}}%
		\pgfmathsubtract@{\pgfmathresult}{\rotate}%
		\ifdim\pgfmathresult pt<0pt\relax%
			\pgfmathadd@{\pgfmathresult}{360}%
		\fi%
		\let\externalangle\pgfmathresult%
		%
		% Locate the appropriate sides on the starburst border...
		%
		\ifdim\externalangle pt<90pt\relax%
			\c@pgf@counta0\relax%
			\c@pgf@countb\totalpoints\relax%
			\pgfmathloop%
			\ifnum\c@pgf@counta>0\relax%
			\else%
				\ifdim\csname angletoborderpoint@\the\c@pgf@countb @\endcsname pt>90pt\relax%
					\c@pgf@counta\c@pgf@countb%
				\else%
					\ifdim\externalangle pt>\csname angletoborderpoint@\the\c@pgf@countb @\endcsname pt\relax%
						\c@pgf@counta\c@pgf@countb%
					\fi%
				\fi%
				\advance\c@pgf@countb-1\relax%
			\repeatpgfmathloop%
			\edef\first{\the\c@pgf@counta}%
			\advance\c@pgf@counta1\relax%
			\ifnum\c@pgf@counta>\totalpoints\relax%
				\c@pgf@counta1\relax%
			\fi%
			\edef\second{\the\c@pgf@counta}%
		\else%
			\c@pgf@counta0\relax%
			\pgfmathloop%
			\ifnum\c@pgf@counta>0\relax%
			\else%
				\ifdim\csname angletoborderpoint@\pgfmathcounter @\endcsname pt<90pt\relax%
					\c@pgf@counta\pgfmathcounter%
				\else%
					\ifdim\externalangle pt<\csname angletoborderpoint@\pgfmathcounter @\endcsname pt\relax%
						\c@pgf@counta\pgfmathcounter%	
					\fi%
				\fi%					
			\repeatpgfmathloop%
			\edef\first{\the\c@pgf@counta}%
			\advance\c@pgf@counta-1\relax%
			\ifnum\c@pgf@counta=0\relax%
				\c@pgf@counta\totalpoints\relax%
			\fi%
			\edef\second{\the\c@pgf@counta}%
		\fi%
		%
		% ...and thus, the point on the star border.
		%
		\pgfpointintersectionoflines{\centerpoint}{\pgfqpoint{\externalx}{\externaly}}%
				{\csname borderpoint@\first @\endcsname}{\csname borderpoint@\second @\endcsname}%
	}%
}




% Keys for shape cloud.
%
% /pgf/cloud puffs    : the number of cloud puffs.
% /pgf/cloud aspect   : the recommended ratio between width and height.
% /pgf/cloud puff arc : the length of the cloud puff arc.

\pgfkeys{/pgf/cloud puffs/.code={%
	\pgfmathtruncatemacro\pgfmathresult{#1}%
	\pgfkeyslet{/pgf/cloud puffs}{\pgfmathresult}%
	}%
}
\pgfkeys{/pgf/cloud puffs=10}%

\pgfkeys{/pgf/cloud aspect/.value required}%
\pgfkeys{/pgf/cloud aspect/.code={%
	\pgfmathparse{#1}%
	\pgfkeyslet{/pgf/cloud aspect}{\pgfmathresult}%
	}%
}
\pgfkeys{/pgf/cloud aspect=2}%

\pgfkeys{/pgf/cloud puff arc/.value required}%
\pgfkeys{/pgf/cloud puff arc/.code={%
	\pgfmathparse{#1}%
	\pgfkeyslet{/pgf/cloud puff arc}{\pgfmathresult}%
	}%
}
\pgfkeys{/pgf/cloud puff arc=150}%

\newif\ifpgfcloudanchorsuseellipse%
\pgfkeys{/pgf/cloud anchors use ellipse/.is if=pgfcloudanchorsuseellipse}%

% Shape cloud.
%
\pgfdeclareshape{cloud}{%
	\savedmacro\puffs{%
		\pgfkeysgetvalue{/pgf/cloud puffs}{\puffs}%
	}%
	\savedmacro\anglestep{%
		\pgfmathdivide@{360}{\pgfkeysvalueof{/pgf/cloud puffs}}%
		\let\anglestep\pgfmathresult%
	}%
	\savedmacro\arc{%
		\pgfkeysgetvalue{/pgf/cloud puff arc}{\arc}%
	}%
	\savedmacro\getradii{%
		%
		% x radius.
		%
		\pgfmathsetlength\pgf@x{+\pgfkeysvalueof{/pgf/inner xsep}}%
		\pgfmathaddtolength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgf@x1.4142135\pgf@x%
		%
		% y radius.
		%
		\pgfmathsetlength\pgf@y{+\pgfkeysvalueof{/pgf/inner ysep}}%
		\pgfmathaddtolength\pgf@y{+.5\ht\pgfnodeparttextbox}%
		\pgfmathaddtolength\pgf@y{+.5\dp\pgfnodeparttextbox}%
		\pgf@y1.4142135\pgf@y%
		%
		% Apply aspect.
		%
		\pgfkeysgetvalue{/pgf/cloud aspect}{\aspect}%
		\pgfmathreciprocal@{\aspect}%
		\pgf@xa\aspect\pgf@y%
		\pgf@ya\pgfmathresult\pgf@x%
		\ifdim\pgf@xa<\pgf@x%
			\pgf@xa\aspect\pgf@ya%
		\fi%
		\ifdim\pgf@ya<\pgf@y%
			\pgf@ya\pgfmathresult\pgf@xa%
		\fi%
		\edef\xinnerradius{\the\pgf@xa}%
		\edef\yinnerradius{\the\pgf@ya}%
		\edef\xdefaultinnerradius{\the\pgf@xa}%
		\edef\ydefaultinnerradius{\the\pgf@ya}%
		%
		% Get the larger of the outer sep.
		%	
		\pgfmathsetlength\pgf@x{+\pgfkeysvalueof{/pgf/outer xsep}}%
		\pgfmathsetlength\pgf@y{+\pgfkeysvalueof{/pgf/outer ysep}}%
		\ifdim\pgf@x<\pgf@y%
			\pgf@x\pgf@y%
		\fi%
		\edef\outersep{\the\pgf@x}%
		%
		% For a given cloud, with puff arc length a°, the quotient of the
		% distance between the start and end point of a puffs circular arc
		% and the radius of that arc, is constant:
		%
		% g = .5 * sec((180-a)/2)
		% 
		\pgfmathsubtract@{180}{\pgfkeysvalueof{/pgf/cloud puff arc}}%
		\pgfmathdivide@{\pgfmathresult}{2}%
		\let\arcangle\pgfmathresult%
		\pgfmathsec@{\pgfmathresult}%
		\pgfmathdivide@{\pgfmathresult}{2}%
		\let\arcradiusquotient\pgfmathresult%
		\addtosavedmacro{\arcradiusquotient}%
		%
		% In addition, the quotient of the distance between the start and
		% end point of a puffs circular arc and the height of that arc 
		% (ignoring rotation), is also constant:
		%
		% h = .5 * (1-sin((180-a)/2))/cos((180-a)/2)
		%   = g  * (1 - sin((180-a)/2))
		\pgfmathsin@{\arcangle}%
		\pgfmathsubtract@{1}{\pgfmathresult}%
		\pgfmathmultiply@{\pgfmathresult}{\arcradiusquotient}%
		\let\archeightquotient\pgfmathresult%
		\addtosavedmacro{\archeightquotient}%
		%
		% Adjust for minimum height.
		%
		\pgfmathdivide@{180}{\pgfkeysvalueof{/pgf/cloud puffs}}%
		\let\halfanglestep\pgfmathresult%
		\pgfmathsubtract@{90}{\pgfmathresult}%
		\let\startangle\pgfmathresult%
		\pgfsavepgf@process\arcstartpoint{%
			\pgfpointpolar{+\startangle}{+\xdefaultinnerradius and +\ydefaultinnerradius}%		
		}%
		\pgfmathadd@{90}{\halfanglestep}%
		\let\endangle\pgfmathresult%
		\pgfsavepgf@process\arcendpoint{%
			\pgfpointpolar{+\endangle}{+\xdefaultinnerradius and +\ydefaultinnerradius}%		
		}%
		\pgfsavepgf@process\arcbetweenpoint{%
			\pgfpointdiff{\arcendpoint}{\arcstartpoint}%
		}%
		%
		\pgfmathveclen@{\pgfmath@tonumber{\pgf@x}}{\pgfmath@tonumber{\pgf@y}}
		\pgf@ya\pgfmathresult pt\relax%
		\pgf@ya\archeightquotient\pgf@ya%
		\pgfextracty\pgf@yb{%
			\pgfpointadd{\arcstartpoint}{\arcbetweenpoint}%
		}%
		\advance\pgf@ya\pgf@yb%
		\edef\youterradius{\the\pgf@ya}%
		\pgfmathsetlength\pgf@yb{+\pgfkeysvalueof{/pgf/minimum height}}%
		\pgf@yb.5\pgf@yb%
		\pgf@y\yinnerradius\relax%
		\ifdim\pgf@ya<\pgf@yb%
			\pgfmathdivide@{\pgfmath@tonumber{\pgf@y}}{\pgfmath@tonumber{\pgf@ya}}%
			\pgf@ya\pgf@yb%
			\edef\youterradius{\the\pgf@ya}%
			\pgf@y\pgfmathresult\pgf@ya%
			\edef\yinnerradius{\the\pgf@y}%
		\fi%
		%
		% Adjust for minimum width.
		%
		\pgfsavepgf@process\arcstartpoint{%
			\pgfpointpolar{+\halfanglestep}{+\xdefaultinnerradius and +\ydefaultinnerradius}%		
		}%
		\pgfsavepgf@process\arcendpoint{%
			\pgfpointpolar{+-\halfanglestep}{+\xdefaultinnerradius and +\ydefaultinnerradius}%		
		}%
		\pgfsavepgf@process\arcbetweenpoint{%
			\pgfpointdiff{\arcendpoint}{\arcstartpoint}%
		}%
		%
		\pgfmathveclen@{\pgfmath@tonumber{\pgf@x}}{\pgfmath@tonumber{\pgf@y}}
		\pgf@xa\pgfmathresult pt\relax%
		\pgf@xa\archeightquotient\pgf@xa%
		\pgfextractx\pgf@xb{%
			\pgfpointadd{\arcstartpoint}{\arcbetweenpoint}%
		}%
		\advance\pgf@xa\pgf@xb%
		\edef\xouterradius{\the\pgf@xa}%
		\pgfmathsetlength\pgf@xb{+\pgfkeysvalueof{/pgf/minimum width}}%
		\pgf@xb.5\pgf@xb%
		\pgf@x\xinnerradius\relax%
		\ifdim\pgf@xa<\pgf@xb%
			\pgfmathdivide@{\pgfmath@tonumber{\pgf@x}}{\pgfmath@tonumber{\pgf@xa}}%
			\pgf@xa\pgf@xb%
			\edef\xouterradius{\the\pgf@xa}%
			\pgf@x\pgfmathresult\pgf@xa%
			\edef\xinnerradius{\the\pgf@x}%
		\fi%
		%
		\addtosavedmacro{\xinnerradius}%
		\addtosavedmacro{\yinnerradius}%
		%
		\pgf@x\xouterradius\relax%
		\advance\pgf@x\outersep\relax%
		\edef\xouterradius{\the\pgf@x}%
		\addtosavedmacro{\xouterradius}%
		%
		\pgf@y\youterradius\relax%
		\advance\pgf@y\outersep\relax%
		\edef\youterradius{\the\pgf@y}%
		\addtosavedmacro{\youterradius}%
	}
	\saveddimen\outersep{%
		\pgfmathsetlength\pgf@x{+\pgfkeysvalueof{/pgf/outer xsep}}%
		\pgfmathsetlength\pgf@y{+\pgfkeysvalueof{/pgf/outer ysep}}%
		\ifdim\pgf@x<\pgf@y%
			\pgf@x\pgf@y%
		\fi%
	}
	\savedmacro\gettrigconstants{%
		%
		% Get some trig. constants.
		%
		\pgfkeysgetvalue{/pgf/cloud puff arc}{\arc}%
		\pgfmathdivide@{\arc}{4}%
		\let\quarterarc\pgfmathresult%
		\pgfmathsubtract@{180}{\arc}%
		\pgfmathdivide@{\pgfmathresult}{2}%
		\let\halfcomplementarc\pgfmathresult%
		%
		\addtosavedmacro{\arc}%
		\addtosavedmacro{\quarterarc}%
		\addtosavedmacro{\halfcomplementarc}%
		%
		\pgfmathsec@{\halfcomplementarc}% 1/cos((180-a)/2)
		\let\sechalfcomplementarc\pgfmathresult%
		\pgfmathsin@{\halfcomplementarc}% sin((180-a)/2)
		\let\sinhalfcomplementarc\pgfmathresult%
		%
		\addtosavedmacro{\sechalfcomplementarc}%
		\addtosavedmacro{\sinhalfcomplementarc}%
		%
		\pgfmathsin@{\quarterarc}% sin(a/4)
		\let\sinquarterarc\pgfmathresult%
		\pgfmathcos@{\quarterarc}% cos(a/4)
		\let\cosquarterarc\pgfmathresult%
		\pgfmathreciprocal@{\cosquarterarc}%
		\pgfmathmultiply@{\pgfmathresult}{\sinquarterarc}% tan(a/4)
		\let\tanquarterarc\pgfmathresult%
		%
		\addtosavedmacro{\sinquarterarc}%
		\addtosavedmacro{\cosquarterarc}%
		\addtosavedmacro{\tanquarterarc}%
	}
	\savedanchor\centerpoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgfmathsetlength\pgf@y{+.5\ht\pgfnodeparttextbox}%
		\pgfmathaddtolength\pgf@y{+-.5\dp\pgfnodeparttextbox}%
	}
	\savedanchor\midpoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgfmathsetlength\pgf@y{+.5ex}%
	}
	\savedanchor\basepoint{%
		\pgfmathsetlength\pgf@x{+.5\wd\pgfnodeparttextbox}%
		\pgfmathsetlength\pgf@y{+0pt}%
	}
	\anchor{center}{\centerpoint}
	\anchor{mid}{\midpoint}
	\anchor{base}{\basepoint}
	\anchor{north}{%
		\getradii%
		\csname pgf@anchor@cloud@border\endcsname{\pgfqpoint{0pt}{\youterradius}}%
	}%
	\anchor{south}{%
		\getradii%
		\csname pgf@anchor@cloud@border\endcsname{\pgfqpoint{0pt}{-\youterradius}}%
	}%
	\anchor{east}{%
		\getradii%
		\csname pgf@anchor@cloud@border\endcsname{\pgfqpoint{\xouterradius}{0pt}}%
	}%
	\anchor{west}{%
		\getradii%
		\csname pgf@anchor@cloud@border\endcsname{\pgfqpoint{-\xouterradius}{0pt}}%
	}%
	\anchor{north west}{%
		\getradii%
		\pgfsavepgf@process\pgf@sh{%
			\pgf@x\xouterradius\relax%
			\pgf@x-0.707106\pgf@x%
			\pgf@y\youterradius\relax%
			\pgf@y0.707106\pgf@y%
		}%
		\csname pgf@anchor@cloud@border\endcsname{\pgf@sh}%
	}%
	\anchor{north east}{%
		\getradii%
		\pgfsavepgf@process\pgf@sh{%
			\pgf@x\xouterradius\relax%
			\pgf@x0.707106\pgf@x%
			\pgf@y\youterradius\relax%
			\pgf@y0.707106\pgf@y%
		}%
		\csname pgf@anchor@cloud@border\endcsname{\pgf@sh}%
	}%
	\anchor{south west}{%
		\getradii%
		\pgfsavepgf@process\pgf@sh{%
			\pgf@x\xouterradius\relax%
			\pgf@x-0.707106\pgf@x%
			\pgf@y\youterradius\relax%
			\pgf@y-0.707106\pgf@y%
		}%
		\csname pgf@anchor@cloud@border\endcsname{\pgf@sh}%
	}%
	\anchor{south east}{%
		\getradii%
		\pgfsavepgf@process\pgf@sh{%
			\pgf@x\xouterradius\relax%
			\pgf@x0.707106\pgf@x%
			\pgf@y\youterradius\relax%
			\pgf@y-0.707106\pgf@y%
		}%
		\csname pgf@anchor@cloud@border\endcsname{\pgf@sh}%
	}%
	%
	% Each `puff' is a circular arc of length a, drawn using two a/2 
	% arcs (a < 180), approximated by Bezier curves. Cannot use \pgfpatharc, 
	% because due to accuracy errors (from various sources), it is sometimes
	% necessary to `force' the arc to end at a specific point. So...
	%
	% @article{riskus2006,
	%   author  = {Aleskus Ri\v{s}kus},
	% 	title   = {Approximation of a cubic Bezier curve by circular arcs and vice versa},
	%   journal = {Information Technology and Control},
	%   year    = {2006},
	%   volume  = {35},
	%   number  = {4}
	% }
	%
	\backgroundpath{%
		\getradii%
		%
		% Get the start angle.
		%
		\pgfmathdivide@{\anglestep}{2}%
		\pgfmathsubtract@{90}{\pgfmathresult}%
		\let\angle\pgfmathresult%
		%
		% Calculate the first arc point.
		%
		\pgfsavepgf@process\arcfirstpoint{%
			\pgfpointadd{\centerpoint}{%
				\pgfpointpolar{+\angle}{+\xinnerradius and \yinnerradius}%
			}%
		}%
		\pgfpathmoveto{\arcfirstpoint}%
		\let\arcendpoint\arcfirstpoint%
		%
		\gettrigconstants%
		%
		\pgfmathloop%
		\ifnum\pgfmathcounter>\puffs\relax%
		\else
			\pgfutil@ifundefined{pgf@anchor@cloud@puff\space\pgfmathcounter}{%
				\expandafter\xdef\csname pgf@anchor@cloud@puff\space\pgfmathcounter\endcsname{%
					\expandafter\noexpand\expandafter\pgf@sh@@cloudpuffanchor\expandafter{\pgfmathcounter}%
				}%
			}{}%
			\let\arcstartpoint\arcendpoint%
			%
			% Make sure beginning and end of path are exactly the same.
			%
			\ifnum\pgfmathcounter=\puffs\relax%
				\let\arcendpoint\arcfirstpoint%
			\else%
				\pgfmathadd@{\angle}{\anglestep}%
				\let\angle\pgfmathresult%
				\pgfsavepgf@process\arcendpoint{%
					\pgfpointadd{\centerpoint}{%
						\pgfpointpolar{+\angle}{+\xinnerradius and +\yinnerradius}%
					}%
				}%	
			\fi%
			%
			% Get some useful cloud parameters from \arcstartpoint and \arcendpoint.
			%
			\pgf@sh@getcloudpuffparameters%
			%
			% Get the rotation for the Bezier curve.
			%
			\pgfmathsubtract@{90}{\quarterarc}%
			\pgfmathadd@{\pgfmathresult}{\arcslope}%
			\let\arcrotate\pgfmathresult%
			\pgfmathsin@{\arcrotate}%
			\let\sinarcrotate\pgfmathresult%
			\pgfmathcos@{\arcrotate}%
			\let\cosarcrotate\pgfmathresult%
			%
			% Calculate the amount by which to scale the control 
			% points, in order to approximate an a/2 arc with radius x.
			%
			\pgf@x\arcradius\relax%
			\pgf@x\tanquarterarc\pgf@x% tan(a/4)
			\edef\controlscale{\pgfmath@tonumber{\pgf@x}}%
			%
			% Get the first control point for the first arc (length a/2)...
			%
			\pgfsavepgf@process\controlone{%
				%
				% k = 0.552284745 (a `magic' number)...
				%
				\pgf@x0.55228475pt\relax%
				\pgf@x\sinquarterarc\pgf@x% k * sin(a/2)
				\pgf@y0.55228475pt\relax%
				\pgf@y\cosquarterarc\pgf@y% k * cos(a/2)
				%
				% ...scale the control points up...
				%
				\pgf@x\controlscale\pgf@x%
				\pgf@y\controlscale\pgf@y%
				%
				% ...rotate...
				%
				\pgf@xa\cosarcrotate\pgf@x%
				\advance\pgf@xa-\sinarcrotate\pgf@y%
				\pgf@ya\cosarcrotate\pgf@y%
				\advance\pgf@ya\sinarcrotate\pgf@x%
				%
				% ...and shift.
				%
				\arcstartpoint%
				\advance\pgf@x\pgf@xa%
				\advance\pgf@y\pgf@ya%
			}%
			%
			% Get the midpoint of the 150° arc.
			%
			\pgfsavepgf@process\arcmidpoint{%
				\pgfsavepgf@process\arcmidpoint{%
					\pgf@x-\halfchordlength\relax%
					\pgf@y\segmentheight\relax%
				}%
				\pgfpointadd{\arcstartpoint}{%
					\pgfmathrotatepointaround{\arcmidpoint}{\pgfpointorigin}{\arcslope}%
				}%
			}%
			%
			% Get the second control point for the first arc (length a/2)...
			%
			\pgfsavepgf@process\controltwo{%		
				\pgf@x0.55228475pt\relax%
				\pgf@x\sinquarterarc\pgf@x%  k * sin(a/2)
				\pgf@y-0.55228475pt\relax%
				\pgf@y\cosquarterarc\pgf@y% -k * cos(a/2)		
				%
				% ...scale, rotate and shift.
				%
				\pgf@x\controlscale\pgf@x%
				\pgf@y\controlscale\pgf@y%
				%
				\pgf@xa\cosarcrotate\pgf@x%
				\advance\pgf@xa-\sinarcrotate\pgf@y%
				\pgf@ya\cosarcrotate\pgf@y%
				\advance\pgf@ya\sinarcrotate\pgf@x%
				%
				\arcmidpoint%
				\advance\pgf@x\pgf@xa%
				\advance\pgf@y\pgf@ya%
			}%
			{%
				\pgfsetcornersarced{\pgfpointorigin}%
				\pgfpathcurveto{\controlone}{\controltwo}{\arcmidpoint}%
			}%
			%
			% Do the same for the second arc...
			%
			\pgfmathadd@{\quarterarc}{90}%
			\pgfmathadd@{\pgfmathresult}{\arcslope}%
			\let\arcrotate\pgfmathresult%
			\pgfmathsin@{\arcrotate}%
			\let\sinarcrotate\pgfmathresult%
			\pgfmathcos@{\arcrotate}%
			\let\cosarcrotate\pgfmathresult%
			%
			% First control point for the second arc...
			%
			\pgfsavepgf@process\controlone{%				
				\pgf@x0.55228475pt\relax%
				\pgf@x\sinquarterarc\pgf@x% k * sin(a/2)
				\pgf@y0.55228475pt\relax%
				\pgf@y\cosquarterarc\pgf@y% k * cos(a/2)
				%
				% ...scale, rotate and shift.
				%
				\pgf@x\controlscale\pgf@x%
				\pgf@y\controlscale\pgf@y%
				%
				\pgf@xa\cosarcrotate\pgf@x%
				\advance\pgf@xa-\sinarcrotate\pgf@y%
				\pgf@ya\cosarcrotate\pgf@y%
				\advance\pgf@ya\sinarcrotate\pgf@x%
				%
				\arcmidpoint%
				\advance\pgf@x\pgf@xa%
				\advance\pgf@y\pgf@ya%
			}%
			%
			% Second control point for the second arc.
			%
			\pgfsavepgf@process\controltwo{%				
				\pgf@x0.55228475pt\relax%
				\pgf@x\sinquarterarc\pgf@x%  k * sin(a/2)
				\pgf@y-0.55228475pt\relax%
				\pgf@y\cosquarterarc\pgf@y% -k * cos(a/2)		
				%
				% ...scale, rotate and shift.
				%
				\pgf@x\controlscale\pgf@x%
				\pgf@y\controlscale\pgf@y%
				%
				\pgf@xa\cosarcrotate\pgf@x%
				\advance\pgf@xa-\sinarcrotate\pgf@y%
				\pgf@ya\cosarcrotate\pgf@y%
				\advance\pgf@ya\sinarcrotate\pgf@x%
				%
				\arcendpoint%
				\advance\pgf@x\pgf@xa%
				\advance\pgf@y\pgf@ya%
			}%
			\pgfpathcurveto{\controlone}{\controltwo}{\arcendpoint}%
			\repeatpgfmathloop%
		\pgfpathclose% Phew!
	}%
	%
	% Calculate a point on the border of the cloud. This is a two-stage process:
	%
	% 1. Locate the correct puff.
	% 2. Locate the angle on the circular arc which forms the puff.
	%
	\anchorborder{%
		%
		% Save x and y.
		%
		\edef\externalx{\the\pgf@x}%
		\edef\externaly{\the\pgf@y}%
	 	%
		% Get the inner radii and trig. constants.
		%
		\getradii%		
		\gettrigconstants%
		%
		%
		%
		\ifpgfcloudanchorsuseellipse%
			\pgfpointadd{\centerpoint}{%
				\pgfpointborderellipse{%
					\pgfpoint{\externalx}{\externaly}
					}{%
						\pgfpoint{\xouterradius}{\youterradius}
					}%
			}%
		\else%
			\pgfsavepgf@process\externalpoint{%
				\centerpoint%
				\advance\pgf@x\externalx\relax%
				\advance\pgf@y\externaly\relax%
			}%
			\pgfmathanglebetweenpoints{\centerpoint}{\externalpoint}%
			\let\externalangle\pgfmathresult%
			%
			% 1. Locate the correct puff: 
			%
			% Get end angle of the relavent puff arc.
			%
			\pgfmathdivide@{\anglestep}{2}%
			\let\halfanglestep\pgfmathresult%
			\pgfmathsubtract@{90}{\halfanglestep}%
			\let\endangle\pgfmathresult%
			\pgfmathloop%
				\pgfmathsubtract@{\endangle}{\anglestep}%
				\ifdim\pgfmathresult pt<-\anglestep pt\relax%
				\else%
					\let\endangle\pgfmathresult%
			\repeatpgfmathloop%
			\def\angle{0}%
			\let\lastangle\angle%
			\pgfmathloop%
				\pgfmathadd@{\endangle}{\anglestep}%
				\let\endangle\pgfmathresult%
				%
				% Calculate the `miter point'. This is the point between 
				% each puff, and takes into account the outer sep.
				%
				\pgfsavepgf@process\miterpoint{%
					%
					\pgfsavepgf@process\secondpoint{%
						\pgfpointpolar{+\endangle}{+\xinnerradius and +\yinnerradius}%
					}%
					%
					\pgfmathadd@{\endangle}{\anglestep}%
					\let\angletemp\pgfmathresult%
					\pgfsavepgf@process\thirdpoint{%
						\pgfpointpolar{+\angletemp}{+\xinnerradius and +\yinnerradius}%
					}%
					%
					\pgfmathsubtract@{\endangle}{\anglestep}%
					\let\angletemp\pgfmathresult%
					\pgfsavepgf@process\firstpoint{%
						\pgfpointpolar{+\angletemp}{+\xinnerradius and +\yinnerradius}%
					}%
					%
					\pgfmathanglebetweenpoints{\firstpoint}{\secondpoint}%
					\let\anglealpha\pgfmathresult%
					\pgfmathanglebetweenpoints{\secondpoint}{\thirdpoint}%
					\let\anglebeta\pgfmathresult%
					%
					\pgfmathsubtract@{\anglebeta}{\anglealpha}%
					\pgfmathdivide@{\pgfmathresult}{2}%
					\pgfmathadd@{\pgfmathresult}{\halfcomplementarc}%
					\pgfmathcosec@{\pgfmathresult}%
					\pgf@x\outersep\relax%
					\pgf@x\pgfmathresult\pgf@x%
					\edef\miterradius{\the\pgf@x}%
					%
					\pgfmathadd@{\anglealpha}{\anglebeta}%
					\pgfmathsubtract@{\pgfmathresult}{180}%
					\pgfmathdivide@{\pgfmathresult}{2}%
					\let\miterangle\pgfmathresult%
					\pgfpointadd{\secondpoint}{%
						\pgfqpointpolar{\miterangle}{\miterradius}%
					}%
				}%
				%
				% Get the angle of the miter point...
				%
				\pgfmathanglebetweenpoints{\pgfpointorigin}{\miterpoint}%
				\let\angle\pgfmathresult%
				\ifdim\angle pt<\lastangle pt\relax% Guard against 360° = 0°
					\pgfmathadd@{\angle}{360}%
					\let\angle\pgfmathresult%
				\fi%
				\let\lastangle\angle%
				%
				% ...and see if it is greater than the external point.
				%
			\ifdim\externalangle pt>\angle pt\relax%
			\repeatpgfmathloop%
			%
			% Get the start angle of the relevant arc and ensure angles are in the range.
			%
			\pgfmathmod@{\endangle}{360}%
			\let\endangle\pgfmathresult%
			\pgfmathsubtract@{\endangle}{\anglestep}%
			\ifdim\pgfmathresult pt<0pt\relax%
				\pgfmathadd@{\pgfmathresult}{360}%
			\fi%
			\let\startangle\pgfmathresult%
			%
			% Now, get the start and end points of the arc.
			%
			\pgfsavepgf@process\arcstartpoint{%
				\pgfpointadd{\centerpoint}{%
					\pgfpointpolar{+\startangle}{+\xinnerradius and +\yinnerradius}%
				}%
			}%	
			\pgfsavepgf@process\arcendpoint{%
				\pgfpointadd{\centerpoint}{%
					\pgfpointpolar{+\endangle}{+\xinnerradius and +\yinnerradius}%
				}%
			}%	
			%
			% Get some useful cloud parameters from \arcstartpoint and \arcendpoint.
			%
			\pgf@sh@getcloudpuffparameters%
			%
			% Hackery, for when an arc straddles 0°.
			%
			\ifdim\endangle pt<\startangle pt\relax%
				\pgfmathadd@{\externalangle}{180}%
				\pgfmathmod@{\pgfmathresult}{360}%
				\let\x\pgfmathresult%
			\else%
				\let\x\externalangle%
			\fi%
			%
			% 2. Locate the angle on the circular arc which forms the puff.
			% 
			% Essentially a binary search to find the angle on the circular  
			% arc, which provides the nearset estimate to the border point.
			%
			\let\s\halfcomplementarc% The start of the arc.
			\pgfmathadd@{\s}{\arc}%
			\let\e\pgfmathresult% The end of the arc.
			\pgfmathadd@{\e}{\s}%
			\pgfmathdivide@{\pgfmathresult}{2}%
			\let\n\pgfmathresult% The nearest estimate (default to middle of arc).
			\def\m{360}% Measure of `nearness'.
			\pgfmathloop%
				\pgfmathadd@{\e}{\s}%
				\pgfmathdivide@{\pgfmathresult}{2}%
				\let\p\pgfmathresult% The point halfway between \s and \e.
				\ifdim\p pt=\s pt\relax% 
				\else%
					%
					% Get the point on the circular arc.
					%
					\pgfmathadd@{\p}{\arcslope}%
					\let\a\pgfmathresult%
					\pgfsavepgf@process\arcpoint{%
						\pgfpointadd{\circlecenterpoint}{%
							\pgfqpointpolar{\a}{\outerarcradius}%
						}%
					}%
					%
					% Find the angle between the node centre and the point on the arc.
					%
					\pgfmathanglebetweenpoints{\centerpoint}{\arcpoint}%
					%
					% Hackery, for when an arc straddles 0°.
					%
					\ifdim\endangle pt<\startangle pt\relax%
						\pgfmathadd@{\pgfmathresult}{180}%
						\pgfmathmod@{\pgfmathresult}{360}%
					\fi%
					\let\q\pgfmathresult%
					\ifdim\x pt=\q pt% Found it!
						\pgfmathbreakloop% Breaks after current iteration is complete.
					\else
						\ifdim\x pt<\q pt\relax%
							\let\e\p%
						\else%
							\let\s\p%
						\fi%
					\fi%
					\pgfmathsubtract@{\x}{\q}%
					\pgfmathabs@{\pgfmathresult}%
					%
					% Save the estimate if it is better than any previous estimate.
					%
					\ifdim\pgfmathresult pt<\m pt\relax%
						\let\m\pgfmathresult%
						\let\n\p%
					\fi%				
			\repeatpgfmathloop%
			%
			% Use the nearest estimate as the anchor angle.
			%
			\pgfmathadd@{\n}{\arcslope}%
			\let\anchorangle\pgfmathresult%
			%
			% Finally, the required point.
			%
			\pgfpointadd{\circlecenterpoint}{%
				\pgfqpointpolar{\anchorangle}{\outerarcradius}%
			}%
		\fi%
	}% Again, Phew!
}

% \pgf@sh@@cloudpuffanchor
% 
% Internal macro for calculating the anchors puff 1, puff 2, ... etc.
%
\def\pgf@sh@@cloudpuffanchor#1{%
		\pgfmathdivide@{\anglestep}{2}%
		\let\halfanglestep\pgfmathresult%
		\c@pgf@counta#1\relax%
		\advance\c@pgf@counta-1\relax%
		\pgfmathmultiply@{\anglestep}{\the\c@pgf@counta}%
		\pgfmathadd@{\pgfmathresult}{90}%
		\pgfmathsubtract@{\pgfmathresult}{\halfanglestep}%
		\let\angle\pgfmathresult%
		\getradii%
		%
		% Calculate the first arc point.
		%
		\pgfsavepgf@process\arcstartpoint{%
			\pgfpointadd{\centerpoint}{%
				\pgfpointpolar{+\angle}{+\xinnerradius and +\yinnerradius}%
			}%
		}%
		%
		\gettrigconstants%
		\pgfmathadd@{\angle}{\anglestep}%
		\let\angle\pgfmathresult%
		\pgfsavepgf@process\arcendpoint{%
			\pgfpointadd{\centerpoint}{%
				\pgfpointpolar{+\angle}{+\xinnerradius and +\yinnerradius}%
			}%
		}%	
		%
		% Get some useful cloud parameters from \arcstartpoint and \arcendpoint.
		%
		\pgf@sh@getcloudpuffparameters%
		%
		% Calculate the point.
		%
		\pgfmathadd@{\arcslope}{90}%
		\let\anchorangle\pgfmathresult%
		\pgfpointadd{\circlecenterpoint}{%
			\pgfqpointpolar{\anchorangle}{\outerarcradius}%
		}%
}  

% \pgf@sh@cloudpuffparameters
%
% Internal macro to calculate some common arc parameters which 
% are required when calculating radii, drawing the background
% path and calculating border anchors.
%
\def\pgf@sh@getcloudpuffparameters{%
  %
	% Calculate the angle to which the entire arc is sloped.
	%
	\pgfmathanglebetweenpoints{\arcendpoint}{\arcstartpoint}%
	\let\arcslope\pgfmathresult%
	%
  % Calculate the chord length and arc radius.
  %
  \pgfpointdiff{\arcendpoint}{\arcstartpoint}%
  \pgfmathveclen@{\pgfmath@tonumber{\pgf@x}}{\pgfmath@tonumber{\pgf@y}}
  \pgf@x\pgfmathresult pt\relax%
  \pgf@xa.5\pgf@x%
  \edef\halfchordlength{\the\pgf@xa}%
	\pgf@x\arcradiusquotient\pgf@x%
  \edef\arcradius{\the\pgf@x}%
  \pgf@xa\outersep\relax%
  \advance\pgf@xa\pgf@x%
  \edef\outerarcradius{\the\pgf@xa}%
  %
  % Calculate the height of the resulting segment.
  %
  \pgf@y-\sinhalfcomplementarc\pgf@x% sin((180-a)/2)
  \advance\pgf@y\pgf@x%
  \edef\segmentheight{\the\pgf@y}%
  %
  % Calculate the center of the circle of which the arc is a part.
  %
  \pgfsavepgf@process\circlecenterpoint{%
    \pgfsavepgf@process\circlecenterpoint{%
      \pgf@x-\halfchordlength\relax%
      \pgf@y\segmentheight\relax%
      \advance\pgf@y-\arcradius
    }%
    \pgfpointadd{\arcstartpoint}{%
      \pgfmathrotatepointaround{\circlecenterpoint}{\pgfpointorigin}{\arcslope}%
    }%
  }%
}
\endinput
