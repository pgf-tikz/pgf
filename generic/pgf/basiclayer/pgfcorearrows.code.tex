% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS $Header$



% Define a new (meta) arrow or a shorthand
%
% #1 = key--value pairs
%
% Description:
%
% This command is used to define a new arrow tip kind. For more
% details on the description of the keys, please see the pgfmanual.
% 
% name        = Name of the arrow. If the name contains a dash
%               (hyphen), the text before the hyphen is the start name
%               and the text behind it the end name.
% means       = If set, none of the below options may be
%               given. The effect is that whenever the arrow is
%               used, it gets replaced by this "text", which is
%               parsed by the parser.
%
% setup       = Code that does "precomputations". These will be
%               executed only once for each combination of the
%               dependencies. At the end of this code, you can use
%                \savethe and \save to "save" computed values, which
%               will then be available inside the "code". Values needed
%               only for the "... end" keys and the convex hull do not
%               need to be saved since these are also executed only
%               once. 
% code        = Code for drawing the arrow. When the cache key is set to
%               true, which is the default, the code will be protocolled
%               and the resulting code is inserted using \pgflowlevelobj.
% cache       = Boolean that decides whether the arrow can be cached. The
%               default is true, so you have to say cache=false to switch
%               caching off. In this case, each time the arrow is drawn,
%               its code is simply executed. This allows you to put things
%               like text or shadings in arrow tips.
% convex hull = A sequence of pairs of coordinates (like
%               {1pt}{2pt}{3pt}{4pt} for the points (1pt,2pt) and
%               (3pt,4pt)) that "envelope" the arrow tip
%               completely. Should be as small and as short as
%               possible. In particular, it usually should not contain 
%               x-coordinates outside the interval [back end, tip
%               end]. This hull is used for updating the picture's
%               bounding box when the arrow tip is used.
% defaults    = A list of "default" options for the arrow tip. These
%               are executed as if they were given to the arrow tip in
%               brackets. This is useful for setting up default values.
% parameters  = A list of comma-separated macro names on whose values
%               the appearance of the arrow tip depends. When an arrow
%               tip is used, these macros are expanded. If an
%               arrow tip was already installed with the same macro
%               names (and caching is true), the cached code is
%               used. Note that when you use dimensions here, add \the.
%               
% Inside the setup code, the following macros are available:               
%
% \pgfarrowsettipend
%              The code should draw an arrow pointing "right along the x
%              axis". The "tip" key specifies how far the arrow goes
%              along the x axis, that is, it should be the x coordinate
%              of the very tip of the arrow. In previous versions this
%              was called the "right extend". The value passed to this
%              key should be some code that sets the dimension
%              "\pgfarrowresult", which is \let to be equal to
%              \pgf@x. A \relax will be added after the code provided
%              here, so you can write things like "\pgfarrowresult=1pt".
% \pgfarrowsetbackend
%              The leftmost x-coordinate that is still part of the
%              arrow tip (the "back end" of the arrow"). This coordinate
%              will be used when multiple arrow tips are
%              composed. Defaults to 0pt.
% \pgfarrowsetlineend
%              The x-coordinate where a line should stop inside the arrow
%              tip so that it gets "obscured" by the arrow. Defaults to 0pt.
% \pgfarrowsetrigidtipend
%              When the arrow tip is drawn "rigidly", it is rotated
%              such that the x-coordinates of "rigid tip end" and "rigid
%              back end" lie on the path. Defaults to \pgfarrowsettipend.
% \pgfarrowsetrigidbackend
%              See above. Defaults to \pgfarrowsetbackend

\def\pgfdeclarearrow#1{%
  \let\pgf@decl@arrow@defaults\pgfutil@empty%
  \pgfkeys{/pgf/@arrows/.cd,
    name=,
    means=,
    setup=,
    code=,
    cache=true,
    parameters=,%
    #1%
  }%
  \ifx\pgf@decl@arrow@name@end\pgfutil@empty%
    \pgferror{Declaring unnamed arrow}%
  \else%
    \pgf@arrow@letter{name@end}%
    \pgf@arrow@letter{name@start}%
    \expandafter\let\csname pgf@ar@start@\pgf@decl@arrow@name@start\endcsname\pgf@decl@arrow@name@end%
    \ifx\pgf@decl@arrow@means\pgfutil@empty%
      \pgf@arrow@letter{code}%
      \pgf@arrow@letter{defaults}%
      \pgf@arrow@letter{setup}%
      \pgf@arrow@letter{cache}%
      \pgf@arrow@letter{par}%
    \else%
      \let\pgf@arrow@tip@sequence\pgfutil@empty%
      \let\pgf@arrow@translate\relax%
      \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@end@\pgf@decl@arrow@means\endcsname%
      \ifx\pgf@arrows@direct\relax%
        \expandafter\pgfarrows@initial@parser\pgf@decl@arrow@means[]\pgf@stop%
      \else%
        \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
      \fi%
      \pgf@arrow@letter@\pgf@arrow@tip@sequence{means}%
    \fi%
  \fi%
}

\def\pgf@arrow@letter#1{%
  \expandafter\pgf@arrow@letter@\expandafter{\csname pgf@decl@arrow@#1\endcsname}{#1}%
}
\def\pgf@arrow@letter@#1#2{%
  \expandafter\let\csname pgf@ar@#2@\pgf@decl@arrow@name@end\endcsname#1%
}

\pgfkeys{
  /pgf/@arrows/.cd,
  name/.code={%
    \pgfutil@in@-{#1}%
    \ifpgfutil@in@%
      \pgf@arrows@name@decomp#1\pgf@stop%
    \else%
      \def\pgf@decl@arrow@name@end{#1}\let\pgf@decl@arrow@name@start\pgf@decl@arrow@name@end%
    \fi},
  means/.store in=\pgf@decl@arrow@means,
  setup/.store in=\pgf@decl@arrow@setup,
  code/.store in=\pgf@decl@arrow@code,
  cache/.is if=pgf@decl@arrow@cache,
  parameters/.store in=\pgf@decl@arrow@par,
  defaults/.code={%
    \let\pgf@arrows@options\pgfutil@empty%
    \pgfkeys{/pgf/arrows/.cd,#1}%
    \let\pgf@decl@arrow@defaults\pgf@arrows@options%
  }
}

\newif\ifpgf@decl@arrow@cache

\def\pgf@arrows@name@decomp#1-#2\pgf@stop{%
  \def\pgf@decl@arrow@name@start{#1}%
  \def\pgf@decl@arrow@name@end{#2}%
}



% Handler for defining arrow tips:
% 
% Description:
% 
% When you write "my name/.tip = arrow spec", this has the same
% effect as writeing \pgfdeclarearrow{name = my name, means = arrow spec}.

\pgfkeys{/handlers/.tip/.code=%
  \expandafter\expandafter\expandafter\pgf@arrows@unravel\pgfkeyscurrentpath/\pgf@stop%
  \expandafter\pgf@arrows@key@call\expandafter{\pgf@arrows@unravelled}{#1}}
\def\pgf@arrows@unravel#1/{\pgfutil@ifnextchar\pgf@stop{\def\pgf@arrows@unravelled{#1}\pgfutil@gobble}{\pgf@arrows@unravel}}
\def\pgf@arrows@key@call#1#2{\pgfdeclarearrow{name={#1},means={#2}}}




% Sets the end arrow tip
%
% #1 = An arrow specification
%
% Description:
% 
% An "arrow specification" is a sequence of names of meta arrow tips
% together with options in brackets. In detail:
% 
% In #1, consider the text from the start up to the first bracket. If
% this text is the name of a (meta) arrow tip, we use this arrow tip
% with the provided options. If it is the name of a arrow tip
% shorthand, this shorthand is expanded and the options are applied to
% each arrow tip inside the shorthand. If the text is neither or the
% above, the first letter of text is treated as a shorthand without
% options.
% 
% The special arrow tip "." is used to indicate the end of the line. 
%
% \pgfsetarrowsend{stealth[reversed]}
% \pgfsetarrowsend{stealth[length=1pt] . stealth[length=2pt]}
% \pgfsetarrowsend{>>>}
% \pgfsetarrowsend{>.>}

\def\pgfsetarrowsend#1{%
  \let\pgf@arrow@tip@sequence\pgfutil@empty%
  \pgf@arrows@translatefalse%
  \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@end@#1\endcsname%
  \ifx\pgf@arrows@direct\relax%
    \edef\pgf@marshal{\noexpand\pgfarrows@initial@parser#1[]\noexpand\pgf@stop}%
    \pgf@marshal%
  \else%
    \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
  \fi%
  \let\pgf@end@tip@sequence\pgf@arrow@tip@sequence%
}

\newif\ifpgf@arrows@translate

\def\pgfarrows@initial@parser{\pgfutil@ifnextchar[\pgfarrows@initial@parser@{\pgfarrows@initial@parser@[]}}%}
\def\pgfarrows@initial@parser@[#1]{%
  \let\pgf@arrows@options\pgfutil@empty%
  \pgfkeys{/pgf/arrows/.cd,#1}%
  \let\pgf@arrows@options@initial\pgf@arrows@options%
  \pgfarrows@parser%
}

\def\pgfarrows@parser#1[{%
  \pgfkeys@spdef\pgf@temp{#1}%
  \ifx\pgf@temp\pgfutil@empty%
    \let\pgf@next\pgf@arrows@empty%
  \else%
    \ifx\pgf@temp\pgf@dot@text%
      \let\pgf@next\pgf@arrows@dot@parsed%
    \else%
      \let\pgf@untranslated\pgf@temp%
      \ifpgf@arrows@translate%
        \pgf@arrow@swapper%
      \fi%
      % Now, let's see what we do with this...
      \expandafter\ifx\csname pgf@ar@code@\pgf@temp\endcsname\relax
        \expandafter\ifx\csname pgf@ar@means@\pgf@temp\endcsname\relax
          % #1 should start with a single-char shorthands
          \let\pgf@next\pgf@arrows@single@char@parser%
          \let\pgf@temp\pgf@untranslated%
        \else%
          % #1 is a shorthand!
          \let\pgf@next\pgf@arrows@shorthand@parsed%
        \fi%
      \else%
        % #1 is a meta arrow!
        \let\pgf@next\pgf@arrows@meta@parsed%
      \fi%
    \fi%
  \fi%
  \expandafter\pgf@next\pgf@temp[%  
}

\def\pgf@arrows@empty[#1]{%
  \pgfutil@ifnextchar\pgf@stop\pgfutil@gobble\pgfarrows@parser%  
}

\def\pgf@arrows@single@char@parser#1{%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\pgf@dot@text%
    \let\pgf@next\pgf@arrows@dot@parsed%
  \else%
    \let\pgf@untranslated\pgf@temp%
    \ifpgf@arrows@translate%
      \pgf@arrow@swapper%
    \fi%
    \expandafter\ifx\csname pgf@ar@code@\pgf@temp\endcsname\relax
      \expandafter\ifx\csname pgf@ar@means@\pgf@temp\endcsname\relax
        \let\pgf@temp\pgf@untranslated%
        \let\pgf@next\pgf@arrows@unknown%
      \else%
        \let\pgf@next\pgf@arrows@shorthand@parsed%  
      \fi%
    \else%
      \let\pgf@next\pgf@arrows@meta@parsed%  
    \fi
  \fi
  \expandafter\pgf@next\pgf@temp[]%  
}
\def\pgf@arrows@unknown#1[]#2[#3]{%
  \pgferror{Unknown arrow tip kind '#1#2'}%
}

\def\pgf@arrows@meta@parsed#1[#2]{%
  % Ok, run the keys #2. This will add commands to \pgf@arrows@options:
  % 
  \let\pgf@arrows@options\pgf@arrows@options@initial%
  \pgfkeys{/pgf/arrows/.cd,#2}%
  % Append the arrow and its options to the arrow tip sequence:
  \expandafter\pgf@arrows@meta@set\expandafter{\pgf@arrows@options}{#1}{\pgf@arrow@handle}%
  \pgfutil@ifnextchar\pgf@stop\pgfutil@gobble\pgfarrows@parser%  
}

\def\pgf@arrows@dot@parsed#1[#2]{%
  \pgf@arrows@append@to@tips{\pgf@arrow@handle@dot}%
  \pgfutil@ifnextchar\pgf@stop\pgfutil@gobble\pgfarrows@parser%  
}

\def\pgf@arrows@meta@set#1#2#3{%
  \pgf@arrows@append@to@tips{#3{#2}{#1}}%
}
\def\pgf@arrows@append@to@tips#1{%
  \let\pgf@tempa\pgf@arrow@tip@sequence%
  \def\pgf@tempb{#1}%
  \ifpgf@arrows@translate%
    \let\pgf@tempa\pgf@tempb%
    \let\pgf@tempb\pgf@arrow@tip@sequence%
  \fi%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrow@tip@sequence%
  \expandafter\expandafter\expandafter{\expandafter\pgf@tempa\pgf@tempb}%  
}

\def\pgf@arrows@shorthand@parsed#1[#2]{%
  \let\pgf@arrows@options\pgf@arrows@options@initial%
  \pgfkeys{/pgf/arrows/.cd,#2}%
  \ifx\pgf@arrows@options\pgfutil@empty%
    \pgf@arrows@append@to@tips{\pgf@arrow@handle@shorthand@empty{#1}}%
  \else%
    \expandafter\pgf@arrows@meta@set\expandafter{\pgf@arrows@options}{#1}{\pgf@arrow@handle@shorthand}%
  \fi%
  \pgfutil@ifnextchar\pgf@stop\pgfutil@gobble\pgfarrows@parser%  
}


% General handler:

\def\pgf@arrow@handle@shorthand@empty#1{%
  \csname pgf@ar@means@#1\endcsname%
}

\def\pgf@arrow@handle@shorthand#1#2{%
  \expandafter\let\expandafter\pgf@temp\csname pgf@ar@means@#1\endcsname%
  \def\pgf@temp@opt{#2}%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@nested@options@temp%
  \expandafter\expandafter\expandafter{\expandafter\pgf@temp@opt\pgf@arrows@nested@options}%
  \expandafter\let\expandafter\pgf@arrows@nested@options\expandafter\pgf@arrows@nested@options@temp%
  \expandafter\pgf@temp% all these expandafters to avoid creating groups, but having the options nest
  \expandafter\def\expandafter\pgf@arrows@nested@options\expandafter{\pgf@arrows@nested@options}%
}

\let\pgf@arrows@nested@options\pgfutil@empty




% Sets the start arrow tip
%
% #1 = An arrow specification
%
% Description:
% 
% This works like \pgfsetarrowsend, only the order of the tips in the
% arrow specification is reversed and the "reversed names" are used.
%
% \pgfsetarrowsend{<<}
% \pgfsetarrowsend{>.>}

\def\pgfsetarrowsstart#1{%
  \let\pgf@arrow@tip@sequence\pgfutil@empty%
  \pgf@arrows@translatetrue%
  \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@start@#1\endcsname%
  \ifx\pgf@arrows@direct\relax%
    \edef\pgf@marshal{\noexpand\pgfarrows@initial@parser#1[]\noexpand\pgf@stop}%
    \pgf@marshal%
  \else%
    \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
  \fi%
  \let\pgf@start@tip@sequence\pgf@arrow@tip@sequence%
}

\def\pgf@arrow@swapper{%
  \expandafter\let\expandafter\pgf@temp\csname pgf@ar@start@\pgf@temp\endcsname%
  \ifx\pgf@temp\relax%
    \def\pgf@temp{undefined}%
  \fi%
}

\let\pgf@start@tip@sequence\pgfutil@empty
\let\pgf@end@tip@sequence\pgfutil@empty


\expandafter\def\csname pgf@arrows@direct@name@start@\endcsname{}
\expandafter\def\csname pgf@arrows@direct@name@end@\endcsname{}


% Predefined lengths and ifs

\newdimen\pgfarrowinset
\newdimen\pgfarrowlength
\newdimen\pgfarrowwidth

\newif\ifpgfarrowswap
\newif\ifpgfarrowreversed

\pgfkeys{
  /pgf/arrows/.cd,
  length/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtooption\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\pgfarrowlength\pgf@x}%
  },
  inset/.code=\pgfarrowsaddtooption{\pgfarrowinset#1},
  width/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtooption\expandafter{\expandafter\pgfarrowslengthdependent\pgfarrowstheparameters\pgfarrowwidth\pgf@x}%
  },
  degrees/.code=\pgfarrowsaddtooption{\def\pgfarrowdegrees{#1}},
  sep/.code={
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtooption\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\edef\pgfarrowsep{\the\pgf@x}}%
  },
  sep/.default=0.88pt .3 1,
  %
  swap/.code=\pgfarrowsaddtooption{\ifpgfarrowswap\pgfarrowswapfalse\else\pgfarrowswaptrue\fi},
  reversed/.code=\pgfarrowsaddtooption{\ifpgfarrowreversed\pgfarrowreversedfalse\else\pgfarrowreversedtrue\fi},
}

\def\pgfarrowsaddtooption#1{\expandafter\def\expandafter\pgf@arrows@options\expandafter{\pgf@arrows@options#1}}
\def\pgfarrowsep{0pt}

\def\pgfarrowsthreeparameters#1{%
  \pgfarrowsthreeparameters@#1 0 0 0 \pgf@stop%
}
\def\pgfarrowsthreeparameters@#1 #2 #3 #4\pgf@stop{%
  \pgfmathsetlength\pgf@x{#1}%
  \edef\pgfarrowstheparameters{{\the\pgf@x}{#2}{#3}}%
}


\def\pgfarrowslinewidthdependent#1#2#3{%
  \pgf@x#1%
  \ifdim\pgfinnerlinewidth>0pt%
    \pgf@arrows@inner@line@width@dep{#2}{#3}%
  \else%  
    \advance\pgf@x by#2\pgflinewidth%
  \fi%
}
\def\pgf@arrows@inner@line@width@dep#1#2{%
  % Compute "real" line width
  \pgf@xa.5\pgflinewidth%
  \pgf@xb\pgfinnerlinewidth%
  \advance\pgf@xa by-.5\pgf@xb%
  \advance\pgf@x by#1\pgf@xa%
  % Compute "dampening":
  \pgf@xa.5\pgflinewidth%
  \advance\pgf@xa by.5\pgf@xb%
  \pgf@xc-\pgf@xa
  \pgf@xa#2\pgf@xa%
  \advance\pgf@xa by\pgf@xc%
  \advance\pgf@x by-\pgf@xa%
}

\def\pgfarrowslengthdependent#1#2#3{%
  \pgf@x#1%
  \advance\pgf@x by#2\pgfarrowlength%
}

\def\pgfarrowslwdependent#1#2#3{%
  \pgf@x#1%
  \advance\pgf@x by#2\pgfarrowlength%
  \advance\pgf@x by#3\pgfarrowwidth%
}


% Build the full name:

\def\pgf@arrow@fullname#1{pgf@@ar@#1@\the\pgflinewidth @\pgfinnerlinewidth @\pgfarrowsep @\ifpgfarrowreversed r\fi @\csname pgf@ar@par@#1\endcsname}

\def\pgf@arrow@id@count{0}%


% Compute the arrow id of an arrow
% 
% #1 = arrow name
% #2 = options
% 
% Description:
% 
% Returns the an id in \pgf@arrow@id that identifies the instantiation
% of the given arrow. If the arrow was not instantiated, this happens now.

\def\pgfarrows@getid#1#2{%
  % Execute options:
  \csname pgf@ar@defaults@#1\endcsname% defaults
  #2\relax% local options
  \pgf@arrows@nested@options% enclosing options
  % Now, test:
  \expandafter\global\expandafter\let\expandafter\pgf@arrow@id\csname\pgf@arrow@fullname{#1}\endcsname\relax%
  \ifx\pgf@arrow@id\relax%
    \pgf@arrows@instantiate{#1}
  \fi%
}

\def\pgf@arrows@instantiate#1{%
  % Not defined. Rats!
  % Allocate new id:
  \pgfutil@tempcnta\pgf@arrow@id@count\relax%
  \advance\pgfutil@tempcnta by1\relax%
  \xdef\pgf@arrow@id@count{\the\pgfutil@tempcnta}%
  \expandafter\global\expandafter\let\csname\pgf@arrow@fullname{#1}\endcsname\pgf@arrow@id@count%
  \global\let\pgf@arrow@id\pgf@arrow@id@count%
  {%
    \csname pgf@ar@setup@#1\endcsname%
    % Handle reversal
    \ifpgfarrowreversed%
      % Compute transformation:
      \pgf@arrows@handle@reverse%
    \fi%
    % Safe computed values
    \expandafter\global\expandafter\let\csname pgf@ar@saves@\pgf@arrow@id\endcsname\pgf@arrows@saves%
    \expandafter\global\expandafter\let\csname pgf@ar@hull@\pgf@arrow@id\endcsname\pgf@arrows@convexhull%
    \expandafter\xdef\csname pgf@ar@ends@\pgf@arrow@id\endcsname{{\pgf@arrows@the@tipend}{\pgf@arrows@the@backend}{\pgf@arrows@the@lineend}{\pgfarrowsep}}%
    \expandafter\xdef\csname pgf@ar@rigid@\pgf@arrow@id\endcsname{{\pgf@arrows@the@rigidtipend}{\pgf@arrows@the@rigidbackend}}%
    % Save code (needed for bending)
    \edef\pgf@arrow@code{%
      \ifpgfarrowreversed\noexpand\pgftransformxscale{-1}\fi%
      \expandafter\noexpand\csname pgf@ar@code@#1\endcsname%
    }%
    \expandafter\global\expandafter\let\csname pgf@ar@code@\pgf@arrow@id\endcsname\pgf@arrow@code%
    % Should we cache?
    \ifpgf@decl@arrow@cache%
      \pgfsysprotocol@getcurrentprotocol\pgf@arrow@temp%
      {%
        \pgfinterruptpath%
          \let\pgfusepath=\pgf@nousepath@here%
          \pgf@relevantforpicturesizefalse%
          \pgftransformreset%
          \pgfsysprotocol@setcurrentprotocol\pgfutil@empty%
          \pgfsysprotocol@bufferedtrue%
          \pgfsys@beginscope%
          \pgf@arrow@code%
          \pgfsys@endscope%
          \pgfsysprotocol@getcurrentprotocol\pgf@@arrow@temp%
          \expandafter\gdef\expandafter\pgf@arrow@code\expandafter{\expandafter\pgfsys@invoke\expandafter{\pgf@@arrow@temp}}%
        \endpgfinterruptpath%
      }%
      \pgfsysprotocol@setcurrentprotocol\pgf@arrow@temp%
    \fi%
    \expandafter\global\expandafter\let\csname pgf@ar@cache@\pgf@arrow@id\endcsname\pgf@arrow@code%
  }%
}

% Ok, now run setup:
\def\pgf@arrows@copy@tipend{\pgf@arrows@the@tipend}
\def\pgf@arrows@copy@backend{\pgf@arrows@the@backend}
\def\pgf@arrows@copy@lineend{\pgf@arrows@the@lineend}
\def\pgf@arrows@zero{0pt}%

\let\pgf@arrows@saves\pgfutil@empty%
\let\pgf@arrows@convexhull\pgfutil@empty%
\let\pgf@arrows@the@tipend\pgf@arrows@zero%
\let\pgf@arrows@the@backend\pgf@arrows@zero%
\let\pgf@arrows@the@lineend\pgf@arrows@zero%
\let\pgf@arrows@the@rigidtipend\pgf@arrows@copy@tipend%
\let\pgf@arrows@the@rigidbackend\pgf@arrows@copy@backend%
\def\pgf@arrows@the@rigidity{1}%


\def\pgf@arrows@handle@reverse{%
  \pgf@x\pgf@arrows@the@rigidtipend\pgf@x-\pgf@x%
  \pgf@y\pgf@arrows@the@rigidbackend\pgf@y-\pgf@y
  \edef\pgf@arrows@the@rigidtipend{\the\pgf@y}%
  \edef\pgf@arrows@the@rigidbackend{\the\pgf@x}%
  \pgf@x\pgf@arrows@the@tipend\pgf@x-\pgf@x%
  \pgf@y\pgf@arrows@the@backend\pgf@y-\pgf@y
  \edef\pgf@arrows@the@tipend{\the\pgf@y}%
  \edef\pgf@arrows@the@backend{\the\pgf@x}%
  \pgf@x\pgf@arrows@the@lineend\pgf@x-\pgf@x\edef\pgf@arrows@the@lineend{\the\pgf@x}%
  \let\pgf@temp\pgf@arrows@convexhull%
  \let\pgf@arrows@convexhull\pgfutil@empty%
  \let\pgf@arrow@hull@point\pgf@arrow@hull@point@reverse%
  \pgf@temp%
}
\def\pgf@arrow@hull@point@reverse#1#2{%
  \pgf@x#1%
  \pgfarrowshullpoint{-\pgf@x}{#2}%
}

\def\pgf@nousepath@here#1{\pgferror{The definition of an arrow may not use \string\pgfusepath}}

\def\pgfarrowssavethe#1{%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@saves%
  \expandafter\expandafter\expandafter{\expandafter\pgf@arrows@saves\expandafter#1\the#1\relax}
}

\def\pgfarrowssave#1{%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@saves%
  \expandafter\expandafter\expandafter{\expandafter\pgf@arrows@saves\expandafter\def\expandafter#1\expandafter{#1}}
}

\def\pgfarrowshullpoint#1#2{%
  \pgf@x#1\relax%
  \pgf@y#2\relax%
  \edef\pgf@arrows@temp{\noexpand\pgf@arrows@convexhull\noexpand\pgf@arrow@hull@point{\the\pgf@x}{\the\pgf@y}}%
  \expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter\pgf@arrows@convexhull\expandafter\expandafter\expandafter{\pgf@arrows@temp}%
}

\def\pgfarrowssettipend#1{\pgf@x#1\edef\pgf@arrows@the@tipend{\the\pgf@x}}
\def\pgfarrowssetbackend#1{\pgf@x#1\edef\pgf@arrows@the@backend{\the\pgf@x}}
\def\pgfarrowssetlineend#1{\pgf@x#1\edef\pgf@arrows@the@lineend{\the\pgf@x}}
\def\pgfarrowssetrigidtipend#1{\pgf@x#1\edef\pgf@arrows@the@rigidtipend{\the\pgf@x}}
\def\pgfarrowssetridigbackend#1{\pgf@x#1\edef\pgf@arrows@the@rigidbackend{\the\pgf@x}}


% Compute the line end (shortening) for an arrow 
% 
% #1 = arrow tip list
% 
% Description:
% 
% \pgf@xa will contain the necessary path shortening for the given
% arrow tip list, \pgf@xb will contain the total length of the arrow
% tip list (sum of the differences between tip end and back end plus
% the seps).

\def\pgf@arrow@compute@shortening#1{%
  \let\pgf@arrow@handle\pgf@arrow@compute@shortening@
  \let\pgf@arrow@handle@dot\pgf@arrow@after@line@endtrue%
  \pgf@arrow@after@line@endfalse%
  \pgf@xa0pt%
  \pgf@xb0pt%
  #1%
}
\newif\ifpgf@arrow@after@line@end

\def\pgf@arrow@compute@shortening@#1#2{%
  {\pgfarrows@getid{#1}{#2}}%
  \expandafter\expandafter\expandafter\pgf@arrow@cont@short\csname pgf@ar@ends@\pgf@arrow@id\endcsname%
}
\def\pgf@dot@text{.}

\def\pgf@arrow@cont@short#1#2#3#4{% tip end, back end, line end, sep
  \advance\pgf@xb by#1%
  \pgf@xc#2%
  \advance\pgf@xb by-\pgf@xc%
  \advance\pgf@xb by#4%
  \ifpgf@arrow@after@line@end%
    \advance\pgf@xa by#1%
    \advance\pgf@xa by#4%
    \pgf@xc#2%
    \advance\pgf@xa by-\pgf@xc%
  \else%
    \pgf@xa#1%
    \advance\pgf@xa by#4%
    \pgf@xc#3%
    \advance\pgf@xa by-\pgf@xc%
  \fi%
}


% Draw an arrow
% 
% #1 = arrow tip list
% #2 = total length of the arrow (the value of \pgf@xb computed by
% \pgf@arrow@compute@shortening)
% #3 = a transformation relative to a reset cm.
% 
% Description:
% 
% Draws an arrow tip list. The coordinate system must have been
% transformed so that the to-be-drawn arrow points right and should
% "end" at the origin.

\def\pgf@arrow@draw@arrow#1#2{%
  {%
    \pgf@xb=#2%
    \pgftransformxshift{-\pgf@xb}%
    \let\pgf@arrow@handle\pgf@arrow@drawer
    \let\pgf@arrow@handle@dot\relax%
    #1%
  }%
}


\def\pgf@arrow@drawer#1#2{%
  % Prepare:
  {%
    \pgfarrows@getid{#1}{#2}%
    % Do shift:
    \expandafter\expandafter\expandafter\pgf@arrow@drawer@shift\csname pgf@ar@ends@\pgf@arrow@id\endcsname%
    % do swap:
    \ifpgfarrowswap%
      \pgftransformyscale{-1}%
    \fi%
    {%
      \csname pgf@ar@saves@\pgf@arrow@id\endcsname%
      \pgfscope\pgflowlevelsynccm\csname pgf@ar@cache@\pgf@arrow@id\endcsname\endpgfscope%
      \pgf@arrows@rigid@hull%
    }%  
  \expandafter}%
  % Transform to next tip:
  \expandafter\pgftransformxshift\expandafter{\the\pgf@xc}%
}

\def\pgf@arrow@drawer@shift#1#2#3#4{% tip end, back end, line end, sep
  \pgf@xb#2\pgftransformxshift{-\pgf@xb}%
  \pgf@xc#1%
  \advance\pgf@xc by#4%
  \advance\pgf@xc by-\pgf@xb%
}

\def\pgf@arrows@rigid@hull{%
  \ifpgfoverlayarrowtips\else%
    % Do bb update:
    \expandafter\let\expandafter\pgf@temp\csname pgf@ar@hull@\pgf@arrow@id\endcsname%
    \ifx\pgf@temp\pgfutil@empty\else%
      \let\pgf@arrow@hull@point\pgf@arrow@hull@point@first%
      \pgf@temp%
      \pgf@arrow@update@bb%
    \fi%
  \fi%  
}


% If set to true, arrow tips do not count for the picture size
% (behaviour in old versions). Switched off by default.

\newif\ifpgfoverlayarrowtips


% Convex hull stuff:

\def\pgf@arrow@hull@point@first#1#2{%
  \pgf@x#1\pgf@y#2%
  \pgf@xa\pgf@pt@aa\pgf@x%
  \advance\pgf@xa by\pgf@pt@ba\pgf@y%
  \pgf@ya\pgf@pt@ab\pgf@x%
  \advance\pgf@ya by\pgf@pt@bb\pgf@y%
  \pgf@xb\pgf@xa\pgf@yb\pgf@ya%
  \let\pgf@arrow@hull@point\pgf@arrow@hull@point@other%
}
\def\pgf@arrow@hull@point@other#1#2{%
  \pgfutil@tempdima#1\pgfutil@tempdimb#2%
  \pgf@x\pgf@pt@aa\pgfutil@tempdima%
  \advance\pgf@x by\pgf@pt@ba\pgfutil@tempdimb%
  \pgf@y\pgf@pt@ab\pgfutil@tempdima%
  \advance\pgf@y by\pgf@pt@bb\pgfutil@tempdimb%
  \ifdim\pgf@x<\pgf@xa\pgf@xa\pgf@x\else\ifdim\pgf@x>\pgf@xb\pgf@xb\pgf@x\fi\fi%
  \ifdim\pgf@y<\pgf@ya\pgf@ya\pgf@y\else\ifdim\pgf@y>\pgf@yb\pgf@yb\pgf@y\fi\fi%
}

\def\pgf@arrow@update@bb{%
  \advance\pgf@xa by\pgf@pt@x%
  \advance\pgf@ya by\pgf@pt@y%
  \advance\pgf@xb by\pgf@pt@x%
  \advance\pgf@yb by\pgf@pt@y%
  \ifdim\pgf@picmaxx=-16000pt\relax%
    \global\pgf@picminx\pgf@xa%
    \global\pgf@picmaxx\pgf@xb%
    \global\pgf@picminy\pgf@ya%
    \global\pgf@picmaxy\pgf@yb%
  \else%
    \ifdim\pgf@xa<\pgf@picminx\global\pgf@picminx\pgf@xa\fi%
    \ifdim\pgf@ya<\pgf@picminy\global\pgf@picminy\pgf@ya\fi%
    \ifdim\pgf@xb>\pgf@picmaxx\global\pgf@picmaxx\pgf@xb\fi%
    \ifdim\pgf@yb>\pgf@picmaxy\global\pgf@picmaxy\pgf@yb\fi%
  \fi%
}


% Sets arrows
%
% #1 = An arrow specification of the form ``left''-``right''. The last
%      and right should be arrow types that have been defined using
%      the \pgfarrowsdef command
%
% Example:
%
% \pgfsetarrows{-to}

\def\pgfsetarrows#1{\pgf@arrows#1\pgf@stop}
\def\pgf@arrows#1-#2\pgf@stop{%
  \pgfsetarrowsstart{#1}%
  \pgfsetarrowsend{#2}%
}







%
% Predefined arrows:
% 


% A dot is used to indicate the end of the line:

\pgfdeclarearrow{
  name = .
}


% An underscore adds a space as in >_> or >_Â >. However, it will be
% faster to say ">[sep] >" or ">[sep=2pt] >".

\pgfdeclarearrow{
  name = _,
  defaults = {sep}
}



% Generic "latex-like" arrow tip

\pgfdeclarearrow{
  name = Latex,
  defaults = {
    length=2.8pt 3 .4,
    width=0pt .375,
  },
  setup = {
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowlength
    \pgfarrowssavethe\pgfarrowwidth
    % Infos:
    \pgfarrowssettipend{\pgfarrowlength}
    \pgfarrowssetlineend{.1\pgfarrowlength}
    % The hull:
    \pgfarrowshullpoint{\pgfarrowlength}{0pt}%
    \pgfarrowshullpoint{0pt}{\pgfarrowwidth}%
    \pgfarrowshullpoint{0pt}{-\pgfarrowwidth}%
  },
  code = {
    \pgfpathmoveto    {\pgfqpoint{\pgfarrowlength}{0pt}}
    \pgfpathcurveto   {\pgfqpoint{.73333\pgfarrowlength}{.133333\pgfarrowwidth}}
                      {\pgfqpoint{.3\pgfarrowlength}{.533333\pgfarrowwidth}}
                      {\pgfqpoint{0pt}{\pgfarrowwidth}}
    \pgfpathlineto    {\pgfqpoint{0pt}{-\pgfarrowwidth}}
    \pgfpathcurveto   {\pgfqpoint{.3\pgfarrowlength}{-.533333\pgfarrowwidth}}
                      {\pgfqpoint{.73333\pgfarrowlength}{-.133333\pgfarrowwidth}}
                      {\pgfqpoint{\pgfarrowlength}{0pt}}
    \pgfpathclose
    \pgfusepathqfill
  },
  parameters = {
    \the\pgfarrowlength,%
    \the\pgfarrowwidth
  },
}

\pgfkeys {
  latex/.tip          = Latex,
  latex reversed/.tip = Latex[reversed]
}



% An arrow similar to the $\to$ arrow
% 
% Need to work on this...

\pgfdeclarearrow{
  name = to,
  setup = 
  {
    \pgfutil@tempdima=-0.84pt%
    \advance\pgfutil@tempdima by-1.3\pgflinewidth%
    \pgfutil@tempdimb=0.21pt%
    \advance\pgfutil@tempdimb by.625\pgflinewidth%
    \pgfarrowsleftextend{+\pgfutil@tempdima}
    \pgfarrowsrightextend{+\pgfutil@tempdimb}
  },
  code = 
  {
    \pgfutil@tempdima=0.28pt%
    \advance\pgfutil@tempdima by.3\pgflinewidth%
    \pgfsetlinewidth{0.8\pgflinewidth}
    \pgfsetdash{}{+0pt}
    \pgfsetroundcap
    \pgfsetroundjoin
    \pgfpathmoveto{\pgfqpoint{-3\pgfutil@tempdima}{4\pgfutil@tempdima}}
    \pgfpathcurveto
    {\pgfqpoint{-2.75\pgfutil@tempdima}{2.5\pgfutil@tempdima}}
    {\pgfqpoint{0pt}{0.25\pgfutil@tempdima}}
    {\pgfqpoint{0.75\pgfutil@tempdima}{0pt}}
    \pgfpathcurveto
    {\pgfqpoint{0pt}{-0.25\pgfutil@tempdima}}
    {\pgfqpoint{-2.75\pgfutil@tempdima}{-2.5\pgfutil@tempdima}}
    {\pgfqpoint{-3\pgfutil@tempdima}{-4\pgfutil@tempdima}}
    \pgfusepathqstroke
  }
}


% Default shorthands:

\pgfkeys{
  <->/.tip = to,
  >-</.tip = >[reversed]
}



% Compatibility:

\expandafter\def\csname pgf@arrows@direct@name@start@[\endcsname{\pgf@arrow@handle@shorthand@empty{]}}
\expandafter\def\csname pgf@arrows@direct@name@start@]\endcsname{\pgf@arrow@handle@shorthand@empty{[}}
\expandafter\def\csname pgf@arrows@direct@name@start@spaced [\endcsname{\pgf@arrow@handle@shorthand@empty{spaced ]}}
\expandafter\def\csname pgf@arrows@direct@name@start@spaced ]\endcsname{\pgf@arrow@handle@shorthand@empty{spaced [}}
  
\expandafter\def\csname pgf@arrows@direct@name@end@[\endcsname{\pgf@arrow@handle@shorthand@empty{[}}
\expandafter\def\csname pgf@arrows@direct@name@end@]\endcsname{\pgf@arrow@handle@shorthand@empty{]}}
\expandafter\def\csname pgf@arrows@direct@name@end@spaced [\endcsname{\pgf@arrow@handle@shorthand@empty{spaced [}}
\expandafter\def\csname pgf@arrows@direct@name@end@spaced ]\endcsname{\pgf@arrow@handle@shorthand@empty{spaced ]}}
  

\pgfdeclarearrow{
  name = space,
  means = _
}






% Compatibility stuff with old arrow system:

% Use "parameters" key instead:

\def\pgfsetarrowoptions#1#2{%
  \expandafter\def\csname pgf@arrow@compat@opt@#1\endcsname{#2}%
}

\def\pgfgetarrowoptions#1{%
  \csname pgf@arrow@compat@opt@#1\endcsname%
}

\def\pgfarrowsdeclare#1#2#3#4{%
  \pgfdeclarearrow{
    name  ={#1}-{#2},
    setup ={#3},
    code  ={#4},
    parameters/.expand once={\csname pgf@arrow@compat@opt@#2\endcsname}
  }  
  \expandafter\def\csname pgf@arrow@compat@opt@#2\endcsname{0}%
}

\def\pgfarrowsleftextend#1{\pgfmathsetlength\pgf@xa{#1}\pgfarrowssetbackend{\pgf@xa}}
\def\pgfarrowsrightextend#1{\pgfmathsetlength\pgf@xb{#1}\pgfarrowssettipend{\pgf@xb}}

\def\pgfarrowsdeclarealias#1#2#3#4{%
  \pgfdeclarearrow{%
    name  ={#1}-{#2},
    means ={#4}
  }
}

\def\pgfarrowsdeclarereversed#1#2#3#4{%
  \pgfdeclarearrow{%
    name ={#1}-{#2},
    means={{#4}[reversed]}
  }
}

\def\pgfarrowsdeclarecombine{\pgfutil@ifnextchar*{\pgfarrowsdeclarecombine@star}{\pgf@@arrowsdeclarecombine}}

\def\pgf@@arrowsdeclarecombine{\pgfutil@ifnextchar[{\pgf@arrowsdeclarecombine}{\pgf@arrowsdeclarecombine[0pt]}}
\def\pgf@arrowsdeclarecombine[#1]#2#3#4#5#6#7{%
  \pgfdeclarearrow{%
    name ={#2}-{#3},
    means={#5[sep=#1]#6}
  }
}
\def\pgfarrowsdeclarecombine@star*{\pgfutil@ifnextchar[{\pgf@arrowsdeclarecombine@star}{\pgf@arrowsdeclarecombine@star[0pt]}}
\def\pgf@arrowsdeclarecombine@star[#1]#2#3#4#5#6#7{%
  \pgfdeclarearrow{%
    name ={#2}-{#3},
    means={#5[sep=#1].#6}
  }
}

\def\pgfarrowsdeclaredouble{\pgfutil@ifnextchar[{\pgf@arrowsdeclaredouble}{\pgf@arrowsdeclaredouble[0pt]}}
\def\pgf@arrowsdeclaredouble[#1]#2#3#4#5{\pgfarrowsdeclarecombine[#1]{#2}{#3}{#4}{#5}{#4}{#5}}
\def\pgfarrowsdeclaretriple{\pgfutil@ifnextchar[{\pgf@arrowsdeclaretriple}{\pgf@arrowsdeclaretriple[0pt]}}
\def\pgf@arrowsdeclaretriple[#1]#2#3#4#5{%
  \pgfarrowsdeclarecombine[#1]{pgf@trip@#2}{pgf@trip@#3}{#4}{#5}{#4}{#5}%
  \pgfarrowsdeclarecombine[#1]{#2}{#3}{pgf@trip@#2}{pgf@trip@#3}{#4}{#5}%
}



% A stealth-fighter-like pointed arrow
%
% Example:
%
% \pgfsetarrows{-stealth}

\pgfarrowsdeclare{stealth}{stealth}
{
  \pgfutil@tempdima=0.28pt%
  \pgfutil@tempdimb=\pgflinewidth%
  \ifdim\pgfinnerlinewidth>0pt%
    \pgfmathsetlength\pgfutil@tempdimb{.6\pgflinewidth-.4*\pgfinnerlinewidth}%
  \fi%
  \advance\pgfutil@tempdima by.3\pgfutil@tempdimb%
  \pgfarrowsleftextend{+-3\pgfutil@tempdima}
  \pgfarrowsrightextend{+5\pgfutil@tempdima}
}
{
  \pgfutil@tempdima=0.28pt%
  \pgfutil@tempdimb=\pgflinewidth%
  \ifdim\pgfinnerlinewidth>0pt%
    \pgfmathsetlength\pgfutil@tempdimb{.6\pgflinewidth-.4*\pgfinnerlinewidth}%
  \fi%
  \advance\pgfutil@tempdima by.3\pgfutil@tempdimb%
  \pgfpathmoveto{\pgfqpoint{5\pgfutil@tempdima}{0pt}}
  \pgfpathlineto{\pgfqpoint{-3\pgfutil@tempdima}{4\pgfutil@tempdima}}
  \pgfpathlineto{\pgfpointorigin}
  \pgfpathlineto{\pgfqpoint{-3\pgfutil@tempdima}{-4\pgfutil@tempdima}}
  \pgfpathclose
  \pgfusepathqfill
}

\pgfarrowsdeclarereversed{stealth reversed}{stealth reversed}{stealth}{stealth}

\pgfarrowsdeclare{to reversed}{to reversed}
{
  \pgfutil@tempdima=-0.21pt%
  \advance\pgfutil@tempdima by-0.475\pgflinewidth%
  \pgfutil@tempdimb=0.98pt%
  \advance\pgfutil@tempdimb by1.45\pgflinewidth%
  \pgfarrowsleftextend{+\pgfutil@tempdima}
  \pgfarrowsrightextend{+\pgfutil@tempdimb}
}
{
  \pgfutil@tempdima=0.28pt%
  \advance\pgfutil@tempdima by.3\pgflinewidth%
  \pgfsetlinewidth{+0.8\pgflinewidth}
  \pgfsetdash{}{+0pt}
  \pgfsetroundcap
  \pgfsetroundjoin
  \pgfpathmoveto{\pgfqpoint{3.5\pgfutil@tempdima}{4\pgfutil@tempdima}}
  \pgfpathcurveto
  {\pgfqpoint{3.25\pgfutil@tempdima}{2.5\pgfutil@tempdima}}
  {\pgfqpoint{0.5\pgfutil@tempdima}{0.25\pgfutil@tempdima}}
  {\pgfqpoint{-0.25\pgfutil@tempdima}{0\pgfutil@tempdima}}
  \pgfpathcurveto
  {\pgfqpoint{0.5\pgfutil@tempdima}{-0.25\pgfutil@tempdima}}
  {\pgfqpoint{3.25\pgfutil@tempdima}{-2.5\pgfutil@tempdima}}
  {\pgfqpoint{3.5\pgfutil@tempdima}{-4\pgfutil@tempdima}}
  \pgfusepathqstroke
}



% A bar shaped arrow
%
% Example:
%
% \pgfsetarrows{-|}

\pgfarrowsdeclare{|}{|}
{
  \pgfarrowsleftextend{+-0.25\pgflinewidth}
  \pgfarrowsrightextend{+.75\pgflinewidth}
}
{
  \pgfutil@tempdima=2pt%
  \advance\pgfutil@tempdima by1.5\pgflinewidth%
  \pgfsetdash{}{+0pt}
  \pgfsetrectcap
  \pgfpathmoveto{\pgfqpoint{0.25\pgflinewidth}{-\pgfutil@tempdima}}
  \pgfpathlineto{\pgfqpoint{0.25\pgflinewidth}{\pgfutil@tempdima}}
  \pgfusepathqstroke
}




\endinput


