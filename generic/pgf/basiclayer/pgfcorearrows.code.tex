% Copyright 2006, 2013 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS $Header$



% Define a new (meta) arrow or a shorthand
%
% #1 = key--value pairs
%
% Description:
%
% This command is used to define a new arrow tip kind. For more
% details on the description of the keys, please see the pgfmanual.
% 
% name         = Name of the arrow. If the name contains a dash
%                (hyphen), the text before the hyphen is the start name
%                and the text behind it the end name.
%
% means        = If set, none of the below options may be
%                given. The effect is that whenever the arrow is
%                used, it gets replaced by this "text", which is
%                parsed by the parser.
%
% setup        = Code that does "precomputations". These will be
%                executed only once for each combination of the
%                dependencies. At the end of this code, you can use
%                \savethe and \save to "save" computed values, which
%                will then be available inside the "code". Values needed
%                only for the "... end" keys and the convex hull do not
%                need to be saved since these are also executed only
%                once. 
% code         = Code for drawing the arrow. When the cache key is set to
%                true, which is the default, the code will be protocolled
%                and the resulting code is inserted using \pgflowlevelobj.
% cache        = Boolean that decides whether the arrow can be cached. The
%                default is true, so you have to say cache=false to switch
%                caching off. In this case, each time the arrow is drawn,
%                its code is simply executed. This allows you to put things
%                like text or shadings in arrow tips.
% bending mode = Can be set to "orthogonal", "polar", or
%                "none". Defaults to "orthogonal".
% defaults     = A list of "default" options for the arrow tip. These
%                are executed as if they were given to the arrow tip in
%                brackets. This is useful for setting up default values.
% parameters   = A list of comma-separated macro names on whose values
%                the appearance of the arrow tip depends. When an arrow
%                tip is used, these macros are expanded. If an
%                arrow tip was already installed with the same macro
%                names (and caching is true), the cached code is
%                used. Note that when you use dimensions here, add \the.
%               
% Inside the setup code, the following macros are available:               
%
% \pgfarrowsettipend
%              The code should draw an arrow pointing "right along the x
%              axis". The "tip" key specifies how far the arrow goes
%              along the x axis, that is, it should be the x coordinate
%              of the very tip of the arrow. In previous versions this
%              was called the "right extend". The value passed to this
%              key should be some code that sets the dimension
%              "\pgfarrowresult", which is \let to be equal to
%              \pgf@x. A \relax will be added after the code provided
%              here, so you can write things like "\pgfarrowresult=1pt".
% \pgfarrowsetbackend
%              The leftmost x-coordinate that is still part of the
%              arrow tip (the "back end" of the arrow"). This coordinate
%              will be used when multiple arrow tips are
%              composed. Defaults to 0pt.
% \pgfarrowsetlineend
%              The x-coordinate where a line should stop inside the arrow
%              tip so that it gets "obscured" by the arrow. Defaults to 0pt.
% \pgfarrowsetrigidtipend
%              When the arrow tip is drawn "rigidly", it is rotated
%              such that the x-coordinates of "rigid tip end" and "rigid
%              back end" lie on the path. Defaults to \pgfarrowsettipend.
% \pgfarrowsetrigidbackend
%              See above. Defaults to \pgfarrowsetbackend

\def\pgfdeclarearrow#1{%
  \let\pgf@decl@arrow@defaults\pgfutil@empty%
  \pgfkeys{/pgf/@arrows decl/.cd,
    name=,
    means=,
    setup=,
    code=,
    cache=true,
    bending mode=orthogonal,
    parameters=,%
    #1%
  }%
  \ifx\pgf@decl@arrow@name@end\pgfutil@empty%
    \pgferror{Declaring unnamed arrow}%
  \else%
    \pgf@arrow@letter{name@end}%
    \pgf@arrow@letter{name@start}%
    \expandafter\let\csname pgf@ar@start@\pgf@decl@arrow@name@start\endcsname\pgf@decl@arrow@name@end%
    \ifx\pgf@decl@arrow@means\pgfutil@empty%
      \pgf@arrow@letter{code}%
      \pgf@arrow@letter{defaults}%
      \pgf@arrow@letter{setup}%
      \pgf@arrow@letter{bending@mode}%
      \pgf@arrow@letter{par}%
    \else%
      \let\pgf@arrow@tip@sequence\pgfutil@empty%
      \let\pgf@arrow@translate\relax%
      \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@end@\pgf@decl@arrow@means\endcsname%
      \ifx\pgf@arrows@direct\relax%
        \let\pgf@arrows@options\pgfutil@empty%
        \expandafter\pgfarrows@initial@parser\pgf@decl@arrow@means[]\pgf@stop%
      \else%
        \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
      \fi%
      \pgf@arrow@letter@\pgf@arrow@tip@sequence{means}%
    \fi%
  \fi%
}

\def\pgf@arrow@letter#1{%
  \expandafter\pgf@arrow@letter@\expandafter{\csname pgf@decl@arrow@#1\endcsname}{#1}%
}
\def\pgf@arrow@letter@#1#2{%
  \expandafter\let\csname pgf@ar@#2@\pgf@decl@arrow@name@end\endcsname#1%
}

\pgfkeys{
  /pgf/@arrows decl/.cd,
  name/.code={%
    \pgfutil@in@-{#1}%
    \ifpgfutil@in@%
      \pgf@arrows@name@decomp#1\pgf@stop%
    \else%
      \def\pgf@decl@arrow@name@end{#1}\let\pgf@decl@arrow@name@start\pgf@decl@arrow@name@end%
    \fi},
  means/.store in=\pgf@decl@arrow@means,
  setup/.store in=\pgf@decl@arrow@setup,
  code/.store in=\pgf@decl@arrow@code,
  cache/.is if=pgf@decl@arrow@cache,
  bending mode/.is choice,
  bending mode/none/.code=\let\pgf@decl@arrow@bending@mode\pgfutil@empty,
  bending mode/orthogonal/.code=\def\pgf@decl@arrow@bending@mode{\pgfpointcurvilinearbezierorthogonal},
  bending mode/polar/.code=\def\pgf@decl@arrow@bending@mode{\pgfpointcurvilinearbezierpolar},
  parameters/.store in=\pgf@decl@arrow@par,
  defaults/.code={%
    \let\pgf@arrows@options\pgfutil@empty%
    \pgfkeys{/pgf/@arrows/.cd,#1}%
    \let\pgf@decl@arrow@defaults\pgf@arrows@options%
  }
}

\newif\ifpgf@decl@arrow@cache

\def\pgf@arrows@name@decomp#1-#2\pgf@stop{%
  \def\pgf@decl@arrow@name@start{#1}%
  \def\pgf@decl@arrow@name@end{#2}%
}


% Handler for defining arrow tips:
% 
% Description:
% 
% When you write "my name/.tip = arrow spec", this has the same
% effect as writeing \pgfdeclarearrow{name = my name, means = arrow spec}.

\pgfkeys{/handlers/.tip/.code=%
  \expandafter\expandafter\expandafter\pgf@arrows@unravel\pgfkeyscurrentpath/\pgf@stop%
  \expandafter\pgf@arrows@key@call\expandafter{\pgf@arrows@unravelled}{#1}}
\def\pgf@arrows@unravel#1/{\pgfutil@ifnextchar\pgf@stop{\def\pgf@arrows@unravelled{#1}\pgfutil@gobble}{\pgf@arrows@unravel}}
\def\pgf@arrows@key@call#1#2{\pgfdeclarearrow{name={#1},means={#2}}}




% Draw an arrow
% 
% #1 = arrow specification
% 
% Description:
% 
% Draws the arrow in the given specification (and "end"
% specification). The arrow will be drawn such that it touches the
% origin "from the left", that is, the arrow will lie completely in
% the half plane with negative $x$ values and the tip will end exactly
% at the origin.

\def\pgfarrowdraw#1{%
  {%
    \pgfsetarrowsend{#1}%
    \pgf@arrow@compute@shortening\pgf@end@tip@sequence%
    \pgf@arrow@draw@arrow\pgf@end@tip@sequence\pgf@xb%
  }%
}



% Compute the length of an arrow
% 
% #1 = arrow specification
% 
% Description:
% 
% In \pgf@x, this will return the total length of the arrow given as
% #1, in \pgf@xa it will return the distance from the tip to the line
% end. 

\def\pgfarrowtotallength#1{%
  {%
    \pgfsetarrowsend{#1}%
    \pgf@arrow@compute@shortening\pgf@end@tip@sequence%
    \expandafter\expandafter\expandafter%
  }%
  \expandafter\expandafter\expandafter\pgf@x\expandafter\the\expandafter\pgf@xb\expandafter\pgf@xa\the\pgf@xa%
}





% Sets the end arrow tip
%
% #1 = An arrow specification
%
% Description:
% 
% An "arrow specification" is a sequence of names of meta arrow tips
% together with options in brackets. In detail:
% 
% In #1, consider the text from the start up to the first bracket. If
% this text is the name of a (meta) arrow tip, we use this arrow tip
% with the provided options. If it is the name of a arrow tip
% shorthand, this shorthand is expanded and the options are applied to
% each arrow tip inside the shorthand. If the text is neither or the
% above, the first letter of text is treated as a shorthand without
% options.
% 
% The special arrow tip "." is used to indicate the end of the line. 
%
% \pgfsetarrowsend{stealth[reversed]}
% \pgfsetarrowsend{stealth[length=1pt] . stealth[length=2pt]}
% \pgfsetarrowsend{>>>}
% \pgfsetarrowsend{>.>}

\def\pgfsetarrowsend#1{%
  \let\pgf@arrow@tip@sequence\pgfutil@empty%
  \pgf@arrows@translatefalse%
  \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@end@#1\endcsname%
  \ifx\pgf@arrows@direct\relax%
    \edef\pgf@marshal{\noexpand\pgfarrows@initial@parser#1[]\noexpand\pgf@stop}%
    \pgf@marshal%
  \else%
    \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
  \fi%
  \let\pgf@end@tip@sequence\pgf@arrow@tip@sequence%
}

\newif\ifpgf@arrows@translate

\def\pgfarrows@initial@parser{%
  \pgfutil@ifnextchar[\pgfarrows@initial@parser@{\pgfarrows@initial@parser@[]}}%}
\def\pgfarrows@initial@parser@[#1]{%
  \pgfkeys{/pgf/@arrows/.cd,#1}%
  \pgfarrows@parser%
}

\def\pgfarrows@parser#1[{%
  \pgfkeys@spdef\pgf@temp{#1}%
  \ifx\pgf@temp\pgfutil@empty%
    \let\pgf@next\pgf@arrows@empty%
  \else%
    \ifx\pgf@temp\pgf@dot@text%
      \let\pgf@next\pgf@arrows@dot@parsed%
    \else%
      \let\pgf@untranslated\pgf@temp%
      \ifpgf@arrows@translate%
        \pgf@arrow@swapper%
      \fi%
      % Now, let's see what we do with this...
      \expandafter\ifx\csname pgf@ar@code@\pgf@temp\endcsname\relax
        \expandafter\ifx\csname pgf@ar@means@\pgf@temp\endcsname\relax
          % #1 should start with a single-char shorthands
          \let\pgf@next\pgf@arrows@single@char@parser%
          \let\pgf@temp\pgf@untranslated%
        \else%
          % #1 is a shorthand!
          \let\pgf@next\pgf@arrows@shorthand@parsed%
        \fi%
      \else%
        % #1 is a meta arrow!
        \let\pgf@next\pgf@arrows@meta@parsed%
      \fi%
    \fi%
  \fi%
  \expandafter\pgf@next\pgf@temp[%  
}

\def\pgf@arrows@empty[#1]{%
  \pgfutil@ifnextchar\pgf@stop\pgf@arrows@parser@done\pgfarrows@parser%  
}

\def\pgf@arrows@single@char@parser#1{%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\pgf@dot@text%
    \let\pgf@next\pgf@arrows@dot@parsed%
  \else%
    \let\pgf@untranslated\pgf@temp%
    \ifpgf@arrows@translate%
      \pgf@arrow@swapper%
    \fi%
    \expandafter\ifx\csname pgf@ar@code@\pgf@temp\endcsname\relax
      \expandafter\ifx\csname pgf@ar@means@\pgf@temp\endcsname\relax
        \let\pgf@temp\pgf@untranslated%
        \let\pgf@next\pgf@arrows@unknown%
      \else%
        \let\pgf@next\pgf@arrows@shorthand@parsed%  
      \fi%
    \else%
      \let\pgf@next\pgf@arrows@meta@parsed%  
    \fi
  \fi
  \expandafter\pgf@next\pgf@temp[]%  
}
\def\pgf@arrows@unknown#1[]#2[#3]{%
  \pgferror{Unknown arrow tip kind '#1#2'}%
}

\def\pgf@arrows@meta@parsed#1[#2]{%
  % Ok, run the keys #2. This will add commands to \pgf@arrows@options:
  % 
  \let\pgf@arrows@options\pgfutil@empty%
  \pgfkeys{/pgf/@arrows/.cd,#2}%
  % Append the arrow and its options to the arrow tip sequence:
  \expandafter\pgf@arrows@meta@set\expandafter{\pgf@arrows@options}{#1}{\pgf@arrow@handle}%
  \pgfutil@ifnextchar\pgf@stop\pgf@arrows@parser@done\pgfarrows@parser%  
}

\def\pgf@arrows@parser@done#1{%
}

\def\pgf@arrows@dot@parsed#1[#2]{%
  \pgf@arrows@append@to@tips{\pgf@arrow@handle@dot}%
  \pgfutil@ifnextchar\pgf@stop\pgf@arrows@parser@done\pgfarrows@parser%  
}

\def\pgf@arrows@meta@set#1#2#3{%
  \pgf@arrows@append@to@tips{#3{#2}{#1}}%
}
\def\pgf@arrows@append@to@tips#1{%
  \let\pgf@tempa\pgf@arrow@tip@sequence%
  \def\pgf@tempb{#1}%
  \ifpgf@arrows@translate%
    \let\pgf@tempa\pgf@tempb%
    \let\pgf@tempb\pgf@arrow@tip@sequence%
  \fi%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrow@tip@sequence%
  \expandafter\expandafter\expandafter{\expandafter\pgf@tempa\pgf@tempb}%  
}

\def\pgf@arrows@shorthand@parsed#1[#2]{%
  \let\pgf@arrows@options\pgfutil@empty%
  \pgfkeys{/pgf/@arrows/.cd,#2}%
  \ifx\pgf@arrows@options\pgfutil@empty%
    \expandafter\pgf@arrows@append@to@tips\expandafter{%
      \expandafter\pgf@arrow@handle@shorthand@empty\expandafter{\csname pgf@ar@means@#1\endcsname}}%
  \else%
    \expandafter\expandafter\expandafter\pgf@arrows@meta@set\expandafter\expandafter\expandafter{%
      \expandafter\pgf@arrows@options\expandafter}\expandafter{\csname pgf@ar@means@#1\endcsname}{\pgf@arrow@handle@shorthand}%
  \fi%
  \pgfutil@ifnextchar\pgf@stop\pgf@arrows@parser@done\pgfarrows@parser%  
}


% General handler:

\def\pgf@arrow@handle@shorthand@empty#1{#1}

\def\pgf@arrow@handle@shorthand#1#2{%
  \def\pgf@temp@opt{#2}%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@nested@options@temp%
  \expandafter\expandafter\expandafter{\expandafter\pgf@temp@opt\pgf@arrows@nested@options}%
  \expandafter\let\expandafter\pgf@arrows@nested@options\expandafter\pgf@arrows@nested@options@temp%
  \expandafter#1% all these expandafters to avoid creating groups, but having the options nest
  \expandafter\def\expandafter\pgf@arrows@nested@options\expandafter{\pgf@arrows@nested@options}%
}

\let\pgf@arrows@nested@options\pgfutil@empty




% Sets the start arrow tip
%
% #1 = An arrow specification
%
% Description:
% 
% This works like \pgfsetarrowsend, only the order of the tips in the
% arrow specification is reversed and the "reversed names" are used.
%
% \pgfsetarrowsend{<<}
% \pgfsetarrowsend{>.>}

\def\pgfsetarrowsstart#1{%
  \let\pgf@arrow@tip@sequence\pgfutil@empty%
  \pgf@arrows@translatetrue%
  \expandafter\let\expandafter\pgf@arrows@direct\csname pgf@arrows@direct@name@start@#1\endcsname%
  \ifx\pgf@arrows@direct\relax%
    \edef\pgf@marshal{\noexpand\pgfarrows@initial@parser#1[]\noexpand\pgf@stop}%
    \pgf@marshal%
  \else%
    \let\pgf@arrow@tip@sequence\pgf@arrows@direct%
  \fi%
  \let\pgf@start@tip@sequence\pgf@arrow@tip@sequence%
}

\def\pgf@arrow@swapper{%
  \expandafter\let\expandafter\pgf@temp\csname pgf@ar@start@\pgf@temp\endcsname%
  \ifx\pgf@temp\relax%
    \def\pgf@temp{undefined}%
  \fi%
}

\let\pgf@start@tip@sequence\pgfutil@empty
\let\pgf@end@tip@sequence\pgfutil@empty


\expandafter\def\csname pgf@arrows@direct@name@start@\endcsname{}
\expandafter\def\csname pgf@arrows@direct@name@end@\endcsname{}


% Predefined lengths and ifs

\newdimen\pgfarrowinset
\newdimen\pgfarrowlength
\newdimen\pgfarrowwidth
\newdimen\pgfarrowsep

\newif\ifpgfarrowswap
\newif\ifpgfarrowreversed
\newif\ifpgfarrowharpoon

\let\pgf@arrows@stroke@color\pgfutil@empty
\let\pgf@arrows@fill@color\pgfutil@empty

\pgfkeys{
  /pgf/@arrows/.cd,
  length/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtooptions\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\pgfarrowlength\pgf@x}%
  },
  inset/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtolateoptions\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\pgfarrowinset\pgf@x}%
  },
  inset'/.code={
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtolateoptions\expandafter{\expandafter\pgfarrowslengthdependent\pgfarrowstheparameters\pgfarrowinset}%
  },
  width/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtolateoptions\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\pgfarrowwidth\pgf@x}%
  },
  width'/.code={%
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtolateoptions\expandafter{\expandafter\pgfarrowslengthdependent\pgfarrowstheparameters\pgfarrowwidth}%
  },
  angle/.code={%
    \pgfarrowsfourparameters{#1}%
    \expandafter\pgfarrowsaddtooptions\expandafter{\expandafter\pgfarrows@angle@setup\pgfarrowstheparameters}%
  },
  angle'/.code={
    \pgfarrowsaddtolateoptions{\pgfarrows@angle@setup@prime{#1}}%
  },
  sep/.code={
    \pgfarrowsthreeparameters{#1}%
    \expandafter\pgfarrowsaddtooptions\expandafter{\expandafter\pgfarrowslinewidthdependent\pgfarrowstheparameters\pgfarrowsep\pgf@x}%
  },
  sep/.default=0.88pt .3 1,
  %
  swap/.code=\pgfarrowsaddtooptions{\ifpgfarrowswap\pgfarrowswapfalse\else\pgfarrowswaptrue\fi},
  reversed/.code=\pgfarrowsaddtooptions{\ifpgfarrowreversed\pgfarrowreversedfalse\else\pgfarrowreversedtrue\fi},
  harpoon/.code=\pgfarrowsaddtooptions{\pgfarrowharpoontrue},
  color/.code=\pgfarrowsaddtooptions{\def\pgf@arrows@stroke@color{#1}},
  fill/.code=\pgfarrowsaddtooptions{\def\pgf@arrows@fill@color{#1}},
  .unknown/.code={ 
    \expandafter\pgfutil@in@\expandafter!\expandafter{\pgfkeyscurrentname}%
    \ifpgfutil@in@%
      % this is a color!
      \expandafter\pgfarrowsaddtooptions\expandafter{\expandafter\def\expandafter\pgf@arrows@stroke@color\expandafter{\pgfkeyscurrentname}}%
    \else%
      \pgfutil@doifcolorelse{\pgfkeyscurrentname}
      {%     
        \expandafter\pgfarrowsaddtooptions\expandafter{\expandafter\def\expandafter\pgf@arrows@stroke@color\expandafter{\pgfkeyscurrentname}}%
      }
      {%
        \pgfkeys{/errors/unknown key/.expand
          once=\expandafter{\pgfkeyscurrentname}{#1}%
        }%
      }
      \fi
    }
}

\def\pgfarrowsaddtooptions#1{\expandafter\def\expandafter\pgf@arrows@options\expandafter{\pgf@arrows@options#1}}
\def\pgfarrowsaddtolateoptions#1{\expandafter\def\expandafter\pgf@arrows@options\expandafter{\pgf@arrows@options\pgf@arrows@add@to@late@options{#1}}}
\def\pgf@arrows@add@to@late@options#1{\expandafter\def\expandafter\pgf@arrows@late@options\expandafter{\pgf@arrows@late@options#1}}

\def\pgfarrowsthreeparameters#1{%
  \pgfarrowsthreeparameters@#1 0 0 0 \pgf@stop%
}
\def\pgfarrowsthreeparameters@#1 #2 #3 #4\pgf@stop{%
  \pgfmathsetlength\pgf@x{#1}%
  \edef\pgfarrowstheparameters{{\the\pgf@x}{#2}{#3}}%
}

\def\pgfarrowsfourparameters#1{%
  \pgfarrowsfourparameters@#1 0 0 0 \pgf@stop%
}
\def\pgfarrowsfourparameters@#1:#2 #3 #4 #5\pgf@stop{%
  \pgfmathsetlength\pgf@x{#2}%
  \edef\pgfarrowstheparameters{{#1}{\the\pgf@x}{#3}{#4}}%
}

\def\pgfarrows@angle@setup#1#2#3#4{%
  \pgfarrowslinewidthdependent{#2}{#3}{#4}
  \pgf@xc\pgf@x
  \pgf@yc#1 pt%
  \pgf@yc.5\pgf@yc%
  \pgfpointpolar{\pgf@yc}{\pgf@xc}
  \pgfarrowlength\pgf@x%
  \pgf@y2\pgf@y%
  \expandafter\pgf@arrows@add@to@late@options\expandafter{\expandafter\pgfarrowwidth\the\pgf@y}%
}

\def\pgfarrows@angle@setup@prime#1{%
  \pgf@yc#1 pt%
  \pgfmathtan@{.5\pgf@yc}%
  \pgfarrowwidth\pgfmathresult\pgfarrowlength%
  \pgfarrowwidth2\pgfarrowwidth%
}

\def\pgfarrowslinewidthdependent#1#2#3{%
  \pgf@x#1%
  \ifdim\pgfinnerlinewidth>0pt%
    \pgf@arrows@inner@line@width@dep{#2}{#3}%
  \else%  
    \advance\pgf@x by#2\pgflinewidth%
  \fi%
}
\def\pgf@arrows@inner@line@width@dep#1#2{%
  % #1*((1-#2/2)*full line width - (#2/2) * inner line width)
  % Compute "real" line width
  \pgf@xa\pgflinewidth%
  \pgf@xb-.5\pgflinewidth%
  \pgf@xb#2\pgf@xb%
  \advance\pgf@xa by\pgf@xb%
  \pgf@xb\pgfinnerlinewidth%
  \pgf@xb-.5\pgf@xb
  \advance\pgf@xa by#2\pgf@xb%
  \advance\pgf@x by#1\pgf@xa%
}


\def\pgfarrowslengthdependent#1#2#3#4{%
  #4#1%
  \advance#4by#2\pgfarrowlength%
}



% Build the full name:

\def\pgf@arrow@fullname#1{pgf@@ar@#1@\the\pgflinewidth
  @\pgfinnerlinewidth @\ifpgfarrowreversed r\fi @\pgf@arrows@stroke@color
  @\pgf@arrows@fill@color @\csname pgf@ar@par@#1\endcsname}

\def\pgf@arrow@id@count{0}%


% Compute the arrow id of an arrow
% 
% #1 = arrow name
% #2 = options
% 
% Description:
% 
% Returns the an id in \pgf@arrow@id that identifies the instantiation
% of the given arrow. If the arrow was not instantiated, this happens now.

\def\pgfarrows@getid#1#2{%
  % Execute options:
  \let\pgf@arrows@late@options\pgfutil@empty%
  % 1. Defaults:
  \csname pgf@ar@defaults@#1\endcsname%
  % 2. Scope:
  \pgf@arrows@options@scope
  % 3. Local:
  #2\relax%
  % 4. Nested:
  \pgf@arrows@nested@options% 
  % 5. Last options:
  \pgf@arrows@late@options%
  % Now, test:
  \expandafter\global\expandafter\let\expandafter\pgf@arrow@id\csname\pgf@arrow@fullname{#1}\endcsname\relax%
  \ifx\pgf@arrow@id\relax%
    \pgf@arrows@instantiate{#1}
  \fi%
}

\def\pgf@arrows@instantiate#1{%
  % Not defined. Rats!
  % Allocate new id:
  \pgfutil@tempcnta\pgf@arrow@id@count\relax%
  \advance\pgfutil@tempcnta by1\relax%
  \xdef\pgf@arrow@id@count{\the\pgfutil@tempcnta}%
  \expandafter\global\expandafter\let\csname\pgf@arrow@fullname{#1}\endcsname\pgf@arrow@id@count%
  \global\let\pgf@arrow@id\pgf@arrow@id@count%
  {%
    \csname pgf@ar@setup@#1\endcsname%
    % Handle reversal
    \ifpgfarrowreversed%
      % Compute transformation:
      \pgf@arrows@handle@reverse%
    \fi%
    % Safe computed values
    \expandafter\global\expandafter\let\csname pgf@ar@saves@\pgf@arrow@id\endcsname\pgf@arrows@saves%
    \expandafter\global\expandafter\let\csname pgf@ar@hull@\pgf@arrow@id\endcsname\pgf@arrows@convexhull%
    \expandafter\xdef\csname pgf@ar@ends@\pgf@arrow@id\endcsname{{\pgf@arrows@the@tipend}{\pgf@arrows@the@backend}{\pgf@arrows@the@lineend}}%
    \expandafter\xdef\csname pgf@ar@rigid@\pgf@arrow@id\endcsname{{\pgf@arrows@the@rigidtipend}{\pgf@arrows@the@rigidbackend}}%
    % Save code (needed for bending)
    \edef\pgf@arrow@code{%
      \ifpgfarrowreversed\noexpand\pgftransformxscale{-1}\fi%
      \expandafter\noexpand\csname pgf@ar@code@#1\endcsname%
    }%
    \expandafter\global\expandafter\let\csname pgf@ar@code@\pgf@arrow@id\endcsname\pgf@arrow@code%
    % Should we cache?
    \ifpgf@decl@arrow@cache%
      \pgfsysprotocol@getcurrentprotocol\pgf@arrow@temp%
      {%
        \pgfinterruptpath%
          \let\pgfusepath=\pgf@nousepath@here%
          \pgf@relevantforpicturesizefalse%
          \pgftransformreset%
          \pgfsysprotocol@setcurrentprotocol\pgfutil@empty%
          \pgfsysprotocol@bufferedtrue%
          \pgfscope%
          \pgf@arrow@code%
          \endpgfscope%
          \pgfsysprotocol@getcurrentprotocol\pgf@@arrow@temp%
          \expandafter\gdef\expandafter\pgf@arrow@code\expandafter{\expandafter\pgfsys@invoke\expandafter{\pgf@@arrow@temp}}%
        \endpgfinterruptpath%
      }%
      \pgfsysprotocol@setcurrentprotocol\pgf@arrow@temp%
    \fi%
    \expandafter\global\expandafter\let\csname pgf@ar@cache@\pgf@arrow@id\endcsname\pgf@arrow@code%
  }%
}

% Ok, now run setup:
\def\pgf@arrows@copy@tipend{\pgf@arrows@the@tipend}
\def\pgf@arrows@copy@backend{\pgf@arrows@the@backend}
\def\pgf@arrows@copy@lineend{\pgf@arrows@the@lineend}
\def\pgf@arrows@zero{0pt}%

\let\pgf@arrows@saves\pgfutil@empty%
\let\pgf@arrows@convexhull\pgfutil@empty%
\let\pgf@arrows@the@tipend\pgf@arrows@zero%
\let\pgf@arrows@the@backend\pgf@arrows@zero%
\let\pgf@arrows@the@lineend\pgf@arrows@zero%
\let\pgf@arrows@the@rigidtipend\pgf@arrows@copy@tipend%
\let\pgf@arrows@the@rigidbackend\pgf@arrows@copy@backend%


\def\pgf@arrows@handle@reverse{%
  \pgf@x\pgf@arrows@the@rigidtipend\pgf@x-\pgf@x%
  \pgf@y\pgf@arrows@the@rigidbackend\pgf@y-\pgf@y
  \edef\pgf@arrows@the@rigidtipend{\the\pgf@y}%
  \edef\pgf@arrows@the@rigidbackend{\the\pgf@x}%
  \pgf@x\pgf@arrows@the@tipend\pgf@x-\pgf@x%
  \pgf@y\pgf@arrows@the@backend\pgf@y-\pgf@y
  \edef\pgf@arrows@the@tipend{\the\pgf@y}%
  \edef\pgf@arrows@the@backend{\the\pgf@x}%
  \pgf@x\pgf@arrows@the@lineend\pgf@x-\pgf@x\edef\pgf@arrows@the@lineend{\the\pgf@x}%
  \let\pgf@temp\pgf@arrows@convexhull%
  \let\pgf@arrows@convexhull\pgfutil@empty%
  \let\pgf@arrow@hull@point\pgf@arrow@hull@point@reverse%
  \pgf@temp%
}
\def\pgf@arrow@hull@point@reverse#1#2{%
  \pgf@x#1%
  \pgfarrowshullpoint{-\pgf@x}{#2}%
}

\def\pgf@nousepath@here#1{\pgferror{The definition of an arrow may not use \string\pgfusepath}}

\def\pgfarrowssavethe#1{%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@saves%
  \expandafter\expandafter\expandafter{\expandafter\pgf@arrows@saves\expandafter#1\the#1\relax}
}

\def\pgfarrowssave#1{%
  \expandafter\expandafter\expandafter\def%
  \expandafter\expandafter\expandafter\pgf@arrows@saves%
  \expandafter\expandafter\expandafter{\expandafter\pgf@arrows@saves\expandafter\def\expandafter#1\expandafter{#1}}
}

\def\pgfarrowshullpoint#1#2{%
  \pgf@x#1\relax%
  \pgf@y#2\relax%
  \edef\pgf@arrows@temp{\noexpand\pgf@arrows@convexhull\noexpand\pgf@arrow@hull@point{\the\pgf@x}{\the\pgf@y}}%
  \expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter\pgf@arrows@convexhull\expandafter\expandafter\expandafter{\pgf@arrows@temp}%
}

\def\pgfarrowssettipend#1{\pgf@x#1\edef\pgf@arrows@the@tipend{\the\pgf@x}}
\def\pgfarrowssetbackend#1{\pgf@x#1\edef\pgf@arrows@the@backend{\the\pgf@x}}
\def\pgfarrowssetlineend#1{\pgf@x#1\edef\pgf@arrows@the@lineend{\the\pgf@x}}
\def\pgfarrowssetrigidtipend#1{\pgf@x#1\edef\pgf@arrows@the@rigidtipend{\the\pgf@x}}
\def\pgfarrowssetrigidbackend#1{\pgf@x#1\edef\pgf@arrows@the@rigidbackend{\the\pgf@x}}


% Internal computatin of the line end (shortening) for an arrow 
% 
% #1 = arrow tip list
% 
% Description:
% 
% \pgf@xa will contain the necessary path shortening for the given
% arrow tip list, \pgf@xb will contain the total length of the arrow
% tip list (sum of the differences between tip end and back end plus
% the seps).

\def\pgf@arrow@compute@shortening#1{%
  \let\pgf@arrow@handle\pgf@arrow@compute@shortening@
  \let\pgf@arrow@handle@dot\pgf@arrow@after@line@endtrue%
  \pgf@arrow@after@line@endfalse%
  \pgf@xa0pt%
  \pgf@xb0pt%
  #1%
}
\newif\ifpgf@arrow@after@line@end

\def\pgf@arrow@compute@shortening@#1#2{%
  {\pgfarrows@getid{#1}{#2}\ifpgf@shorten@curved\global\pgf@shorten@curvedtrue\fi\expandafter}\expandafter\pgf@x\the\pgfarrowsep%
  \expandafter\expandafter\expandafter\pgf@arrow@cont@short\csname pgf@ar@ends@\pgf@arrow@id\endcsname%
}
\def\pgf@dot@text{.}

\def\pgf@arrow@cont@short#1#2#3{% tip end, back end, line end, sep
  \advance\pgf@xb by#1%
  \pgf@xc#2%
  \advance\pgf@xb by-\pgf@xc%
  \advance\pgf@xb by\pgf@x%
  \ifpgf@arrow@after@line@end%
    \advance\pgf@xa by#1%
    \advance\pgf@xa by\pgf@x%
    \pgf@xc#2%
    \advance\pgf@xa by-\pgf@xc%
  \else%
    \pgf@xa#1%
    \advance\pgf@xa by\pgf@x%
    \pgf@xc#3%
    \advance\pgf@xa by-\pgf@xc%
  \fi%
}




% Draw an arrow
% 
% #1 = arrow tip list
% #2 = total length of the arrow (the value of \pgf@xb computed by
% \pgf@arrow@compute@shortening)
% 
% Description:
% 
% Draws an arrow tip list. The coordinate system must have been
% transformed so that the to-be-drawn arrow points right and should
% "end" at the origin.

\def\pgf@arrow@draw@arrow#1#2{%
  {%
    \pgf@xb=#2%
    \pgftransformxshift{-\pgf@xb}%
    \let\pgf@arrow@handle\pgf@arrow@drawer
    \let\pgf@arrow@handle@dot\relax%
    #1%
  }%
}


\def\pgf@arrow@drawer#1#2{%
  % Prepare:
  {%
    \pgfarrows@getid{#1}{#2}%
    % Do shift:
    \expandafter\expandafter\expandafter\pgf@arrow@drawer@shift\csname pgf@ar@ends@\pgf@arrow@id\endcsname%
    % do swap:
    \ifpgfarrowswap%
      \pgftransformyscale{-1}%
    \fi%
    {%
      \csname pgf@ar@saves@\pgf@arrow@id\endcsname%
      \pgfscope%
        \pgf@arrows@color@setup%
        \pgflowlevelsynccm\csname pgf@ar@cache@\pgf@arrow@id\endcsname%
      \endpgfscope%
      \pgf@arrows@rigid@hull%
    }%  
  \expandafter}%
  % Transform to next tip:
  \expandafter\pgftransformxshift\expandafter{\the\pgf@xc}%
}

\def\pgf@arrows@color@setup{%
  \ifx\pgf@arrows@stroke@color\pgfutil@empty\else\pgfsetstrokecolor{\pgf@arrows@stroke@color}\fi%
  \ifx\pgf@arrows@fill@color\pgfutil@empty%
    \expandafter\expandafter\expandafter\ifx%
    \expandafter\csname\expandafter\string\expandafter\color@pgfstrokecolor\expandafter\endcsname\csname\string\color@pgffillcolor\endcsname%
    \else
      \pgfsetfillcolor{pgfstrokecolor}%
    \fi%
  \else%  
    \pgfsetfillcolor{\pgf@arrows@fill@color}%
  \fi%
}

\def\pgf@arrow@drawer@shift#1#2#3{% tip end, back end, line end, sep
  \pgf@xb#2\pgftransformxshift{-\pgf@xb}%
  \pgf@xc#1%
  \advance\pgf@xc by\pgfarrowsep%
  \advance\pgf@xc by-\pgf@xb%
}

\def\pgf@arrows@rigid@hull{%
  \ifpgf@relevantforpicturesize%
    \ifpgfoverlayarrowtips\else%
      % Do bb update:
      \expandafter\let\expandafter\pgf@temp\csname pgf@ar@hull@\pgf@arrow@id\endcsname%
      \ifx\pgf@temp\pgfutil@empty\else%
        \let\pgf@arrow@hull@point\pgf@arrow@hull@point@first%
        \pgf@temp%
        \pgf@arrow@update@bb%
      \fi%
    \fi%
  \fi
}


% If set to true, arrow tips do not count for the picture size
% (behaviour in old versions). Switched off by default.

\newif\ifpgfoverlayarrowtips


% Convex hull stuff:

\def\pgf@arrow@hull@point@first#1#2{%
%  {\pgfsys@beginscope\pgfpathcircle{\pgfqpoint{#1}{#2}}{0.1pt}\pgfusepathqfill\pgfsys@endscope}%
  \pgf@x#1\pgf@y#2%
  \pgf@xa\pgf@pt@aa\pgf@x%
  \advance\pgf@xa by\pgf@pt@ba\pgf@y%
  \pgf@ya\pgf@pt@ab\pgf@x%
  \advance\pgf@ya by\pgf@pt@bb\pgf@y%
  \pgf@xb\pgf@xa\pgf@yb\pgf@ya%
  \let\pgf@arrow@hull@point\pgf@arrow@hull@point@other%
}
\def\pgf@arrow@hull@point@other#1#2{%
%  {\pgfsys@beginscope\pgfpathcircle{\pgfqpoint{#1}{#2}}{0.1pt}\pgfusepathqfill\pgfsys@endscope}%
  \pgfutil@tempdima#1\pgfutil@tempdimb#2%
  \pgf@x\pgf@pt@aa\pgfutil@tempdima%
  \advance\pgf@x by\pgf@pt@ba\pgfutil@tempdimb%
  \pgf@y\pgf@pt@ab\pgfutil@tempdima%
  \advance\pgf@y by\pgf@pt@bb\pgfutil@tempdimb%
  \ifdim\pgf@x<\pgf@xa\pgf@xa\pgf@x\else\ifdim\pgf@x>\pgf@xb\pgf@xb\pgf@x\fi\fi%
  \ifdim\pgf@y<\pgf@ya\pgf@ya\pgf@y\else\ifdim\pgf@y>\pgf@yb\pgf@yb\pgf@y\fi\fi%
}

\def\pgf@arrow@update@bb{%
  \advance\pgf@xa by\pgf@pt@x%
  \advance\pgf@ya by\pgf@pt@y%
  \advance\pgf@xb by\pgf@pt@x%
  \advance\pgf@yb by\pgf@pt@y%
  \ifdim\pgf@picmaxx=-16000pt\relax%
    \global\pgf@picminx\pgf@xa%
    \global\pgf@picmaxx\pgf@xb%
    \global\pgf@picminy\pgf@ya%
    \global\pgf@picmaxy\pgf@yb%
  \else%
    \ifdim\pgf@xa<\pgf@picminx\global\pgf@picminx\pgf@xa\fi%
    \ifdim\pgf@ya<\pgf@picminy\global\pgf@picminy\pgf@ya\fi%
    \ifdim\pgf@xb>\pgf@picmaxx\global\pgf@picmaxx\pgf@xb\fi%
    \ifdim\pgf@yb>\pgf@picmaxy\global\pgf@picmaxy\pgf@yb\fi%
  \fi%
}


% Sets arrows
%
% #1 = An arrow specification of the form
%      <start spec>-<end spec>. This will call \pgfsetstartarrow{start
%        spec} and \pgfsetendarrow{end spec}.
%      
%      Alternatively, it may be of the form [options]. In this case,
%      the arrow options are set for the local scope and all arrows in
%      the current scope will have these options set.
%
% Example:
%
% \pgfsetarrows{-to}

\def\pgfsetarrows#1{\pgf@arrows#1\pgf@stop}
\def\pgf@arrows{\pgfutil@ifnextchar[\pgf@arrows@test@opt\pgf@arrows@}%}
\def\pgf@arrows@#1-#2\pgf@stop{%
  \pgfsetarrowsstart{#1}%
  \pgfsetarrowsend{#2}%
}
\def\pgf@arrows@test@opt[{%
  \pgfutil@ifnextchar-{\pgf@arrows@[}%} go back to normal reading for compat. reasons.
  \pgf@arrows@test@opt@%
}
\def\pgf@arrows@test@opt@#1]{%
  \pgfutil@ifnextchar\pgf@stop{%
    \let\pgf@arrows@options\pgf@arrows@options@scope%
    \pgfkeys{/pgf/@arrows/.cd,#1}%
    \let\pgf@arrows@options@scope\pgf@arrows@options%    
    % Ok, setup the options
    \pgfutil@gobble%
  }{%
    \pgf@arrows@[#1]% Oops: go back to normal mode
  }%
}

\let\pgf@arrows@options@scope\pgfutil@empty





%
% Predefined arrows:
% 


% A dot is used to indicate the end of the line:

\pgfdeclarearrow{
  name = .
}


% An underscore adds a space as in >_> or >_Â >. However, it will be
% faster to say ">[sep] >" or ">[sep=2pt] >".

\pgfdeclarearrow{
  name = _,
  defaults = {sep}
}



% Square Hooks are arrows heads that look like an I at the end of a line.

\pgfdeclarearrow{
  name = Square Hooks,
  defaults = {
    width = +4pt 4,
  },
  bending mode=polar,
  setup = {
    % Two useful numbers... 
    \pgfutil@tempdima\pgfarrowinset\ifdim\pgfutil@tempdima<.5\pgflinewidth\pgfutil@tempdima.5\pgflinewidth\fi%
    \pgfutil@tempdimb-\pgfarrowlength\advance\pgfutil@tempdimb by\pgfarrowinset\ifdim\pgfutil@tempdimb>-.5\pgflinewidth\pgfutil@tempdimb-.5\pgflinewidth\fi
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowwidth
    \pgfarrowssavethe\pgfutil@tempdima
    \pgfarrowssavethe\pgfutil@tempdimb
    % Infos:
    \pgfarrowssettipend{\pgfutil@tempdima}
    \pgfarrowssetrigidbackend{.5\pgflinewidth}
    \pgfarrowssetbackend{\pgfutil@tempdimb}
    \pgfarrowssetlineend{-.25\pgflinewidth}%
    % The hull:
    \pgfarrowshullpoint{\pgfutil@tempdima}{.5\pgfarrowwidth}%
    \pgfarrowshullpoint{\pgfutil@tempdimb}{.5\pgfarrowwidth}%
    \ifpgfarrowharpoon
      \pgfarrowshullpoint{.5\pgflinewidth}{-.5\pgflinewidth}%
    \else
      \pgfarrowshullpoint{\pgfutil@tempdima}{-.5\pgfarrowwidth}%
      \pgfarrowshullpoint{\pgfutil@tempdimb}{-.5\pgfarrowwidth}%
    \fi
  },
  code = {
    \pgfsetdash{}{+0pt}
    \pgfsetbuttcap
    \pgfsetmiterjoin
    \pgf@x\pgfutil@tempdima\advance\pgf@x by-.5\pgflinewidth%
    \pgf@y\pgfutil@tempdimb\advance\pgf@y by.5\pgflinewidth%
    % Case 1: No bar atop the I:
    \ifdim\pgf@x=\pgf@y%
      \pgfpathmoveto{\pgfqpoint{0pt}{.5\pgfarrowwidth}}
      \pgfpathlineto{\pgfqpoint{0pt}{\ifpgfarrowharpoon-.5\pgflinewidth\else-.5\pgfarrowwidth\fi}}
    \else
      % Case 2: Bar, but only in one direction:
      \ifdim\pgfutil@tempdima=.5\pgflinewidth%
        \pgfpathmoveto{\pgfqpoint{\pgfutil@tempdimb}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}}
        \pgfpathlineto{\pgfqpoint{0pt}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}}
        \ifpgfarrowharpoon%
          \pgfpathlineto{\pgfqpoint{0pt}{-.5\pgflinewidth}}%
        \else%
          \pgfpathlineto{\pgfqpoint{0pt}{-.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}}
          \pgfpathlineto{\pgfqpoint{\pgfutil@tempdimb}{-.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}}
        \fi
      \else% Case 3: Complete I:
        \pgfpathmoveto{\pgfqpoint{\pgfutil@tempdimb}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}}
        \pgfpathlineto{\pgfqpoint{\pgfutil@tempdima}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}}
        \pgfpathmoveto{\pgfqpoint{0pt}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}}
        \ifpgfarrowharpoon%
          \pgfpathlineto{\pgfqpoint{0pt}{-.5\pgflinewidth\advance\pgf@y by.5\pgflinewidth}}%
        \else%
          \pgfpathlineto{\pgfqpoint{0pt}{-.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}}
          \pgfpathmoveto{\pgfqpoint{\pgfutil@tempdimb}{-.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}}
          \pgfpathlineto{\pgfqpoint{\pgfutil@tempdima}{-.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}}
        \fi
      \fi
    \fi
    \pgfusepathqstroke
  },
  parameters = {
    \the\pgfarrowwidth,%
    \the\pgfarrowlength,%
    \the\pgfarrowinset,%
    \ifpgfarrowharpoon h\fi%
  },
}




% Generic "latex-like" arrow tip. This is the basic arrow tip used in
% latex's picture environment. You can configure its length and width.  

\pgfdeclarearrow{
  name = Latex,
  defaults = {
    length = +3.8pt 0.55 -0.45,
    width' = +0pt .75,
  },
  setup = {
    \pgf@xb\pgflinewidth
    \ifdim\pgfinnerlinewidth>0pt
      \advance\pgf@xb by-\pgfinnerlinewidth\pgf@xb.5\pgf@xb
    \fi
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowlength
    \pgfarrowssavethe\pgfarrowwidth
    % Infos:
    % Compute miter length:
    \pgfmathdivide@\pgfarrowlength\pgfarrowwidth%
    \let\pgf@temp@quot\pgfmathresult%
    \pgf@x\pgfmathresult pt%
    \pgf@x\pgfmathresult\pgf@x%
    \pgf@x9\pgf@x%
    \advance\pgf@x by1pt%
    \pgfmathsqrt@\pgf@x%
    \pgf@xc\pgfmathresult\pgf@xb%
    \pgfarrowssettipend{.741\pgfarrowlength\advance\pgf@x by.5\pgf@xc%
      \ifpgfarrowharpoon\pgf@xa\pgf@temp@quot\pgf@xb\advance\pgf@x by1.5\pgf@xa\fi% miter correction
    }
    \pgfarrowssetbackend{-.5\pgf@xb}
    \pgfarrowssetlineend{.2\pgf@xb}
    % The hull:
    \pgfarrowshullpoint{\pgfarrowlength}{\ifpgfarrowharpoon-.5\pgf@xb\else0pt\fi}%
    \pgfarrowshullpoint{0pt}{.5\pgfarrowwidth\ifpgfarrowharpoon\advance\pgf@y by-.5\pgf@xb\fi}%
    \pgfarrowshullpoint{0pt}{\ifpgfarrowharpoon-.5\pgf@xb\else-.5\pgfarrowwidth\fi}%
  },
  code = {
    \pgfsetdash{}{+0pt}
    \pgfsetmiterjoin
    \ifdim\pgfinnerlinewidth>0pt%
      \advance\pgflinewidth by-\pgfinnerlinewidth\pgflinewidth.5\pgflinewidth
      \pgfsetlinewidth{\pgflinewidth}
    \fi
    \pgfpathmoveto    {\pgfqpoint{.741\pgfarrowlength}{0pt}}
    \pgfpathcurveto   {\pgfqpoint{.65\pgfarrowlength}{.03\pgfarrowwidth}}
                      {\pgfqpoint{.25\pgfarrowlength}{.2\pgfarrowwidth}}
                      {\pgfqpoint{0pt}{.385\pgfarrowwidth}}
    \ifpgfarrowharpoon
      \pgfpathlineto  {\pgfpointorigin}
    \else  
      \pgfpathlineto  {\pgfqpoint{0pt}{-.385\pgfarrowwidth}}
      \pgfpathcurveto {\pgfqpoint{.25\pgfarrowlength}{-.2\pgfarrowwidth}}
                      {\pgfqpoint{.65\pgfarrowlength}{-.03\pgfarrowwidth}}
                      {\pgfqpoint{.741\pgfarrowlength}{0pt}}
    \fi
    \pgfpathclose
    \pgfusepathqfillstroke
  },
  parameters = {
    \the\pgfarrowlength,%
    \the\pgfarrowwidth,%
    \ifpgfarrowharpoon h\fi%
  },
}


% A basic stealth-fighter-like pointed arrow
%
% Example:
%
% \pgfsetarrows{-stealth}

\pgfdeclarearrow{
  name = Stealth,
  defaults = {
    length  = +2.24pt 2.4 .8,
    width'  = +0pt 1,
    inset'  = +0pt 0.375
  },
  setup = {
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowlength
    \pgfarrowssavethe\pgfarrowwidth
    % Infos:
    \pgfarrowssettipend{\pgfarrowlength}
    \ifpgfarrowreversed%
      \pgfarrowssetlineend{\pgfarrowinset \ifdim\pgfinnerlinewidth=0pt\advance\pgf@x by.5\pgflinewidth\fi}
    \else%
      \pgfmathdivide@{\pgfarrowlength}{\pgfarrowwidth}
      \pgfarrowssetlineend{%
        \pgfarrowlength%
        \advance\pgf@x by-\pgfmathresult\pgflinewidth%
        \advance\pgf@x by-.5\pgflinewidth
        \ifpgfarrowharpoon\advance\pgf@x by-\pgfmathresult\pgflinewidth\fi
        \ifdim\pgf@x<\pgfarrowinset\pgf@x\pgfarrowinset\fi
      }
    \fi%
    \pgfarrowssetrigidbackend{\pgfarrowinset}
    % The hull:
    \pgfarrowshullpoint{\pgfarrowlength}{\ifpgfarrowharpoon-.5\pgflinewidth\else0pt\fi}%
    \pgfarrowshullpoint{0pt}{.5\pgfarrowwidth\ifpgfarrowharpoon\advance\pgf@y by-.5\pgflinewidth\fi}%
    \ifpgfarrowharpoon
      \pgfarrowshullpoint{\pgfarrowinset}{-.5\pgflinewidth}%
    \else
      \pgfarrowshullpoint{0pt}{-.5\pgfarrowwidth}%
    \fi%
  },
  code = {
    \ifpgfarrowharpoon \pgftransformyshift{+-.5\pgflinewidth} \fi
    \pgfpathmoveto{\pgfqpoint{\pgfarrowlength}{0pt}}
    \pgfpathlineto{\pgfqpoint{0pt}{.5\pgfarrowwidth}}
    \pgfpathlineto{\pgfqpoint{\pgfarrowinset}{0pt}}
    \ifpgfarrowharpoon \else
    \pgfpathlineto{\pgfqpoint{0pt}{-.5\pgfarrowwidth}}
    \fi
    \pgfpathclose
    \pgfusepathqfill
  },
  parameters = {
    \the\pgfarrowlength,%
    \the\pgfarrowwidth,%
    \the\pgfarrowinset,%
    \ifpgfarrowharpoon h\fi%
    \ifpgfarrowreversed r\fi%
  },
}



% The original default arrow head used in TikZ. It is modeled on an
% old version of the \rightarrow head of the *old* Computer Modern
% fonts. 

\pgfdeclarearrow{
  name = Classical TikZ Rightarrow,
  defaults = {
    length  = +1.05pt 1.125,
    width'  = +0pt 2.133333
  },
  setup = 
  {
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowlength
    \pgfarrowssavethe\pgfarrowwidth
    % The extend:
    \pgfarrowssettipend{\pgfarrowlength\advance\pgf@x by.4\pgflinewidth}%
    \pgfarrowssetrigidbackend{\pgfarrowlength\advance\pgf@x by.4\pgflinewidth}%
    \ifpgfarrowreversed%
      \ifpgfarrowharpoon%
        % A reversed arrow needs a slightly different line end:
        \pgfarrowssetlineend{\pgfarrowlength\advance\pgf@x by.5\pgflinewidth}%
      \else%
        % A reversed arrow needs a slightly different line end:
        \pgfarrowssetlineend{\pgfarrowlength\advance\pgf@x by-.25\pgflinewidth}%
      \fi%
    \else%
      \pgfarrowssetlineend{\pgfarrowlength\advance\pgf@x by-.7\pgflinewidth}%
    \fi%
    \pgfarrowssetbackend{-.4\pgflinewidth}%
    % The hull:
    %  Tip:
    \pgfarrowshullpoint{\pgfarrowlength\advance\pgf@x by.4\pgflinewidth}{.4\pgflinewidth}%
    \pgfarrowshullpoint{\pgfarrowlength\advance\pgf@x by.4\pgflinewidth}{-.4\pgflinewidth}%
    %  Upper end:
    \pgfarrowshullpoint{.4\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by.4\pgflinewidth}%
    \pgfarrowshullpoint{-.4\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by.4\pgflinewidth}%
    %  Lower end:
    \ifpgfarrowharpoon
      \pgfarrowshullpoint{\pgfarrowlength\advance\pgf@x by-\pgflinewidth}{-.5\pgflinewidth}%    
      \pgfarrowshullpoint{-.4\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}%
    \else%
      \pgfarrowshullpoint{.4\pgflinewidth}{-.5\pgfarrowwidth\advance\pgf@y by-.4\pgflinewidth}%
      \pgfarrowshullpoint{-.4\pgflinewidth}{-.5\pgfarrowwidth\advance\pgf@y by-.4\pgflinewidth}%
    \fi
  },
  code = 
  {
    \pgfsetlinewidth{+.8\pgflinewidth}
    \pgfsetdash{}{+0pt}
    \pgfsetroundcap
    \pgfsetroundjoin
    \pgfpathmoveto
          {\pgfqpoint{0pt}{.5\pgfarrowwidth}}
    \ifpgfarrowharpoon
      \pgf@arrows@old@tikz@harpoon
    \else
      \pgfpathcurveto
          {\pgfqpoint{0.066666\pgfarrowlength}{0.3125\pgfarrowwidth}}
          {\pgfqpoint{.8\pgfarrowlength}{0.03125\pgfarrowwidth}}
          {\pgfqpoint{\pgfarrowlength}{0pt}}
      \pgfpathcurveto
          {\pgfqpoint{.8\pgfarrowlength}{-.03125\pgfarrowwidth}}
          {\pgfqpoint{0.066666\pgfarrowlength}{-.3125\pgfarrowwidth}}
          {\pgfqpoint{0pt}{-.5\pgfarrowwidth}}
      \pgfusepathqstroke
    \fi
  },
  parameters = {
    \the\pgfarrowlength,%
    \the\pgfarrowwidth,%
    \ifpgfarrowreversed r\fi%
    \ifpgfarrowharpoon h\fi
  },
}

\def\pgf@arrows@old@tikz@harpoon{
  \ifpgfarrowreversed
    \pgf@arrows@old@tikz@harpoon@reversed
  \else
    \pgfpathcurveto
      {\pgfqpoint{0.066666\pgfarrowlength}{0.3125\pgfarrowwidth}}
      {\pgfqpoint{.8\pgfarrowlength}{0.03125\pgfarrowwidth}}
      {\pgfqpoint{\pgfarrowlength}{0pt}}
    \pgfpathcurveto
      {\pgfqpoint{0.95\pgfarrowlength}{-0.125\pgflinewidth}}
      {\pgfqpoint{0.933333\pgfarrowlength}{-0.125\pgflinewidth}}
      {\pgfqpoint{0.933333\pgfarrowlength}{-0.125\pgflinewidth}}
    \pgfpathlineto
      {\pgfqpoint{0.8\pgfarrowlength}{-0.125\pgflinewidth}}
    \pgfusepathqstroke
  \fi
}
\def\pgf@arrows@old@tikz@harpoon@reversed{
    \pgfpathcurveto
      {\pgfqpoint{0.066666\pgfarrowlength}{0.3125\pgfarrowwidth}}
      {\pgfqpoint{.8\pgfarrowlength}{0.03125\pgfarrowwidth}}
      {\pgfqpoint{\pgfarrowlength}{0.125\pgflinewidth}}
    \pgfpathmoveto
      {\pgfqpoint{0pt}{.5\pgfarrowwidth}}
    \pgfpathcurveto
      {\pgfqpoint{0.066666\pgfarrowlength}{0.3125\pgfarrowwidth}}
      {\pgfqpoint{.8\pgfarrowlength}{0.03125\pgfarrowwidth}}
      {\pgfqpoint{\pgfarrowlength}{-0.125\pgflinewidth}}
    \pgfusepathqstroke
    \pgfsetlinewidth{+1.25\pgflinewidth}
    \pgfpathmoveto{\pgfqpoint{\pgfarrowlength\advance\pgf@x by0.6\pgflinewidth}{0pt}}
    \pgfpathlineto{\pgfqpoint{\pgfarrowlength}{0pt}}
    \pgfusepathqstroke
}


% An approximation to the new (past 1992) Computer Modern math arrow
% heads. This would be a better version of "to", so consider saying
% to/.tips=Computer Modern Rightarrow

\pgfdeclarearrow{
  name = Computer Modern Rightarrow,
  defaults = {
    length = +1.6pt 1.2, % 0pt 5.2
    width' = +0pt 2.3077
  },
  setup = 
  {
    % The following are needed in the code:
    \pgfarrowssavethe\pgfarrowlength
    \pgfarrowssavethe\pgfarrowwidth
    % The extend:
    \pgfarrowssettipend{.5\pgflinewidth}%
    \pgfarrowssetrigidbackend{.5\pgflinewidth}%
    \ifpgfarrowreversed%
      \ifpgfarrowharpoon%
        \pgfarrowssetlineend{.5\pgflinewidth}%
      \else%
        \pgfarrowssetlineend{-.5\pgflinewidth}%
      \fi%
    \else%
      \pgfarrowssetlineend{-.5\pgflinewidth}%
    \fi%
    \pgfarrowssetbackend{-\pgfarrowlength\advance\pgf@x by-.5\pgflinewidth}%
    % The hull:
    %  Tip:
    \pgfarrowshullpoint{.5\pgflinewidth}{.5\pgflinewidth}%
    \pgfarrowshullpoint{.5\pgflinewidth}{-.5\pgflinewidth}%
    %  Upper end:
    \pgfarrowshullpoint{-\pgfarrowlength\advance\pgf@x by.5\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}%
    \pgfarrowshullpoint{-\pgfarrowlength\advance\pgf@x by-.5\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by.5\pgflinewidth}%
    %  Lower end:
    \ifpgfarrowharpoon
      \pgfarrowshullpoint{-\pgflinewidth}{-.5\pgflinewidth}%    
      \pgfarrowshullpoint{-\pgfarrowlength\advance\pgf@x by-.5\pgflinewidth}{.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}%
    \else%
      \pgfarrowshullpoint{-\pgfarrowlength\advance\pgf@x by.5\pgflinewidth}{-.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}%
      \pgfarrowshullpoint{-\pgfarrowlength\advance\pgf@x by-.5\pgflinewidth}{-.5\pgfarrowwidth\advance\pgf@y by-.5\pgflinewidth}%
    \fi
  },
  code = 
  {
    \pgfsetdash{}{+0pt}
    \pgfsetroundcap
    \pgfsetroundjoin
    \pgfpathmoveto
        {\pgfqpoint{-\pgfarrowlength}{.5\pgfarrowwidth}}
    \pgfpathcurveto
        {\pgfqpoint{-0.81731\pgfarrowlength}{.2\pgfarrowwidth}}
        {\pgfqpoint{-0.41019\pgfarrowlength}{0.05833333\pgfarrowwidth}}
        {\pgfpointorigin}
    \ifpgfarrowharpoon
      \pgfpathlineto
        {\pgfqpoint{\ifpgfarrowreversed.5\else-\fi\pgflinewidth}{0pt}}
    \else    
      \pgfpathcurveto
        {\pgfqpoint{-0.41019\pgfarrowlength}{-0.05833333\pgfarrowwidth}}
        {\pgfqpoint{-0.81731\pgfarrowlength}{-.2\pgfarrowwidth}}
        {\pgfqpoint{-\pgfarrowlength}{-.5\pgfarrowwidth}}
    \fi
    \pgfusepathqstroke
  },
  parameters = {
    \the\pgfarrowlength,%
    \the\pgfarrowwidth,%
    \ifpgfarrowharpoon h\fi
    \ifpgfarrowharpoon r\fi
  },
}


% Default shorthands:

\pgfkeys{
  to /.tip            = {Classical TikZ Rightarrow},
  bar /.tip           = {Square Hooks[length=0pt,inset=0pt]},
  <-> /.tip           = {to},
  >-< /.tip           = {>[reversed]},
}



% Compatibility stuff: 

\pgfkeys {
  latex /.tip                  = {Latex},
  latex reversed/.tip          = {latex[reversed]},
  space /.tip                  = {_},
  to reversed /.tip            = {to[reversed]},
  left to /.tip                = {to[harpoon]},
  right to /.tip               = {to[harpoon,swap]},
  left to reversed /.tip       = {to[harpoon,reversed]},
  right to reversed /.tip      = {to[harpoon,swap,reversed]},
  stealth /.tip                = {Stealth},
  stealth reversed /.tip       = {stealth[reversed]},
  | /.tip                      = {bar},
  square bracket /.tip         = {Square Hooks[length=1pt 1.25]},
  [-] /.tip                    = {square bracket[length=1pt 1.25]},
  ]-[ /.tip                    = {square bracket[length=1pt 1.25, reversed]},
}

\def\pgf@arrows@direct@def#1#2{%
  \expandafter\pgf@arrows@direct@def@\expandafter{\csname pgf@ar@means@#2\endcsname}{#1}
}
\def\pgf@arrows@direct@def@#1#2{%
  \expandafter\def\csname pgf@arrows@direct@name@#2\endcsname{\pgf@arrow@handle@shorthand@empty{#1}}
}

\pgf@arrows@direct@def{start@[}{]}
\pgf@arrows@direct@def{start@]}{[}
\pgf@arrows@direct@def{start@spaced [}{spaced ]}
\pgf@arrows@direct@def{start@spaced ]}{spaced [}
\pgf@arrows@direct@def{end@[}{[}
\pgf@arrows@direct@def{end@]}{]}
\pgf@arrows@direct@def{end@spaced [}{spaced [}
\pgf@arrows@direct@def{end@spaced ]}{spaced ]}


% Compatibility stuff with old arrow system:

% Use "parameters" key instead:

\def\pgfsetarrowoptions#1#2{%
  \expandafter\def\csname pgf@arrow@compat@opt@#1\endcsname{#2}%
}

\def\pgfgetarrowoptions#1{%
  \csname pgf@arrow@compat@opt@#1\endcsname%
}

\def\pgfarrowsdeclare#1#2#3#4{%
  \pgfdeclarearrow{
    name  ={#1}-{#2},
    setup ={#3},
    code  ={#4},
    parameters/.expand once={\csname pgf@arrow@compat@opt@#2\endcsname}
  }  
  \expandafter\def\csname pgf@arrow@compat@opt@#2\endcsname{0}%
}

\def\pgfarrowsleftextend#1{\pgfmathsetlength\pgf@xa{#1}\pgfarrowssetbackend{\pgf@xa}}
\def\pgfarrowsrightextend#1{\pgfmathsetlength\pgf@xb{#1}\pgfarrowssettipend{\pgf@xb}}

\def\pgfarrowsdeclarealias#1#2#3#4{%
  \pgfdeclarearrow{%
    name  ={#1}-{#2},
    means ={#4}
  }
}

\def\pgfarrowsdeclarereversed#1#2#3#4{%
  \pgfdeclarearrow{%
    name ={#1}-{#2},
    means={{#4}[reversed]}
  }
}

\def\pgfarrowsdeclarecombine{\pgfutil@ifnextchar*{\pgfarrowsdeclarecombine@star}{\pgf@@arrowsdeclarecombine}}

\def\pgf@@arrowsdeclarecombine{\pgfutil@ifnextchar[{\pgf@arrowsdeclarecombine}{\pgf@arrowsdeclarecombine[0pt]}}
\def\pgf@arrowsdeclarecombine[#1]#2#3#4#5#6#7{%
  \pgfdeclarearrow{%
    name ={#2}-{#3},
    means={#5[sep=#1]#6}
  }
}
\def\pgf@linewidth@text{\pgflinewidth}
\def\pgfarrowsdeclarecombine@star*{\pgfutil@ifnextchar[{\pgf@arrowsdeclarecombine@star}{\pgf@arrowsdeclarecombine@star[0pt]}}
\def\pgf@arrowsdeclarecombine@star[#1]#2#3#4#5#6#7{%
  \pgfdeclarearrow{%
    name ={#2}-{#3},
    means={#5[sep=#1].#6}
  }
}

\def\pgfarrowsdeclaredouble{\pgfutil@ifnextchar[{\pgf@arrowsdeclaredouble}{\pgf@arrowsdeclaredouble[0pt]}}
\def\pgf@arrowsdeclaredouble[#1]#2#3#4#5{\pgfarrowsdeclarecombine[#1]{#2}{#3}{#4}{#5}{#4}{#5}}
\def\pgfarrowsdeclaretriple{\pgfutil@ifnextchar[{\pgf@arrowsdeclaretriple}{\pgf@arrowsdeclaretriple[0pt]}}
\def\pgf@arrowsdeclaretriple[#1]#2#3#4#5{%
  \pgfarrowsdeclarecombine[#1]{pgf@trip@#2}{pgf@trip@#3}{#4}{#5}{#4}{#5}%
  \pgfarrowsdeclarecombine[#1]{#2}{#3}{pgf@trip@#2}{pgf@trip@#3}{#4}{#5}%
}








\endinput


