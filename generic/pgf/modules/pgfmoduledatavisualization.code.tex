% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS $Header$

\usepgfmodule{oo,shapes}


% This module defines the basic framework for data visualization. 

% In order to visualize data, you first need data. The format for this
% data is not specified, indeed, different formats are possible. A
% data point is created each time the command \pgfdatapoint is
% used. The "parameters" of the data point are just the current values
% of the keys or macros in the current scope. 
%
% A set of data points created using the \pgfdata command.
% When a data point is created, a number of signals are emitted, see
% the description of \pgfdatapoint. To actually visualize something,
% objects should be created that listen to these signals and that
% handle them. 
%
% The following class manages a data visualization

\pgfooclass{data visualization}
{
  % Class data visualization
  %
  % This class is used to "manage" a data visualization. It provides
  % methods for hooking into the data visualization process and its
  % constructor initializes the signals that are issued during a data
  % visualization. 
  %
  % When a data visualization object is created, a whole bunch of
  % signal objects. You should then create objects that connect to
  % these signals. They will be emitted when datapoints come
  % available.
  %
  % It is permissible to have several data visualization objects
  % active at the same time.
  %
  % To use a data visualization object, you should (possibly
  % repeatedly) call the method add data() or the macro \pgfdata. You should also
  % create transformation, mapping and visualization objects. Then,
  % you should, first, call the method survey, which will "survey" the
  % data, allowing the mapping and bounding objects to compute the
  % correct ranges. You may then create further objects based on this
  % data. Then, you should call the "visualize" method, which will
  % invoke the visualization signals for the data points.


  % These attribute store code that should be executed at certain
  % points. The order is the following:
  %
  %  1. "before survey" code
  %  2. "begin survey" phase signal
  %  3. "at start survey" code
  %  4. data points are processed
  %  5. "at end survey" code
  %  6. "end survey" phase signal
  %  7. "after survey" code
  %
  % The first seven points will be repeated until the method "do
  % another survey" is no longer called during a survey.
  %
  %  8. "before visualization" code
  %  9. "begin visualization" phase signal
  % 10. "at start visualization" code
  % 11. data points are processed once more
  % 12. "at end visualization" code
  % 13. "end visualization" phase signal
  % 14. "after visualization" code
  \attribute before survey;
  \attribute at start survey;
  \attribute at end survey;
  \attribute after survey;
  \attribute before visualization;
  \attribute at start visualization;
  \attribute at end visualization;
  \attribute after visualization;
  
  %
  % Survey counts and handling
  %
  
  \attribute survey count=1;
  % Each time a survey is done before the visualization is done, this
  % count is incremented. Normally, there is only one survey, but
  % objects may request another survey or even more surveys to be
  % done, giving them a chance to setup further internal values. By
  % accessing this count (via the get survey count method), you can
  % find out which survey is currently being done.

  \attribute number of surveys=1;
  % By increasing this count, you can request additional surveys to be
  % done.

  
  % Stores the to-be-visualized data
  \attribute data;

  
  % Stores the signal objects
  \attribute prepare datapoint signal;
  \attribute map datapoint signal;
  \attribute transform datapoint signal;
  \attribute visualize datapoint signal;
  \attribute finish datapoint signal;
  \attribute survey datapoint signal;
  \attribute phase signal;
  \attribute path signal;

  
  % Constructor
  %
  % Inits the signals
  \method data visualization() {
    \pgfoonew{prepare datapoint signal}=new signal()%
    \pgfoonew{map datapoint signal}=new signal()%
    \pgfoonew{transform datapoint signal}=new signal()%
    \pgfoonew{visualize datapoint signal}=new signal()%
    \pgfoonew{finish datapoint signal}=new signal()%
    \pgfoonew{survey datapoint signal}=new signal()%
    \pgfoonew{phase signal}=new signal()%
    \pgfoonew{path signal}=new signal()%
    %
    % Store this object in a key
    %
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeyslet{/pgf/data visualization/obj}\pgf@dv@me
  }

  % The phase signal will emit the following constants:
  \def\pgfdvbeginsurvey{1}
  \def\pgfdvendsurvey{2}
  \def\pgfdvbeginvisualization{3}
  \def\pgfdvendvisualization{4}

  % The path signale will meit the following constants:
  \def\pgfdvpathmovetotoken{1}
  \def\pgfdvpathlinetotoken{2}

  % Method
  %
  % Connect the object #1's slot "#2" to the signal named "#3"
  \method connect(#1,#2,#3) {
    \pgfoovalueof{#3}.connect(#1,#2)
  }
  
  % Method
  %
  % Add data that is to be visualized. The code #1 should call the
  % \pgfdatapoint macro for each data point it creates.
  \method add data(#1) {
    \pgfooappend{data}{#1}
  }
  

  % Setters
  \method before survey(#1) {
    \pgfooappend{before survey}{#1}
  }
  \method at start survey(#1) {
    \pgfooappend{at start survey}{#1}
  }
  \method before visualization(#1) {
    \pgfooappend{before visualization}{#1}
  }
  \method at start visualization(#1) {
    \pgfooappend{at start visualization}{#1}
  }

  % Method
  \method at end survey(#1) {
    \pgfooprefix{at end survey}{#1}
  }
  \method after survey(#1) {
    \pgfooprefix{after survey}{#1}
  }
  \method at end visualization(#1) {
    \pgfooprefix{at end visualization}{#1}
  }
  \method after visualization(#1) {
    \pgfooprefix{after visualization}{#1}
  }


  % Method
  %
  % Copy the signals to macros. This is just for efficiency (ha!)
  \method prepare signal macros() {
    \pgfooget{prepare datapoint signal}\pgf@signalpreparedatapoint
    \pgfooget{map datapoint signal}\pgf@signalmapdatapoint
    \pgfooget{transform datapoint signal}\pgf@signaltransformdatapoint
    \pgfooget{visualize datapoint signal}\pgf@signalvisualizedatapoint
    \pgfooget{finish datapoint signal}\pgf@signalfinishdatapoint
    \pgfooget{survey datapoint signal}\pgf@signalsurveydatapoint
    \pgfooget{phase signal}\pgf@signalphase
    \pgfooget{path signal}\pgf@signalpath
  }

  
  % Survey method
  %
  % Call this method to "survey" the data. This should be done before
  % the "visualize" method is called.
  \method survey() {
    % Survey phase.
    \let\pgfdatapoint=\pgfdatapoint@surveyphase%
    \pgfoothis.prepare signal macros()
    \pgfooset{survey count}{1}
    \pgfutil@loop
      \pgfoovalueof{before survey}%
      \pgf@signalphase.emit(\pgfdvbeginsurvey)
      \pgfoovalueof{at start survey}
      \pgfoovalueof{data}%
      \pgfoovalueof{at end survey}
      \pgf@signalphase.emit(\pgfdvendsurvey)%
      \pgfoovalueof{after survey}
      \c@pgf@counta=\pgfoovalueof{survey count}\relax
      \c@pgf@countb=\pgfoovalueof{number of surveys}\relax
    \ifnum\c@pgf@counta<\c@pgf@countb
      \advance\c@pgf@counta by1\relax
      \pgfooeset{survey count}{\the\c@pgf@counta}
    \pgfutil@repeat  
  }

  % Getter
  \method get survey count(#1) {
    \pgfooget{survey count}{#1}
  }

  % Request another survey to be done
  \method do an additional survey() {
    \c@pgf@counta=\pgfoovalueof{number of surveys}\relax
    \advance\c@pgf@counta by1\relax
    \pgfooeset{number of surveys}{\the\c@pgf@counta}
  }
  
  % Visualize method
  %
  % This method will cause the actual visualization.
  \method visualize() {
    % Visualization phase.
    \let\pgfdatapoint=\pgfdatapoint@visualizationphase%
    \pgfoothis.prepare signal macros()
    \pgfoovalueof{before visualization}
    \pgf@signalphase.emit(\pgfdvbeginvisualization)%
    \pgfoovalueof{at start visualization}
    \pgfoovalueof{data}%
    \pgfoovalueof{at end visualization}
    \pgf@signalphase.emit(\pgfdvendvisualization)%
    \pgfoovalueof{after visualization}
  }
}  


%
% The data point keys
%
% Unlike other keys, the subkeys of /data point/ can simply be set
% directly. If the key has not been initialized, it will automatically
% be.
\pgfkeys{/data point/.unknown/.code={%
    \pgfkeyssetvalue{/data point/\pgfkeyscurrentname}{#1}
  }}




% Create and handle a data point
%
% Description:
%
% This command is called by the survey and the visualize methods
% whenever a complete data point has been produced. Depending on the
% current circumstances, different signals will be emitted.
%
% The data that is represented by the data point is not given as a
% parameter. Rather, it is stored in macros and keys, that is, the
% data point is conceptually given by the settings of all the keys and
% macros in the local scope.
%
% There are two phases to data processing: In the survey phase data
% points are produced and handled in order to find out things like
% their number or the minimum and maximum values of attributes, so
% that axes and picture sizes can be prepared correctly. In the
% visualization phase, data point are actually shown. 
%
% During the survey phase, for each data point the signal
% "surveydatapoint" is emitted.
%
% During the visualization phase, more signals are emitted. A prepare
% signal is emitted first, giving all objects a 
% chance to "prepare" for the data point. Note that it is permissible
% for an object to manipulate the data point here (and also
% in later on).
%
% Next, the command \pgfdvmapdatapointtocanvas is called. Mainly,
% the effect of this command is to setup the keys /data point/canvas x
% and /data point/canvas y, see the description of this command for
% more details. 
%
% The next step consists of signaling "visualize data point". Objects
% listening to this will cause some form of visualization of the
% data point to occur. 
%
% Before the visualization is started, it is checked whether the key
% /data point/name is set (to a non-empty value). If so,
% a coordinate is created with the given canvas x and y values and
% this key's value as name.
%
% Finally, finish data point allows objects to do any final processing
% of the data point.

\def\pgfdatapoint@surveyphase{%
  \pgf@signalpreparedatapoint.emit()%
  \pgf@signalmapdatapoint.emit()%
  \pgf@signalsurveydatapoint.emit()%
}

\def\pgfdatapoint@visualizationphase{%
  \pgf@signalpreparedatapoint.emit()%
  \pgfdvmapdatapointtocanvas%
  \pgfkeysifdefined{/data point/name}
  {%
    \pgfcoordinate{\pgfkeysvalueof{/data point/name}}{\pgfpointdvdatapoint}%
  }{}%
  \pgf@signalvisualizedatapoint.emit()%
  \pgf@signalfinishdatapoint.emit()%
}



% Compute a position of a data point
%
% Description:
%
% This command uses a special signal to compute the position where a
% data point should be visualized on the canvas. In detail, the
% following happens:
%
% A local scope is created and the
% transformation matrix is reset. Then, two signals are emitted: First,
% "map data points" and then "transform data point". The first
% lets listening objects "map" the object by setting up
% attributes of the data point. The second asks objects
% listening to this signal to transform  the current transformation
% matrix. After the signals, we compute where 
% the origin lies inside this transformed coordinate system. Then the
% two keys /data point/canvas x and /data point/canvas y are set to
% the values of this position. The local scope ends (but the settings
% of the keys persist by a bit of magic), thus restoring the
% transformation matrix to its original value.

\def\pgfdvmapdatapointtocanvas{%
  {%
    \pgfpointdvlocaldatapoint
    % Smuggle outside group
    \expandafter%
  }%
  \edef\pgf@marshal{%
    \noexpand\pgfkeyssetvalue{/data point/canvas x}{\the\pgf@x}
    \noexpand\pgfkeyssetvalue{/data point/canvas y}{\the\pgf@y}
  }%
  \pgf@marshal%
}

% Help functions for locating a canvas data point
%
% Description:
%
% The first function returns the data point computed by a
% canvasposition... call.

\def\pgfpointdvdatapoint{%
  \pgfqpoint{\pgfkeysvalueof{/data point/canvas x}}{\pgfkeysvalueof{/data point/canvas y}}%
}

\def\pgfpointdvlocaldatapoint{%
  {%
    % only returns the data point in \pgf@x and \pgf@y, does not set
    % canvas x and canvas y
    \pgf@signalmapdatapoint.emit()%
    \pgftransformreset%
    \pgf@signaltransformdatapoint.emit()%
    \pgfpointtransformed{\pgfpointorigin}%
  }%
}



%
% Special path constructions commands
%
%
% The following commands are used to construct paths based on
% datapoints.
%
% Normally, all these methods need to do is to compute the current
% canvas position of the current data point and then do a moveto or
% lineto to this position.
%
% However, when the coordinate system is weird, like with polar
% coordinates or spherical or log-polar coordinate or whatever, a
% straight line "along an attribute" is no longer a straight line.
% In this case, three actions can be taken:
%
% 1. The problem can be ignored, resulting in a wrong line.
% 2. Some clever algorithm kicks in an replaces the straight line by
%    the correct replacement.
%
% As always, when a computer tries to be clever, things can go
% wrong... Nevertheless, some support for the second method is
% given. This works as follows: Objects can register to the data
% visualization path signal. This signal is emitted every time the
% lineto or moveto commands are executed. If an object reacts to such
% a command and handles it, it should set
% \pgfdvpathcommandhandledtrue. 

\newif\ifpgfdvpathcommandhandled


% Handle a moveto
%
% This command has no parameters since the target of the moveto is
% given by the canvas position of the current local data point.
\def\pgfpathdvmoveto{%
  \pgfpathdv@generic{\pgfdvpathmovetotoken}{\pgfpathmoveto}
}
\def\pgfpathdv@generic#1#2{%
  {%
    \pgfdvpathcommandhandledfalse%
    \pgf@signalmapdatapoint.emit()%
    \pgf@signalpath.emit(#1)%
    \ifpgfdvpathcommandhandled%
    \else%
      \pgf@process{%
        \pgftransformreset%
        \pgf@signaltransformdatapoint.emit()%
        \pgfpointtransformed{\pgfpointorigin}%
      }%
      #2{}%
    \fi%
  }%
}


% Handle a lineto
%
% This command has no parameters since the target of the moveto is
% given by the canvas position of the current local data point.
\def\pgfpathdvlineto{%
  \pgfpathdv@generic{\pgfdvpathlinetotoken}{\pgfpathlineto}
}





%
%
% Data parsing and formatting
%
%



% Run the rendering pipeline on a dataset.
% 
% #1 = options with path /pgf/dataset/
% #2 = optionally data given inline in curly braces.
%
% Description:
%
% This command is define a data sets. For a single data visualization,
% multiple data sets can be defined, they will accumulate. Data can be
% in different formats, as specified by the "format" key, and you can
% define new formats.  
%
% The setting of the following keys is important:
%
% /pgf/data visualization/obj contains a handle to the dv-object
% /pgf/data/format stores the format (see below)
% /pgf/data/source determines where the data is.
%
% If source is empty, the data is stored in the argument that
% follows. Otherwise, the file whose name is stored in source is read.  
% This data is stored in an internal variable, which is local to the
% current group.
%
% After the group, the key "/pgf/data/continue code" will be
% executed.
%
% When the data is actually used later on (during a survey or a
% visualization), independently of what source is used, a format
% handler is started for each data set. This works as follows: first,
% the handler's startup code is executed. Then for each line of the
% data file/the data given inline, the line handler function is
% called. Finally, the data format end handler is called. 
%
% The format handler's job is to call \pgfdatapoint each time a
% complete data point has been produced.
%
% Example:
%
% \pgfoonew \dv=new data visualization()
% \pgfoonew \obj=new attribute mapper(...)
% ...
%
% \pgfkeys{/pgf/dataset/.cd,
%          column 1=dax/low,
%          column 2=dax/high,
%          column 3=dax/entry,
%          column 4=dax/exit}
%
% \pgfdata[format=space separated columns]
% {
%   % today
%   2000 2300 2100 2200 
%   2000 2350 2200 2500
%   2200 2300 2250 2260 
%   1800 2260 2260 1900 
%   2000 2300 2100 2200
% }
%
% \pgfdata[format=comma separated columns]
% {
%   % yesterday
%   2000, 2350, 2200, 2250 
%   2200, 2300, 2250, 2260 
% }
%
% \pgfdata[source=data,format=comma separated columns]
%
% \dv.survey()
% \dv.visualize()

\def\pgfdata{\pgfutil@ifnextchar[{\pgf@dataset@data@opt}{\pgf@dataset@data@opt[]}}%}
\def\pgf@dataset@data@opt[#1]{%
  % Ok, add one data thing...
  \pgfkeysvalueof{/pgf/data visualization/obj}.add data(\pgf@do@data{#1})%
  \begingroup%
    \pgfkeys{/pgf/data/.cd,/pgf/every data/.try,#1}%
    \pgfkeysgetvalue{/pgf/data/continue code}\pgf@dv@cont@code%
    \global\let\pgf@dv@cont@code\pgf@dv@cont@code%
    \pgfkeysgetvalue{/pgf/data/format}\pgf@dv@format%
    \expandafter\let\expandafter\pgf@dv@format@catcodes\csname pgfdv@format@\pgf@dv@format @catcodes\endcsname%
    \ifx\pgf@dv@format@catcodes\relax
      \PackageError{pgf}{Unknown data format '\pgf@dv@format'}{}%
    \else%
      \pgfkeysgetvalue{/pgf/data/source}\pgf@dv@source%
      \ifx\pgf@dv@source\pgfutil@empty%
        \let\pgf@next\pgf@dataset@grab@inline%
      \else%
        \let\pgf@next\pgf@dataset@grab@external%
      \fi%
      \pgf@next%
}
\def\pgf@dataset@grab@inline{%
  \pgfutil@ifnextchar\bgroup{%
    \begingroup%
    \catcode`\^^M=\active%
    \pgf@dv@format@catcodes%
    \pgf@dataset@grab@@inline}%
  {\PackageError{pgf}{Opening brace expected}{}}%
}
\def\pgf@dataset@grab@external{%
    \fi%
  \endgroup%
  \pgfkeysvalueof{/pgf/data visualization/obj}.add data({{{\pgf@dataset@do@external}}})%
  \pgf@dv@cont@code%
}

{\catcode`\^^M=\active%
  \gdef\pgf@dataset@grab@@inline#1{%
    \endgroup%
    \pgfkeysvalueof{/pgf/data visualization/obj}.add data({{{\pgf@dataset@do@inline#1^^M\pgf@@eol}}})%
    \fi%
  \endgroup%
  \pgf@dv@cont@code%
  }%
}%
\def\pgf@@eol{\pgf@eol}

\def\pgf@do@data#1#2{%
  \begingroup%
    \pgfkeys{/pgf/data/.cd,/pgf/every data/.try,#1}%
    \pgfkeysgetvalue{/pgf/data/format}\pgf@dv@format%
    \expandafter\let\expandafter\pgf@dv@format@line\csname pgfdv@format@\pgf@dv@format @line\endcsname%
    \expandafter\let\expandafter\pgf@dv@format@emptyline\csname pgfdv@format@\pgf@dv@format @empty\endcsname%
    \csname pgfdv@format@\pgfkeysvalueof{/pgf/data/format}@startup\endcsname%
    #2%
    \csname pgfdv@format@\pgfkeysvalueof{/pgf/data/format}@end\endcsname%
  \endgroup%
}


%
% Read external file
%

\def\pgf@dataset@do@external{%
  \csname pgfdv@format@\pgfkeysvalueof{/pgf/data/format}@catcodes\endcsname%
  \immediate\openin1=\pgfkeysvalueof{/pgf/data/source} %
  \ifeof1\relax
     \PackageError{pgf}{Data source '\pgfkeysvalueof{/pgf/data/source}' not found}{}%
  \else
    \pgf@dataset@readline%
  \fi
  \immediate\closein1%
}

\def\pgf@partext{\par}%
\def\pgf@dataset@readline{%
  \immediate\read1 to \pgf@temp%
  \ifx\pgf@temp\pgf@partext%
    \pgf@dv@format@emptyline%
  \else%
    \ifx\pgf@temp\pgfutil@empty%
      \pgf@dv@format@emptyline%
    \else%
      \expandafter\pgf@dv@format@line\pgf@temp\pgfeol%
    \fi%
  \fi%
  \ifeof1\else\expandafter\pgf@dataset@readline\fi%
}


%
% Read inline data
%

\def\pgf@dataset@do@inline{%
  \pgf@dv@handle@line%
}

{\catcode`\^^M=\active%
\gdef\pgf@dv@handle@line{%
  \pgfutil@ifnextchar^^M{\pgf@dv@format@emptyline\expandafter\pgf@dv@handle@line\pgfutil@gobble}%
  {\pgfutil@ifnextchar\pgf@@eol{\pgfutil@gobble}{\pgf@dv@handle@nonemptyline}}%
}%
\gdef\pgf@dv@handle@nonemptyline#1^^M{%
  \pgf@dv@format@line#1\pgfeol%
  \pgf@dv@handle@line%
}%
}

\pgfkeys{
  /pgf/data/data visualization obj/.initial=\undefined,
  /pgf/data/format/.initial=,
  /pgf/data/source/.initial=,
  /pgf/data/continue code/.initial=
}






% Define a data format
%
% #1 = format name
% #2 = catcode code
% #3 = startup code
% #4 = line arguments
% #5 = line code
% #6 = empty line code
% #7 = end code
%
% Description:
%
% This command defines a new data format for data visualization. When
% a data set is visualized and the format is set to #1, this handler
% is used to parse the data.
%
% In detail, the \dataset command will select a source. Before this
% source is read, #2 will be executed to setup the
% catcodes. Additionally, each time the data is parsed, #3 will be
% called. Then, for each nonempty line of the source, the
% command #5 is executed, where the line will be matched against the
% argument pattern given in #4. For empty lines, #6 will be executed
% instead. At the end of the source, #7 will be executed.

\def\pgfdeclaredataformat#1#2#3#4#5#6#7{%
  \expandafter\def\csname pgfdv@format@#1@catcodes\endcsname{#2}%
  \expandafter\def\csname pgfdv@format@#1@startup\endcsname{#3}%
  \expandafter\def\csname pgfdv@format@#1@line\endcsname#4\pgfeol{#5}%
  \expandafter\def\csname pgfdv@format@#1@empty\endcsname{#6}%
  \expandafter\def\csname pgfdv@format@#1@end\endcsname{#7}%
}



%
% Predefined standard formats
%

% TeX code format
%
% Description:
%
% The lines of the data set are assumed to contains executable TeX
% code that will call \pgfdatapoint.
%
% Example:
%
% \pgfdatavisualizationrender[format=TeX code]
% \dataset{
%   \pgfkeyssetvalue{/data point/x}{5}
%   \pgfkeyssetvalue{/data point/y}{5}
%   \pgfdatapoint
%   \pgfkeyssetvalue{/data point/x}{6}
%   \pgfkeyssetvalue{/data point/y}{6}
%   \pgfdatapoint
% }

\pgfdeclaredataformat{TeX code}{}{}{#1}{#1 }{}{}



% Key-value lines format
%
% Description:
%
% The lines of the data set are passed to \pgfkeys with the path set
% to /data point.
%
% Example:
%
% \pgfdatavisualizationrender[format=key value pairs]
% \dataset{
%   x=5, y=6, hi=9
%   x=7, y=6, lo=10
% }

\pgfdeclaredataformat{key value pairs}{}{}{#1}{\pgfkeys{/data point/.cd,#1}\pgfdatapoint}{}{}



% Comma separated columns
%
% Description:
%
% Each input line for this format should contain values separated by
% commas. For each nonempty line, the first value will be stored in
% /data point/<col1>, where <col1> is the value stored in /pgf/data
% visualization/column 1, the second value is stored in /data
% point/<col2>, where <col2> is the value stored in /pgf/data
% visualization/column 2, and so on. If a <colX> is empty, the value
% is ignored.
%
% Example:
%
% \pgfdatavisualizationrender[format=space separated columns,
%             column 1=dax/low,
%             column 2=dax/high,
%             column 3=dax/entry,
%             column 4=dax/exit]
% \dataset{
%   % today
%   2000, 2300, 2100, 2200 
%   2000, 2350, 2200  
%   2200, 2300, 2250, 2260 
%   1800, 2260, 2260, 1900 
%   2000, 2300, 2100, 2200
%    
%   % yesterday
%   2000, 2350, 2200, 2250 
%   2200, 2300, 2250, 2260 
%   1800, 2260, 2260, 1900 
% }

\pgfkeys{/pgf/data/.cd,
  column 1/.initial=x,
  column 2/.initial=y,
  column 3/.initial=z,
  column 4/.initial=,
  column 5/.initial=,
  column 6/.initial=,
  column 7/.initial=,
  column 8/.initial=}

\pgfdeclaredataformat{comma separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@csc#1,,,,,,,,,\pgfeol}{}{}

\def\pgf@dv@csc#1,#2,#3,#4,#5,#6,#7,#8,#9\pgfeol{%
  \ifx\pgf@dv@cola\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cola}{#1}\fi%
  \ifx\pgf@dv@colb\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colb}{#2}\fi%
  \ifx\pgf@dv@colc\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colc}{#3}\fi%
  \ifx\pgf@dv@cold\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cold}{#4}\fi%
  \ifx\pgf@dv@cole\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cole}{#5}\fi%
  \ifx\pgf@dv@colf\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colf}{#6}\fi%
  \ifx\pgf@dv@colg\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colg}{#7}\fi%
  \ifx\pgf@dv@colh\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colh}{#8}\fi%
  \pgfdatapoint%
}

\def\pgf@dv@separated@get{%
  \pgfkeysgetvalue{/pgf/data/column 1}\pgf@dv@cola%
  \pgfkeysgetvalue{/pgf/data/column 2}\pgf@dv@colb%
  \pgfkeysgetvalue{/pgf/data/column 3}\pgf@dv@colc%
  \pgfkeysgetvalue{/pgf/data/column 4}\pgf@dv@cold%
  \pgfkeysgetvalue{/pgf/data/column 5}\pgf@dv@cole%
  \pgfkeysgetvalue{/pgf/data/column 6}\pgf@dv@colf%
  \pgfkeysgetvalue{/pgf/data/column 7}\pgf@dv@colg%
  \pgfkeysgetvalue{/pgf/data/column 8}\pgf@dv@colh%
}


% Semicolon separated columns
%
% Description:
%
% Like comma separated columns, only with a semicolon as separator

\pgfdeclaredataformat{semicolon separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@scsc#1;;;;;;;;;\pgfeol}{}{}

\def\pgf@dv@scsc#1;#2;#3;#4;#5;#6;#7;#8;#9\pgfeol{%
  \ifx\pgf@dv@cola\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cola}{#1}\fi%
  \ifx\pgf@dv@colb\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colb}{#2}\fi%
  \ifx\pgf@dv@colc\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colc}{#3}\fi%
  \ifx\pgf@dv@cold\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cold}{#4}\fi%
  \ifx\pgf@dv@cole\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cole}{#5}\fi%
  \ifx\pgf@dv@colf\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colf}{#6}\fi%
  \ifx\pgf@dv@colg\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colg}{#7}\fi%
  \ifx\pgf@dv@colh\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colh}{#8}\fi%
  \pgfdatapoint%
}


% Colon separated columns
%
% Description:
%
% Like comma separated columns, only with a colon as separator

\pgfdeclaredataformat{colon separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@scsc#1:::::::::\pgfeol}{}{}

\def\pgf@dv@scsc#1:#2:#3:#4:#5:#6:#7:#8:#9\pgfeol{%
  \ifx\pgf@dv@cola\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cola}{#1}\fi%
  \ifx\pgf@dv@colb\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colb}{#2}\fi%
  \ifx\pgf@dv@colc\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colc}{#3}\fi%
  \ifx\pgf@dv@cold\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cold}{#4}\fi%
  \ifx\pgf@dv@cole\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cole}{#5}\fi%
  \ifx\pgf@dv@colf\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colf}{#6}\fi%
  \ifx\pgf@dv@colg\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colg}{#7}\fi%
  \ifx\pgf@dv@colh\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colh}{#8}\fi%
  \pgfdatapoint%
}




% Space separated columns
%
% Description:
%
% Each input line for this format should contain values separated by
% spaces. Otherwise, the format works like comma separated columns.
%
% Example:
%
% \pgfdatavisualizationrender[format=space separated columns,
%             column 1=dax/low,
%             column 2=dax/high,
%             column 3=dax/entry,
%             column 4=dax/exit]
% {
%   % today
%   2000 2300 2100 2200 
%   2000 2350 2200  
%   2200 2300 2250 2260 
%   1800 2260 2260 1900 
%   2000 2300 2100 2200
%    
%   % yesterday
%   2000 2350 2200 2250 
%   2200 2300 2250 2260 
%   1800 2260 2260 1900 
% }


\pgfdeclaredataformat{space separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@ssc#1 @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @\pgfeol}{}{}

\def\pgf@dv@ssc#1 #2 #3 #4 #5 #6 #7 #8 #9\pgfeol{%
  \pgf@dv@css@handle\pgf@dv@cola{#1}%
  \pgf@dv@css@handle\pgf@dv@colb{#2}%
  \pgf@dv@css@handle\pgf@dv@colc{#3}%
  \pgf@dv@css@handle\pgf@dv@cold{#4}%
  \pgf@dv@css@handle\pgf@dv@cole{#5}%
  \pgf@dv@css@handle\pgf@dv@colf{#6}%
  \pgf@dv@css@handle\pgf@dv@colg{#7}%
  \pgf@dv@css@handle\pgf@dv@colh{#8}%
  \pgfdatapoint%
}
\def\pgf@dv@css@handle#1#2{%
  \ifx#1\pgfutil@empty%
  \else%
    \def\pgf@temp{#2}%
    \ifx\pgf@temp\pgf@atpgfattext%
      \let\pgf@temp\pgfutil@empty%
    \fi%
    \pgfkeyslet{/data point/#1}\pgf@temp%
  \fi%
}
\def\pgf@atpgfattext{@\pgf @}




%
%
% Standard objects for data visualization
% 
%


%
% Transformers
%

\pgfooclass{linear transformer}
{
  % Class linear transformer
  %
  % This class is a transformer class. It reacts to the transform
  % datapoint signal. When this signal is raised, it will shift the
  % coordinate system as follows: If the current value of /data
  % point/this.attribute  is 0, then the system is shifted to the
  % current value of this.origin. If the current value is 1, the
  % system is shifted to this.origin + this.unit vector. For other
  % values of /data point/this.attribuate, the shift is interpolated
  % between these two values. 

  
  \attribute attribute;
  % The attribute (/data point/this.attribute) by which
  % the unit vector is multiplied. If it is empty (which is
  % different from 0), no transformation is done at all.

  \attribute origin = \pgfpointorigin;
  % The shift in case the /data point/this.attribute is 0.

  \attribute unit vector;
  % The coordinate system is additionally shifted by this amount
  % times the current value of /data point/this.attribute.

  
  % Constructor
  %
  % #1 = attribute that is being transformed. Example: x
  % #2 = a vector corresponding to one unit of #1.
  %      Example: \pgfpoint{1cm}{0cm}
  \method linear transformer(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgf@process{#2}
    \edef\pgf@temp{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
    \pgfoolet{unit vector}\pgf@temp%
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,transform,transform datapoint signal)
  }
  
  % Setter
  \method set origin(#1) {
    \pgf@process{#1}
    \edef\pgf@temp{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
    \pgfoolet{origin}\pgf@temp%
  }

  % Slot
  %
  % This slot should be connected to the transform datapoint
  % signal. When this signal is emitted, the coordinate system will be
  % shifted according to the current value of the attribute.
  \method transform() {
    \pgfkeysgetvalue{/data point/\pgfoovalueof{attribute}}\pgf@dv@val%
    \ifx\pgf@dv@val\pgfutil@empty%
    \else%
      \ifx\pgf@dv@val\relax%
      \else%
        \pgftransformshift{\pgfoovalueof{origin}}%
        \pgftransformshift{\pgfpointscale{\pgf@dv@val}{\pgfoovalueof{unit vector}}}%
      \fi%
    \fi%
  }

}


%
% Numerical mapping of attributes to other attributes
%

\pgfooclass{interval mapper}
{
  % Class interval mapper
  %
  % This interval mapper reacts to the map datapoint signal. Its purpose is to
  % map one attribute to another attribute. For the first attribute,
  % two intervals are specified: The clip interval and the in
  % interval. Values outside the clip-interval are not mapped (they are
  % clip away). Note that if the min-part of an interval is missing,
  % this means that -infinity is the lower bound and if the max part
  % is missing, then the max-part is infinity.
  %
  % In addition to the in interval [a,b] there is also an outinterval
  % [c,d]. Values in the range [a,b] are linearly mapped to the
  % range [c,d] and the result is stored in the second attribute.
  %
  % For instance, if the first range is [10,20] and the second range
  % is [0,100], then 10 is mapped to 0, 11 is mapped to 10, 20 is
  % mapped to 100 and 30 is mapped to 200.
  %
  % It is permissible to specify an additional non-linear
  % transformation function f. In this case, for an input value x the
  % position of f(x) inside the interval [f(a),f(b)] is determined and
  % this position is linearly mapped to [c,d]. 
  %
  % For example, if f(x) = log_10 (x) and the first range [a,b] =
  % [10,1000] and the second range is [1,2], then 10 is mapped to 1,
  % 100 is mapped to 1.5 (since f(100) = 3 lies in the middle
  % between f(10) = 2 and f(1000) = 4) and 100000 is mapped to 3.
  

  \attribute in;
  % The name of the input attribute. If the value of this attribute
  % is empty or undefined, no mapping is done.
  %
  % The in attribute may have a subkey called .../const. If this key
  % has a value different from \relax, it will always be used instead
  % of the in attribute itself. This can be useful to temporarily
  % set a constant value to a key inside a mapping chain.

  \attribute clip;
  % The code for clipping the interval. Will set \pgf@dvcliptrue, if a
  % clip is necessary.
  
  \attribute out;
  % The name of the output attribute.
  
  \attribute trans;
  % Stores (more or less) the transformation function.

  \attribute out min;
  % Start of the second range (the value of c).

  \attribute trans in min;
  % Transformed value of the start of the first range (the value
  % f(a)).

  \attribute scale;
  % The scaling factor, that is, the value of (f(d)-f(c))/(b-a).

  
  % Constructor
  %
  % #1 = input attribute. Example: velocity.
  % #2 = output attribute. Example: x
  % #3 = optional transformation function. The input value for this
  %      function is stored in the macro \pgfvalue, that is, when the
  %      function is called the macro will expand to something like
  %      "3.141". The output of the function should be stored in the
  %      macro \pgfmathresult.
  %
  % The intervals are set using setter methods later on.
  %
  \method interval mapper(#1,#2,#3) {
    \pgfooset{in}{#1}
    \pgfooset{out}{#2}
    \def\pgf@temp{#3}%
    \ifx\pgf@temp\pgfutil@empty%
    \else%
      \pgfooset{trans}{%
        \let\pgfvalue\pgfmathresult%
        #3%
      }%
    \fi%
  } 

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,map,map datapoint signal)
  }

  % Method
  \method set clip interval(#1) {
    #1.get min and max()%
    \pgfooeset{clip}{%
      \noexpand\pgf@dvclipfalse%
      \ifx\pgfdvmin\pgfutil@empty%
      \else%
        \noexpand\ifdim\noexpand\pgfmathresult pt<\pgfdvmin pt\relax\noexpand\pgf@dvcliptrue\noexpand\fi%
      \fi%
      \ifx\pgfdvmax\pgfutil@empty%
      \else%
        \noexpand\ifdim\noexpand\pgfmathresult pt>\pgfdvmax pt\relax\noexpand\pgf@dvcliptrue\noexpand\fi%
      \fi%
    }
  }

  % Method
  %
  % #1 = in interval minimum
  % #2 = in interval maximum
  % #3 = out interval minimum
  % #4 = out interval maximum
  %
  % This method will (re)compute the correct mappings for the interval
  % mapper. 
  \method set interval values(#1,#2,#3,#4) {
    {%
      % Let's start with the output, it's easier...
      \pgfmathparse{#3}
      \pgfooeset{out min}{\pgfmathresult}
      \pgfmathsubtract{#4}{#3}%
      \let\pgf@dv@out@diff=\pgfmathresult%
      % Ok, now the transformed input:
      \pgfmathparse{#1}
      \pgfoovalueof{trans}%
      \let\pgf@dv@min=\pgfmathresult
      \pgfooeset{trans in min}{\pgfmathresult}
      \pgfmathparse{#2}
      \pgfoovalueof{trans}%
      \pgfmathsubtract{\pgfmathresult}{\pgfoovalueof{trans in min}}%
      % 
      % Precompute the scaling
      %
      \let\pgf@dv@temp\pgfmathresult%
      \pgfmathdivide{\pgf@dv@out@diff}{\pgf@dv@temp}%
      \pgfooeset{scale}{\pgfmathresult}%
    }%
  } 

  % Slot
  \method map() {
    \pgfooget{scale}\pgf@temp
    \ifx\pgf@temp\pgfutil@empty%
      % not yet setup
    \else%
      \pgfkeysgetvalue{/data point/\pgfoovalueof{in}/const}\pgfmathresult%
      \ifx\pgfmathresult\relax%
        \pgfkeysgetvalue{/data point/\pgfoovalueof{in}}\pgfmathresult%
      \fi%
      \ifx\pgfmathresult\pgfutil@empty%
      \else%
        \ifx\pgfmathresult\relax%
        \else%
          % Clip?
          \pgfoovalueof{clip}%
          \ifpgf@dvclip%
            \pgfkeyslet{/data point/\pgfoovalueof{out}}\pgfutil@empty%
          \else%
            \pgfoovalueof{trans}%
            \pgfmathsubtract{\pgfmathresult}{\pgfoovalueof{trans in min}}%
            \pgfmathmultiply{\pgfmathresult}{\pgfoovalueof{scale}}%
            \pgfmathadd{\pgfmathresult}{\pgfoovalueof{out min}}%
            \pgfkeyslet{/data point/\pgfoovalueof{out}}\pgfmathresult%
          \fi%
        \fi%
      \fi%
    \fi%
  }
}

\newif\ifpgf@dvclip
\newif\ifpgf@dvignore

\pgfooclass{scaling mapper}
{
  % Class scaling mapper
  %
  % A scaling mapper is (mainly) used to scale an attribute in such a way
  % that it can be rendered easily on a page. The idea is that you
  % specify some attribute and a desired target interval size (like
  % [0,5]). The scaling mapper will then survey the data and will setup a
  % interval mapper in such a way that the minimum value present in the data is
  % mapped to 0 and the maximum to 5. However, it is also possible to,
  % say, only have the maximum value mapped to 5 and have 0 be mapped
  % to 0. Other, more complicated specifications are also possible.
  %
  % The scaling mapper internally creates several objects: First, a surveyor
  % for determining the minimum and maximum values of the attribute
  % and a interval mapper for then mapping the values to the scaled
  % values. Additionally, interval objects are needed.

  \attribute in;
  % The to-be-scaled attribute;

  \attribute out;
  % The attribute storing the scaled value.

  \attribute in range obj;
  % This interval keep track of the range of the in attribute
  
  \attribute scaling spec;
  % A specification of how the scaling should be performed.
  %
  % The format is the following:
  %
  % #1 at #2 and #3 at #4
  %
  % Here, #2 and #4 must be numbers. #1 and #3 can either be numbers
  % or #1 can be the text "min" and #3 can be the text "max".
  %
  % The effect of such a specification is the following: The value #1
  % is mapped to #2, the value #3 is mapped to #4 and values between
  % #1 and #3 (or outside this range) are mapped linearly to a value
  % between (or outside) #2 and #4. In case #1 is set to "min", the
  % smallest observed value of the in-attribute is mapped to #3 and
  % similarly for a value of "max" for #3.
  %
  % Additionally, as for a interval mapper, a function f might be specified
  % that deforms the linear mapping. In case f is specified,
  % f(#1) is mapped to #2 and f(#3) is mapped to #4.

  \attribute function;
  % Stores the function
  
  \attribute interval mapper;
  % Stores the interval mapper object
  
  
  % Constructor
  %
  % #1 = in attribute
  % #2 = out attribute
  % #3 = scaling specification
  % #4 = optional function
  %
  \method scaling mapper(#1,#2,#3,#4) {
    %
    % Save the parameters in attributes
    %
    \pgfooset{in}{#1}
    \pgfooset{out}{#2}
    \pgfooset{scaling spec}{#3}
    \pgfooset{function}{#4}
    %
    % Now setup the objects for the before survey phase
    %
    %
    % First, the in range interval
    \pgfoonew \pgf@dv@in@range@obj=new interval(,)
    \pgfoolet{in range obj}\pgf@dv@in@range@obj
    % Second, the in range surveyor. We do not need to store this
    % object, it will "do its work in the background"
    \pgfoonew \pgf@temp=new range surveyor(#1,\pgf@dv@in@range@obj)
    \pgf@temp.default connects()
    %
    %
    % The interval mapper:
    % 
    \pgfoonew{interval mapper}=new interval mapper(#1,#2,#4)
    \pgfoovalueof{interval mapper}.default connects()
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,phase,phase signal)
  }

  % Getter
  %
  % Returns an interval object that stores the range of the in
  % attribute. 
  \method get in range interval() {
    \pgfooget{in range obj}\pgfdvinrangeinterval
  }
  
  % Slot 
  \method phase(#1) {
    \ifx#1\pgfdvendsurvey
      % Ok, we setup the interval mapper.
      %
      % We start by computing the interval borders:
      \pgfoovalueof{in range obj}.get min and max()
      \ifx\pgfdvmin\pgfutil@empty% undefined, since no data points
      \else%
        \pgfooget{scaling spec}\pgf@temp
        \expandafter\pgf@lib@dv@parse@scaling\pgf@temp\pgf@stop%
        \pgfoovalueof{interval mapper}.set interval values(
          \pgf@lib@dv@min,\pgf@lib@dv@max,
          \pgf@lib@dv@min@at,\pgf@lib@dv@max@at)
      \fi
    \fi
  }

  
  % Internal helper
  \def\pgf@lib@dv@parse@scaling#1 at#2and #3 at#4\pgf@stop{%
    \def\pgf@lib@dv@min{#1}%
    \pgfmathparse{#2}
    \let\pgf@lib@dv@min@at\pgfmathresult%
    \def\pgf@lib@dv@max{#3}%
    \pgfmathparse{#4}
    \let\pgf@lib@dv@max@at\pgfmathresult%
    \ifx\pgf@lib@dv@min\pgf@min@text%
      \let\pgf@lib@dv@min\pgfdvmin
    \else
      \pgfmathparse{\pgf@lib@dv@min}
      \let\pgf@lib@dv@min\pgfmathresult
    \fi
    \ifx\pgf@lib@dv@max\pgf@max@text%
      \let\pgf@lib@dv@max\pgfdvmax
    \else
      \pgfmathparse{\pgf@lib@dv@max}
      \let\pgf@lib@dv@max\pgfmathresult
    \fi
  }
  \def\pgf@min@text{min}
  \def\pgf@max@text{max}
}





%
% Surveyors
%

\pgfooclass{range surveyor}
{
  % Class range surveyor
  %
  % A range surveyor is used only in the survey phase. Its job is to
  % determine the minimum and maximum values of an attribute that are
  % "seen" during the survey phase. Based on this value, the size of,
  % say, an axis can be detemined later on.

  \attribute attribute;
  % The to-be-surveyed attribute

  \attribute interval obj;
  % The interval object that protocols the minimum and maximum
  % values. 


  % Constructor
  %
  % #1 = the attribute
  % #2 = handle to the interval object
  %
  \method range surveyor(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfoolet{interval obj}#2
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,survey,survey datapoint signal)
  }

  % Slot
  %
  % This slot should be connected to the survey datapoint signal. For
  % each datapoint, this method will call the adjust method of the
  % interval.
  %
  \method survey() {
    \pgfkeysgetvalue{/data point/\pgfoovalueof{attribute}}\pgf@dv@val%
    \pgfoovalueof{interval obj}.adjust(\pgf@dv@range@surv)
  }

  \def\pgf@dv@range@surv{%
    \ifx\pgf@dv@val\pgfutil@empty%
    \else%
      \ifx\pgf@dv@val\relax%
      \else%
        % Now, protocol value
        \ifx\pgfdvmin\pgfutil@empty%
          \let\pgfdvmin\pgf@dv@val%
        \else%
          \ifdim\pgf@dv@val pt<\pgfdvmin pt%
            \let\pgfdvmin\pgf@dv@val%
          \fi%
        \fi%
        \ifx\pgfdvmax\pgfutil@empty%
          \let\pgfdvmax\pgf@dv@val%
        \else%
          \ifdim\pgf@dv@val pt>\pgfdvmax pt%
            \let\pgfdvmax\pgf@dv@val%
          \fi%
        \fi%
      \fi%
    \fi
  }    
}



%
% Visualizers
%

\usepgflibrary{plothandlers}


\pgfooclass{plot mark visualizer}
{
  % Class plot mark visualizer
  %
  % This visualizer will put a little marking at each data point. The
  % marking is a plot mark as defined in pgf's plot mark library.
  %
  % By default, each data point is visualized by a plot mark. This can
  % be changed by setting the "zero trigger" to a different value. The
  % zero trigger is the name of an attribute and the plot mark is
  % shown only when this attribute is zero. For instance, you can set
  % the zero trigger to an attribute that holds the value of a
  % repetive count down from 10 downward. The effect of this will be
  % that only every tenth data point will be marked.
  
  \attribute mark;
  % A plot mark like "star" or "oplus", see the plot mark library for
  % possible values.  
  
  \attribute zero trigger=always 0;
  % Name of an attribute that, when its value is zero, causes a plot
  % mark to be placed at the data point's position. The default
  % attribute is always 0, so every data point gets a plot mark.
  
  \attribute size=\pgfplotmarksize;
  % The size of the plot mark.

  
  % Constructor
  %
  % #1 = plot mark like "star" or "asterix"
  %
  \method plot mark visualizer(#1) {
    \pgfooset{mark}{#1}
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,visualize,visualize datapoint signal)
  }

  % Setter
  \method set size(#1) {
    \pgfooset{size}{#1}
  }

  % Setter
  \method set zero trigger(#1) {
    \pgfooset{zero trigger}{#1}
  }

  % Slot
  \method visualize() {
    {%
      \pgfkeysgetvalue{/data point/\pgfoovalueof{zero trigger}}\pgf@dv@trig%
      \ifx\pgf@dv@trig\pgf@dv@zero@text%
        \pgfplotmarksize\pgfoovalueof{size}
        \pgftransformshift{\pgfpointdvdatapoint}
        \pgfuseplotmark{\pgfoovalueof{mark}}
      \fi%
    }%
  }

  \def\pgf@dv@zero@text{0}
}



\pgfooclass{plot handler visualizer}
{
  % Class plot hanlder visualizer
  %
  % This visualizer uses a plot handler to visualize data points. As
  % the data points are processed, the canvas positions of the data
  % points are recorded. At the end of the visualization phase, the
  % recorded stream of canvas position is the visualized (rendered)
  % using a plot handler. For instance, when the lineto plot handler
  % is used, the data points are connected by straight lines, when the
  % curveto plot handler is used, they are connected by smooth curves
  % and so on.
  %
  % Since plot lines are not drawn immediately, but only at the end,
  % when everything has been collected, multiple plot handlers can
  % coexist peacefully at the same time.

  \attribute handler;
  % The to-be-used handler
  
  \attribute use path=\pgfusepath{stroke};
  % The default action to be taken on the path
  
  \attribute positions;
  % An internal protocol of the positions on the stream
  
  \attribute cache;
  % An internal cache. Positions are first inserted into this
  % cache. Every 100 steps this cache is moved to positions. The idea
  % behind this is that it will avoid the quadratic time increase that
  % is normally caused when a protocol is build in TeX.

  
  % Constructor
  %
  % #1 = A handler like \pgfplothandlerlineto
  %
  \method plot handler visualizer(#1) {
    \pgfooset{handler}{#1}
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,protocol,visualize datapoint signal)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,phase,phase signal)
  }

  % Setter
  \method set use path(#1) {
    \pgfooset{use path}{#1}
  }

  % Slot
  \method protocol() {
    % Cache it
    \pgfooget{cache}\pgf@dv@cache
    \edef\pgf@dv@add{\noexpand\pgf@dv@ph{\pgfkeysvalueof{/data point/canvas x}}{\pgfkeysvalueof{/data point/canvas y}}}%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\pgf@dv@cache%
    \expandafter\expandafter\expandafter{\expandafter\pgf@dv@cache\pgf@dv@add}%
    % Possibly flush cache
    \global\advance\pgf@lib@dv@cache@count by1\relax%
    \ifnum\pgf@lib@dv@cache@count=100\relax%
      \global\pgf@lib@dv@cache@count=0\relax%
      % Append cache to positions
      \pgfooget{positions}\pgf@dv@temp
      \expandafter\expandafter\expandafter\def%
      \expandafter\expandafter\expandafter\pgf@dv@temp%
      \expandafter\expandafter\expandafter{\expandafter\pgf@dv@temp\pgf@dv@cache}%
      \pgfoolet{positions}\pgf@dv@temp
      \let\pgf@dv@cache\pgfutil@empty
    \fi
    \pgfoolet{cache}\pgf@dv@cache
  }

  % Slot
  \method phase(#1) {%
    \ifx#1\pgfdvendvisualization%
      \pgfoothis.render()%
    \fi%
  }

  % Internal method
  \method render() {
    \pgfoovalueof{handler}
    \pgfplotstreamstart
    \pgfoovalueof{positions}
    \pgfoovalueof{cache}
    \pgfplotstreamend
    \pgfoovalueof{use path}
    \pgfoolet{positions}\pgfutil@empty
  }

  \def\pgf@dv@ph#1#2{\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
}

\newcount\pgf@lib@dv@cache@count




%
% Axis visualizers
%

\pgfooclass{axis visualizer}
{
  % Class axis visualizer
  %
  % The job of this class is to visualize an axis. By (my) definition,
  % an axis is the line that results when a single attribute is varied
  % between two values. 
  %
  % Visualizing an axis is somewhat more tricky than one might expect:
  % In order to visualize a horizontal axis, we might need to
  % visualize it several time in different ways and at different
  % vertical positions. Indeed, when the plot is three-dimensional or
  % of an even higher dimension, it may be necessary to visualize the
  % axis many times and different logical and canvas positions.
  %
  % Axes will also often be slightly larger than the scaling area in
  % order to create an effect of "continuity".
  %
  % Ticks on an axis also need special treatment. In order to draw a
  % tick, another axis is typically needed; this second axis
  % determines the direction of the ticks (which is not necessarily
  % orthogonal to the axis itself, for instance in a
  % 3d-plot). However, the second axis may also be missing, in which
  % case the tick is drawn orthogonally to the first tick.

  \attribute attribute;
  % The attribute whose variation produces the axis

  \attribute interval obj;
  % An interval object that stores the minimum and maximum values of
  % the attribute between which the axis is drawn.

  \attribute use path=\pgfusepath{stroke};
  % Path usage command for drawing the axis
  
  \attribute use tick path=\pgfusepath{stroke};
  % Path usage command for drawing a tick
  

  % Constructor
  %
  % #1 = attribute
  % #2 = interval obj
  %
  \method axis visualizer(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfoolet{interval obj}{#2}
  }

  % Method
  \method default connects() {
    % Does not listen to any signals, you have to invoke methods the
    % visualization methods directly. 
  }

  % Setter
  \method set use path(#1) {
    \pgfooset{use path}{#1}
  }

  % Setter
  \method set use tick path(#1) {
    \pgfooset{use tick path}{#1}
  }
 


  %
  % Visualization methods
  %

  % Method
  %
  % #1 = offset at minimum value given as a dimension (typically negative)
  % #2 = offset at maximum value given as a dimension (typically positive)
  %
  % Description:
  %
  % This method will create a line path and then apply the "use path"
  % attribute to it. This line path results from the "attribute" to be
  % varied from the minimum value of the "interval obj" to the maximum
  % value of this interval. The values of the other attributes are
  % also important since they determine the position of the
  % axis. Additionally, the start point of the line is offset by #1
  % along the direction of the axis, where #1 should be given as a
  % dimension like "2pt". Similarly for the end point. 
  %
  \method visualize(#1,#2) {
    {%
      % we assume that the current data point settings determine where
      % the axis should go
      %
      % We now compute the start and the end points
      %
      \pgfooget{interval obj}\pgf@dv@interval
      \pgf@dv@interval.get min and max()%
      % Ok, got the values
      % Save them.
      \let\pgf@dv@av@min=\pgfdvmin
      \let\pgf@dv@av@max=\pgfdvmax
      \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@av@min}%
      % Ok, that's where we start
      \pgfpathdvmoveto%
      % now the end:
      \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@av@max}%
      \pgfpathdvlineto%
      % Finally, use the path:
      \pgfoovalueof{use path}%
    }%
  }  
}



%
% Help classes
%

\pgfooclass{interval}
{
  % Class interval
  %
  % Instances of this class store intervals. When either the min or
  % the max value is empty, this corresponds to "not yet set", (not to
  % "infinity). 

  \attribute min;
  % The minimum value of the interval
  
  \attribute max;
  % The maximum value of the interval

  % Constructor
  %
  % #1 = initial minimum value
  % #2 = initial maximum value
  %
  \method interval(#1,#2) {
    \pgfooset{min}{#1}
    \pgfooset{max}{#2}
  }

  % Method
  \method default connects() {
  }

  % Sets the minimum/maximum to a new value
  \method set min(#1) {
    \pgfooset{min}{#1}
  }  
  \method set max(#1) {
    \pgfooset{max}{#1}
  }

  % Getter
  %
  % Returns the current values of the minimum and maximum in the
  % macros \pgfdvmin and \pgfdvmax.
  \method get min and max() {
    \pgfooget{min}\pgfdvmin
    \pgfooget{max}\pgfdvmax
  }

  % Adjusts the mimum and maximum values
  %
  % #1 = some code. When this code is executed, the values of
  %      \pgfdvmin and \pgfdvmax will be set to the current values of
  %      the minimum/maximum. The code may change these values. The
  %      changed values will then be stored.
  %
  % This method does nothing that cannot be achieved also by calling
  % set/get methods, but it is easier to use and faster.
  \method adjust(#1) {
    {%
      \pgfooget{min}\pgfdvmin
      \pgfooget{max}\pgfdvmax
      #1%
      \pgfoolet{min}\pgfdvmin
      \pgfoolet{max}\pgfdvmax
    }%
  }
}



\pgfooclass{count}
{
  % Class count
  %
  % This class can be used to count the number of data points that are
  % present or that have a certain property. By default, for every
  % data point a counter is incremented and the value of this counter
  % is stored in an attribute. You can also specify an increment for
  % the counter and some action that should be taken when the counter
  % reaches zero. You can also specify that certain data points should
  % not have an effect on the counter.
  %
  % Counters can serve different purposes.
  %
  % 1. For plotting points in a table or sequence, the counter can be
  %    used to provide the position along one axis.
  % 2. By using the counter as a repetitive count down one can for
  %    instance have only every 10th data point be marked.
  
  \attribute attribute;
  % The attribute that will be set to the current value of the counter
  
  \attribute val=0;
  % The current value of the counter
  
  \attribute step=1;
  % The stepping by which the counter is incremented for each
  % datapoint
  
  \attribute start val=0;
  % The start value of the counter
  
  \attribute zero action=;
  % Some action to be taken when the counter has the value zero.
  
  \attribute filter=;
  % This attribute stores some code that is executed for each
  % data point. If the data point sets the TeX-if ifpgfdvfilterout to
  % true, then the counter is not incremented.

  
  % Constructor
  %
  % #1 = The attribute in which the counter value is stored
  %
  \method count(#1) {
    \pgfooset{attribute}{#1}
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,apply,prepare datapoint signal)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,phase,phase signal)
  }

  % Setter
  \method set value(#1) {
    \pgfooset{val}{#1}
    \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{#1}%
  }

  % Setter
  \method set start value(#1) {
    \pgfooset{start val}{#1}
  }

  % Setter
  \method set filter(#1) {
    \pgfooset{filter}{#1}
  }

  % Setter
  \method set step(#1) {
    \pgfooset{step}{#1}
  }

  % Setter
  \method set zero action(#1) {
    \pgfooset{zero action}{#1}
  }

  % Method
  %
  % #1 = a value from which we count down.
  %
  % This method can be used to turn the counter into a count
  % down. Each time zero is reached, the counter is reset to #1.
  %
  \method count down(#1) {
    \pgfooset{step}{-1}
    \edef\pgf@temp{\noexpand\pgfooset{val}{#1}}
    \pgfoolet{zero action}\pgf@temp
    \pgfooeset{start val}{#1}
  }

  % Slot
  \method apply() {
    \pgfdvfilteroutfalse%
    \pgfoovalueof{filter}%
    \ifpgfdvfilterout%
    \else%
      \pgfmathparse{\pgfoovalueof{val}+\pgfoovalueof{step}}%
      \pgfoolet{val}\pgfmathresult%
      \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfmathresult%
      \ifdim\pgfmathresult pt=0pt\relax%
        \pgfoovalueof{zero action}%
      \fi%
    \fi%
  }

  % Slot 
  \method phase(#1) {
    \ifx#1\pgfdvbeginsurvey
      \pgfooeset{val}{\pgfoovalueof{start val}}
    \else \ifx#1\pgfdvbeginvisualization
      \pgfooeset{val}{\pgfoovalueof{start val}}
    \fi\fi
  }
}

\newif\ifpgfdvfilterout




\pgfooclass{accumulator}
{
  % Class accumulator
  %
  % This class is used to keep track of the sum of the values of some
  % attribute. When this object is connected to some attribute, the
  % subkey attribute/sum will always contain the sum of all values in
  % all previous data points with respect to this
  % attribute. Furthermore, the subkey attribute/prev key will hold
  % the previous sum, which is sometimes also useful to have access
  % to. 

  \attribute attribute;
  % The attribute to-be-accumulated
  
  \attribute sum=0;
  % The initial value of the sum

  % Constructor
  %
  % #1 = to-be-accumulated attribute
  \method accumulator(#1) {
    \pgfooset{attribute}{#1}
    \pgfoothis.reset()
  }

  % Method
  \method default connects() {
    \pgfoothis.get handle(\pgf@dv@me)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,apply,prepare datapoint signal)
    \pgfkeysvalueof{/pgf/data visualization/obj}.connect(\pgf@dv@me,phase,phase signal)
  }

  % Slot
  \method apply() {
    \pgfooget{sum}\pgf@temp
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}/prev sum}\pgf@temp
    \pgfmathadd{\pgfkeysvalueof{/data point/\pgfoovalueof{attribute}}}{\pgfoovalueof{sum}}
    \pgfoolet{sum}\pgfmathresult
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}/sum}\pgfmathresult
  }

  % Method
  %
  % Use this method to reset the sum at any point.
  %
  \method reset() {
    \pgfooset{sum}{0}
    \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}/prev sum}{0}
    \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}/sum}{0}
  }

  % Slot
  \method phase(#1) {
    \ifx#1\pgfdvbeginsurvey
      \pgfoothis.reset()
    \else \ifx#1\pgfdvbeginvisualization
      \pgfoothis.reset()
    \fi\fi
  }
}







%
%
% Help keys and, attributes
%
%

\pgfkeys{% do not even think of changing the values of the following:
  /data point/always true/.initial=true,
  /data point/always false/.initial=false,
  /data point/always 0/.initial=0,
  /data point/always 1/.initial=1,
  /data point/always empty/.initial=%
}

\pgfoonew \pgfdatavisualizationunitinterval=new interval(0,1)
\pgfoonew \pgfdatavisualizationemptyinterval=new interval(,)




\endinput






